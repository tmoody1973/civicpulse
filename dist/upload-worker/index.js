globalThis.__RAINDROP_GIT_COMMIT_SHA = "d1ae57f18adae2ce7b0b9c57e09b23ccb53ceeff"; 
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// node_modules/@smithy/protocol-http/dist-es/extensions/httpExtensionConfiguration.js
var getHttpHandlerExtensionConfiguration, resolveHttpHandlerRuntimeConfig;
var init_httpExtensionConfiguration = __esm({
  "node_modules/@smithy/protocol-http/dist-es/extensions/httpExtensionConfiguration.js"() {
    "use strict";
    getHttpHandlerExtensionConfiguration = (runtimeConfig) => {
      return {
        setHttpHandler(handler) {
          runtimeConfig.httpHandler = handler;
        },
        httpHandler() {
          return runtimeConfig.httpHandler;
        },
        updateHttpClientConfig(key, value) {
          runtimeConfig.httpHandler?.updateHttpClientConfig(key, value);
        },
        httpHandlerConfigs() {
          return runtimeConfig.httpHandler.httpHandlerConfigs();
        }
      };
    };
    resolveHttpHandlerRuntimeConfig = (httpHandlerExtensionConfiguration) => {
      return {
        httpHandler: httpHandlerExtensionConfiguration.httpHandler()
      };
    };
  }
});

// node_modules/@smithy/protocol-http/dist-es/extensions/index.js
var init_extensions = __esm({
  "node_modules/@smithy/protocol-http/dist-es/extensions/index.js"() {
    "use strict";
    init_httpExtensionConfiguration();
  }
});

// node_modules/@smithy/types/dist-es/abort.js
var init_abort = __esm({
  "node_modules/@smithy/types/dist-es/abort.js"() {
    "use strict";
  }
});

// node_modules/@smithy/types/dist-es/auth/auth.js
var HttpAuthLocation;
var init_auth = __esm({
  "node_modules/@smithy/types/dist-es/auth/auth.js"() {
    "use strict";
    (function(HttpAuthLocation2) {
      HttpAuthLocation2["HEADER"] = "header";
      HttpAuthLocation2["QUERY"] = "query";
    })(HttpAuthLocation || (HttpAuthLocation = {}));
  }
});

// node_modules/@smithy/types/dist-es/auth/HttpApiKeyAuth.js
var HttpApiKeyAuthLocation;
var init_HttpApiKeyAuth = __esm({
  "node_modules/@smithy/types/dist-es/auth/HttpApiKeyAuth.js"() {
    "use strict";
    (function(HttpApiKeyAuthLocation2) {
      HttpApiKeyAuthLocation2["HEADER"] = "header";
      HttpApiKeyAuthLocation2["QUERY"] = "query";
    })(HttpApiKeyAuthLocation || (HttpApiKeyAuthLocation = {}));
  }
});

// node_modules/@smithy/types/dist-es/auth/HttpAuthScheme.js
var init_HttpAuthScheme = __esm({
  "node_modules/@smithy/types/dist-es/auth/HttpAuthScheme.js"() {
    "use strict";
  }
});

// node_modules/@smithy/types/dist-es/auth/HttpAuthSchemeProvider.js
var init_HttpAuthSchemeProvider = __esm({
  "node_modules/@smithy/types/dist-es/auth/HttpAuthSchemeProvider.js"() {
    "use strict";
  }
});

// node_modules/@smithy/types/dist-es/auth/HttpSigner.js
var init_HttpSigner = __esm({
  "node_modules/@smithy/types/dist-es/auth/HttpSigner.js"() {
    "use strict";
  }
});

// node_modules/@smithy/types/dist-es/auth/IdentityProviderConfig.js
var init_IdentityProviderConfig = __esm({
  "node_modules/@smithy/types/dist-es/auth/IdentityProviderConfig.js"() {
    "use strict";
  }
});

// node_modules/@smithy/types/dist-es/auth/index.js
var init_auth2 = __esm({
  "node_modules/@smithy/types/dist-es/auth/index.js"() {
    "use strict";
    init_auth();
    init_HttpApiKeyAuth();
    init_HttpAuthScheme();
    init_HttpAuthSchemeProvider();
    init_HttpSigner();
    init_IdentityProviderConfig();
  }
});

// node_modules/@smithy/types/dist-es/blob/blob-payload-input-types.js
var init_blob_payload_input_types = __esm({
  "node_modules/@smithy/types/dist-es/blob/blob-payload-input-types.js"() {
    "use strict";
  }
});

// node_modules/@smithy/types/dist-es/checksum.js
var init_checksum = __esm({
  "node_modules/@smithy/types/dist-es/checksum.js"() {
    "use strict";
  }
});

// node_modules/@smithy/types/dist-es/client.js
var init_client = __esm({
  "node_modules/@smithy/types/dist-es/client.js"() {
    "use strict";
  }
});

// node_modules/@smithy/types/dist-es/command.js
var init_command = __esm({
  "node_modules/@smithy/types/dist-es/command.js"() {
    "use strict";
  }
});

// node_modules/@smithy/types/dist-es/connection/config.js
var init_config = __esm({
  "node_modules/@smithy/types/dist-es/connection/config.js"() {
    "use strict";
  }
});

// node_modules/@smithy/types/dist-es/connection/manager.js
var init_manager = __esm({
  "node_modules/@smithy/types/dist-es/connection/manager.js"() {
    "use strict";
  }
});

// node_modules/@smithy/types/dist-es/connection/pool.js
var init_pool = __esm({
  "node_modules/@smithy/types/dist-es/connection/pool.js"() {
    "use strict";
  }
});

// node_modules/@smithy/types/dist-es/connection/index.js
var init_connection = __esm({
  "node_modules/@smithy/types/dist-es/connection/index.js"() {
    "use strict";
    init_config();
    init_manager();
    init_pool();
  }
});

// node_modules/@smithy/types/dist-es/crypto.js
var init_crypto = __esm({
  "node_modules/@smithy/types/dist-es/crypto.js"() {
    "use strict";
  }
});

// node_modules/@smithy/types/dist-es/encode.js
var init_encode = __esm({
  "node_modules/@smithy/types/dist-es/encode.js"() {
    "use strict";
  }
});

// node_modules/@smithy/types/dist-es/endpoint.js
var EndpointURLScheme;
var init_endpoint = __esm({
  "node_modules/@smithy/types/dist-es/endpoint.js"() {
    "use strict";
    (function(EndpointURLScheme2) {
      EndpointURLScheme2["HTTP"] = "http";
      EndpointURLScheme2["HTTPS"] = "https";
    })(EndpointURLScheme || (EndpointURLScheme = {}));
  }
});

// node_modules/@smithy/types/dist-es/endpoints/EndpointRuleObject.js
var init_EndpointRuleObject = __esm({
  "node_modules/@smithy/types/dist-es/endpoints/EndpointRuleObject.js"() {
    "use strict";
  }
});

// node_modules/@smithy/types/dist-es/endpoints/ErrorRuleObject.js
var init_ErrorRuleObject = __esm({
  "node_modules/@smithy/types/dist-es/endpoints/ErrorRuleObject.js"() {
    "use strict";
  }
});

// node_modules/@smithy/types/dist-es/endpoints/RuleSetObject.js
var init_RuleSetObject = __esm({
  "node_modules/@smithy/types/dist-es/endpoints/RuleSetObject.js"() {
    "use strict";
  }
});

// node_modules/@smithy/types/dist-es/endpoints/shared.js
var init_shared = __esm({
  "node_modules/@smithy/types/dist-es/endpoints/shared.js"() {
    "use strict";
  }
});

// node_modules/@smithy/types/dist-es/endpoints/TreeRuleObject.js
var init_TreeRuleObject = __esm({
  "node_modules/@smithy/types/dist-es/endpoints/TreeRuleObject.js"() {
    "use strict";
  }
});

// node_modules/@smithy/types/dist-es/endpoints/index.js
var init_endpoints = __esm({
  "node_modules/@smithy/types/dist-es/endpoints/index.js"() {
    "use strict";
    init_EndpointRuleObject();
    init_ErrorRuleObject();
    init_RuleSetObject();
    init_shared();
    init_TreeRuleObject();
  }
});

// node_modules/@smithy/types/dist-es/eventStream.js
var init_eventStream = __esm({
  "node_modules/@smithy/types/dist-es/eventStream.js"() {
    "use strict";
  }
});

// node_modules/@smithy/types/dist-es/extensions/checksum.js
var AlgorithmId;
var init_checksum2 = __esm({
  "node_modules/@smithy/types/dist-es/extensions/checksum.js"() {
    "use strict";
    (function(AlgorithmId2) {
      AlgorithmId2["MD5"] = "md5";
      AlgorithmId2["CRC32"] = "crc32";
      AlgorithmId2["CRC32C"] = "crc32c";
      AlgorithmId2["SHA1"] = "sha1";
      AlgorithmId2["SHA256"] = "sha256";
    })(AlgorithmId || (AlgorithmId = {}));
  }
});

// node_modules/@smithy/types/dist-es/extensions/defaultClientConfiguration.js
var init_defaultClientConfiguration = __esm({
  "node_modules/@smithy/types/dist-es/extensions/defaultClientConfiguration.js"() {
    "use strict";
  }
});

// node_modules/@smithy/types/dist-es/extensions/defaultExtensionConfiguration.js
var init_defaultExtensionConfiguration = __esm({
  "node_modules/@smithy/types/dist-es/extensions/defaultExtensionConfiguration.js"() {
    "use strict";
  }
});

// node_modules/@smithy/types/dist-es/extensions/index.js
var init_extensions2 = __esm({
  "node_modules/@smithy/types/dist-es/extensions/index.js"() {
    "use strict";
    init_defaultClientConfiguration();
    init_defaultExtensionConfiguration();
    init_checksum2();
  }
});

// node_modules/@smithy/types/dist-es/feature-ids.js
var init_feature_ids = __esm({
  "node_modules/@smithy/types/dist-es/feature-ids.js"() {
    "use strict";
  }
});

// node_modules/@smithy/types/dist-es/http.js
var FieldPosition;
var init_http = __esm({
  "node_modules/@smithy/types/dist-es/http.js"() {
    "use strict";
    (function(FieldPosition2) {
      FieldPosition2[FieldPosition2["HEADER"] = 0] = "HEADER";
      FieldPosition2[FieldPosition2["TRAILER"] = 1] = "TRAILER";
    })(FieldPosition || (FieldPosition = {}));
  }
});

// node_modules/@smithy/types/dist-es/http/httpHandlerInitialization.js
var init_httpHandlerInitialization = __esm({
  "node_modules/@smithy/types/dist-es/http/httpHandlerInitialization.js"() {
    "use strict";
  }
});

// node_modules/@smithy/types/dist-es/identity/apiKeyIdentity.js
var init_apiKeyIdentity = __esm({
  "node_modules/@smithy/types/dist-es/identity/apiKeyIdentity.js"() {
    "use strict";
  }
});

// node_modules/@smithy/types/dist-es/identity/awsCredentialIdentity.js
var init_awsCredentialIdentity = __esm({
  "node_modules/@smithy/types/dist-es/identity/awsCredentialIdentity.js"() {
    "use strict";
  }
});

// node_modules/@smithy/types/dist-es/identity/identity.js
var init_identity = __esm({
  "node_modules/@smithy/types/dist-es/identity/identity.js"() {
    "use strict";
  }
});

// node_modules/@smithy/types/dist-es/identity/tokenIdentity.js
var init_tokenIdentity = __esm({
  "node_modules/@smithy/types/dist-es/identity/tokenIdentity.js"() {
    "use strict";
  }
});

// node_modules/@smithy/types/dist-es/identity/index.js
var init_identity2 = __esm({
  "node_modules/@smithy/types/dist-es/identity/index.js"() {
    "use strict";
    init_apiKeyIdentity();
    init_awsCredentialIdentity();
    init_identity();
    init_tokenIdentity();
  }
});

// node_modules/@smithy/types/dist-es/logger.js
var init_logger = __esm({
  "node_modules/@smithy/types/dist-es/logger.js"() {
    "use strict";
  }
});

// node_modules/@smithy/types/dist-es/middleware.js
var SMITHY_CONTEXT_KEY;
var init_middleware = __esm({
  "node_modules/@smithy/types/dist-es/middleware.js"() {
    "use strict";
    SMITHY_CONTEXT_KEY = "__smithy_context";
  }
});

// node_modules/@smithy/types/dist-es/pagination.js
var init_pagination = __esm({
  "node_modules/@smithy/types/dist-es/pagination.js"() {
    "use strict";
  }
});

// node_modules/@smithy/types/dist-es/profile.js
var IniSectionType;
var init_profile = __esm({
  "node_modules/@smithy/types/dist-es/profile.js"() {
    "use strict";
    (function(IniSectionType2) {
      IniSectionType2["PROFILE"] = "profile";
      IniSectionType2["SSO_SESSION"] = "sso-session";
      IniSectionType2["SERVICES"] = "services";
    })(IniSectionType || (IniSectionType = {}));
  }
});

// node_modules/@smithy/types/dist-es/response.js
var init_response = __esm({
  "node_modules/@smithy/types/dist-es/response.js"() {
    "use strict";
  }
});

// node_modules/@smithy/types/dist-es/retry.js
var init_retry = __esm({
  "node_modules/@smithy/types/dist-es/retry.js"() {
    "use strict";
  }
});

// node_modules/@smithy/types/dist-es/schema/schema.js
var init_schema = __esm({
  "node_modules/@smithy/types/dist-es/schema/schema.js"() {
    "use strict";
  }
});

// node_modules/@smithy/types/dist-es/schema/traits.js
var init_traits = __esm({
  "node_modules/@smithy/types/dist-es/schema/traits.js"() {
    "use strict";
  }
});

// node_modules/@smithy/types/dist-es/schema/schema-deprecated.js
var init_schema_deprecated = __esm({
  "node_modules/@smithy/types/dist-es/schema/schema-deprecated.js"() {
    "use strict";
  }
});

// node_modules/@smithy/types/dist-es/schema/sentinels.js
var init_sentinels = __esm({
  "node_modules/@smithy/types/dist-es/schema/sentinels.js"() {
    "use strict";
  }
});

// node_modules/@smithy/types/dist-es/schema/static-schemas.js
var init_static_schemas = __esm({
  "node_modules/@smithy/types/dist-es/schema/static-schemas.js"() {
    "use strict";
  }
});

// node_modules/@smithy/types/dist-es/serde.js
var init_serde = __esm({
  "node_modules/@smithy/types/dist-es/serde.js"() {
    "use strict";
  }
});

// node_modules/@smithy/types/dist-es/shapes.js
var init_shapes = __esm({
  "node_modules/@smithy/types/dist-es/shapes.js"() {
    "use strict";
  }
});

// node_modules/@smithy/types/dist-es/signature.js
var init_signature = __esm({
  "node_modules/@smithy/types/dist-es/signature.js"() {
    "use strict";
  }
});

// node_modules/@smithy/types/dist-es/stream.js
var init_stream = __esm({
  "node_modules/@smithy/types/dist-es/stream.js"() {
    "use strict";
  }
});

// node_modules/@smithy/types/dist-es/streaming-payload/streaming-blob-common-types.js
var init_streaming_blob_common_types = __esm({
  "node_modules/@smithy/types/dist-es/streaming-payload/streaming-blob-common-types.js"() {
    "use strict";
  }
});

// node_modules/@smithy/types/dist-es/streaming-payload/streaming-blob-payload-input-types.js
var init_streaming_blob_payload_input_types = __esm({
  "node_modules/@smithy/types/dist-es/streaming-payload/streaming-blob-payload-input-types.js"() {
    "use strict";
  }
});

// node_modules/@smithy/types/dist-es/streaming-payload/streaming-blob-payload-output-types.js
var init_streaming_blob_payload_output_types = __esm({
  "node_modules/@smithy/types/dist-es/streaming-payload/streaming-blob-payload-output-types.js"() {
    "use strict";
  }
});

// node_modules/@smithy/types/dist-es/transfer.js
var RequestHandlerProtocol;
var init_transfer = __esm({
  "node_modules/@smithy/types/dist-es/transfer.js"() {
    "use strict";
    (function(RequestHandlerProtocol2) {
      RequestHandlerProtocol2["HTTP_0_9"] = "http/0.9";
      RequestHandlerProtocol2["HTTP_1_0"] = "http/1.0";
      RequestHandlerProtocol2["TDS_8_0"] = "tds/8.0";
    })(RequestHandlerProtocol || (RequestHandlerProtocol = {}));
  }
});

// node_modules/@smithy/types/dist-es/transform/client-payload-blob-type-narrow.js
var init_client_payload_blob_type_narrow = __esm({
  "node_modules/@smithy/types/dist-es/transform/client-payload-blob-type-narrow.js"() {
    "use strict";
  }
});

// node_modules/@smithy/types/dist-es/transform/mutable.js
var init_mutable = __esm({
  "node_modules/@smithy/types/dist-es/transform/mutable.js"() {
    "use strict";
  }
});

// node_modules/@smithy/types/dist-es/transform/no-undefined.js
var init_no_undefined = __esm({
  "node_modules/@smithy/types/dist-es/transform/no-undefined.js"() {
    "use strict";
  }
});

// node_modules/@smithy/types/dist-es/transform/type-transform.js
var init_type_transform = __esm({
  "node_modules/@smithy/types/dist-es/transform/type-transform.js"() {
    "use strict";
  }
});

// node_modules/@smithy/types/dist-es/uri.js
var init_uri = __esm({
  "node_modules/@smithy/types/dist-es/uri.js"() {
    "use strict";
  }
});

// node_modules/@smithy/types/dist-es/util.js
var init_util = __esm({
  "node_modules/@smithy/types/dist-es/util.js"() {
    "use strict";
  }
});

// node_modules/@smithy/types/dist-es/waiter.js
var init_waiter = __esm({
  "node_modules/@smithy/types/dist-es/waiter.js"() {
    "use strict";
  }
});

// node_modules/@smithy/types/dist-es/index.js
var init_dist_es = __esm({
  "node_modules/@smithy/types/dist-es/index.js"() {
    "use strict";
    init_abort();
    init_auth2();
    init_blob_payload_input_types();
    init_checksum();
    init_client();
    init_command();
    init_connection();
    init_crypto();
    init_encode();
    init_endpoint();
    init_endpoints();
    init_eventStream();
    init_extensions2();
    init_feature_ids();
    init_http();
    init_httpHandlerInitialization();
    init_identity2();
    init_logger();
    init_middleware();
    init_pagination();
    init_profile();
    init_response();
    init_retry();
    init_schema();
    init_traits();
    init_schema_deprecated();
    init_sentinels();
    init_static_schemas();
    init_serde();
    init_shapes();
    init_signature();
    init_stream();
    init_streaming_blob_common_types();
    init_streaming_blob_payload_input_types();
    init_streaming_blob_payload_output_types();
    init_transfer();
    init_client_payload_blob_type_narrow();
    init_mutable();
    init_no_undefined();
    init_type_transform();
    init_uri();
    init_util();
    init_waiter();
  }
});

// node_modules/@smithy/protocol-http/dist-es/Field.js
var init_Field = __esm({
  "node_modules/@smithy/protocol-http/dist-es/Field.js"() {
    "use strict";
  }
});

// node_modules/@smithy/protocol-http/dist-es/Fields.js
var init_Fields = __esm({
  "node_modules/@smithy/protocol-http/dist-es/Fields.js"() {
    "use strict";
  }
});

// node_modules/@smithy/protocol-http/dist-es/httpHandler.js
var init_httpHandler = __esm({
  "node_modules/@smithy/protocol-http/dist-es/httpHandler.js"() {
    "use strict";
  }
});

// node_modules/@smithy/protocol-http/dist-es/httpRequest.js
function cloneQuery(query) {
  return Object.keys(query).reduce((carry, paramName) => {
    const param = query[paramName];
    return {
      ...carry,
      [paramName]: Array.isArray(param) ? [...param] : param
    };
  }, {});
}
var HttpRequest;
var init_httpRequest = __esm({
  "node_modules/@smithy/protocol-http/dist-es/httpRequest.js"() {
    "use strict";
    HttpRequest = class _HttpRequest {
      method;
      protocol;
      hostname;
      port;
      path;
      query;
      headers;
      username;
      password;
      fragment;
      body;
      constructor(options) {
        this.method = options.method || "GET";
        this.hostname = options.hostname || "localhost";
        this.port = options.port;
        this.query = options.query || {};
        this.headers = options.headers || {};
        this.body = options.body;
        this.protocol = options.protocol ? options.protocol.slice(-1) !== ":" ? `${options.protocol}:` : options.protocol : "https:";
        this.path = options.path ? options.path.charAt(0) !== "/" ? `/${options.path}` : options.path : "/";
        this.username = options.username;
        this.password = options.password;
        this.fragment = options.fragment;
      }
      static clone(request) {
        const cloned = new _HttpRequest({
          ...request,
          headers: { ...request.headers }
        });
        if (cloned.query) {
          cloned.query = cloneQuery(cloned.query);
        }
        return cloned;
      }
      static isInstance(request) {
        if (!request) {
          return false;
        }
        const req = request;
        return "method" in req && "protocol" in req && "hostname" in req && "path" in req && typeof req["query"] === "object" && typeof req["headers"] === "object";
      }
      clone() {
        return _HttpRequest.clone(this);
      }
    };
  }
});

// node_modules/@smithy/protocol-http/dist-es/httpResponse.js
var HttpResponse;
var init_httpResponse = __esm({
  "node_modules/@smithy/protocol-http/dist-es/httpResponse.js"() {
    "use strict";
    HttpResponse = class {
      statusCode;
      reason;
      headers;
      body;
      constructor(options) {
        this.statusCode = options.statusCode;
        this.reason = options.reason;
        this.headers = options.headers || {};
        this.body = options.body;
      }
      static isInstance(response) {
        if (!response)
          return false;
        const resp = response;
        return typeof resp.statusCode === "number" && typeof resp.headers === "object";
      }
    };
  }
});

// node_modules/@smithy/protocol-http/dist-es/isValidHostname.js
function isValidHostname(hostname) {
  const hostPattern = /^[a-z0-9][a-z0-9\.\-]*[a-z0-9]$/;
  return hostPattern.test(hostname);
}
var init_isValidHostname = __esm({
  "node_modules/@smithy/protocol-http/dist-es/isValidHostname.js"() {
    "use strict";
  }
});

// node_modules/@smithy/protocol-http/dist-es/types.js
var init_types = __esm({
  "node_modules/@smithy/protocol-http/dist-es/types.js"() {
    "use strict";
  }
});

// node_modules/@smithy/protocol-http/dist-es/index.js
var init_dist_es2 = __esm({
  "node_modules/@smithy/protocol-http/dist-es/index.js"() {
    "use strict";
    init_extensions();
    init_Field();
    init_Fields();
    init_httpHandler();
    init_httpRequest();
    init_httpResponse();
    init_isValidHostname();
    init_types();
  }
});

// node_modules/@aws-sdk/middleware-expect-continue/dist-es/index.js
function addExpectContinueMiddleware(options) {
  return (next) => async (args) => {
    const { request } = args;
    if (options.expectContinueHeader !== false && HttpRequest.isInstance(request) && request.body && options.runtime === "node" && options.requestHandler?.constructor?.name !== "FetchHttpHandler") {
      let sendHeader = true;
      if (typeof options.expectContinueHeader === "number") {
        try {
          const bodyLength = Number(request.headers?.["content-length"]) ?? options.bodyLengthChecker?.(request.body) ?? Infinity;
          sendHeader = bodyLength >= options.expectContinueHeader;
        } catch (e2) {
        }
      } else {
        sendHeader = !!options.expectContinueHeader;
      }
      if (sendHeader) {
        request.headers.Expect = "100-continue";
      }
    }
    return next({
      ...args,
      request
    });
  };
}
var addExpectContinueMiddlewareOptions, getAddExpectContinuePlugin;
var init_dist_es3 = __esm({
  "node_modules/@aws-sdk/middleware-expect-continue/dist-es/index.js"() {
    "use strict";
    init_dist_es2();
    addExpectContinueMiddlewareOptions = {
      step: "build",
      tags: ["SET_EXPECT_HEADER", "EXPECT_HEADER"],
      name: "addExpectContinueMiddleware",
      override: true
    };
    getAddExpectContinuePlugin = (options) => ({
      applyToStack: (clientStack) => {
        clientStack.add(addExpectContinueMiddleware(options), addExpectContinueMiddlewareOptions);
      }
    });
  }
});

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/constants.js
var RequestChecksumCalculation, DEFAULT_REQUEST_CHECKSUM_CALCULATION, ResponseChecksumValidation, DEFAULT_RESPONSE_CHECKSUM_VALIDATION, ChecksumAlgorithm, ChecksumLocation, DEFAULT_CHECKSUM_ALGORITHM;
var init_constants = __esm({
  "node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/constants.js"() {
    "use strict";
    RequestChecksumCalculation = {
      WHEN_SUPPORTED: "WHEN_SUPPORTED",
      WHEN_REQUIRED: "WHEN_REQUIRED"
    };
    DEFAULT_REQUEST_CHECKSUM_CALCULATION = RequestChecksumCalculation.WHEN_SUPPORTED;
    ResponseChecksumValidation = {
      WHEN_SUPPORTED: "WHEN_SUPPORTED",
      WHEN_REQUIRED: "WHEN_REQUIRED"
    };
    DEFAULT_RESPONSE_CHECKSUM_VALIDATION = RequestChecksumCalculation.WHEN_SUPPORTED;
    (function(ChecksumAlgorithm3) {
      ChecksumAlgorithm3["MD5"] = "MD5";
      ChecksumAlgorithm3["CRC32"] = "CRC32";
      ChecksumAlgorithm3["CRC32C"] = "CRC32C";
      ChecksumAlgorithm3["CRC64NVME"] = "CRC64NVME";
      ChecksumAlgorithm3["SHA1"] = "SHA1";
      ChecksumAlgorithm3["SHA256"] = "SHA256";
    })(ChecksumAlgorithm || (ChecksumAlgorithm = {}));
    (function(ChecksumLocation2) {
      ChecksumLocation2["HEADER"] = "header";
      ChecksumLocation2["TRAILER"] = "trailer";
    })(ChecksumLocation || (ChecksumLocation = {}));
    DEFAULT_CHECKSUM_ALGORITHM = ChecksumAlgorithm.CRC32;
  }
});

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/NODE_REQUEST_CHECKSUM_CALCULATION_CONFIG_OPTIONS.js
var init_NODE_REQUEST_CHECKSUM_CALCULATION_CONFIG_OPTIONS = __esm({
  "node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/NODE_REQUEST_CHECKSUM_CALCULATION_CONFIG_OPTIONS.js"() {
    "use strict";
  }
});

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/NODE_RESPONSE_CHECKSUM_VALIDATION_CONFIG_OPTIONS.js
var init_NODE_RESPONSE_CHECKSUM_VALIDATION_CONFIG_OPTIONS = __esm({
  "node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/NODE_RESPONSE_CHECKSUM_VALIDATION_CONFIG_OPTIONS.js"() {
    "use strict";
  }
});

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/crc64-nvme-crt-container.js
var crc64NvmeCrtContainer;
var init_crc64_nvme_crt_container = __esm({
  "node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/crc64-nvme-crt-container.js"() {
    "use strict";
    crc64NvmeCrtContainer = {
      CrtCrc64Nvme: null
    };
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/client/emitWarningIfUnsupportedVersion.js
var init_emitWarningIfUnsupportedVersion = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/client/emitWarningIfUnsupportedVersion.js"() {
    "use strict";
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/client/setCredentialFeature.js
function setCredentialFeature(credentials, feature, value) {
  if (!credentials.$source) {
    credentials.$source = {};
  }
  credentials.$source[feature] = value;
  return credentials;
}
var init_setCredentialFeature = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/client/setCredentialFeature.js"() {
    "use strict";
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/client/setFeature.js
function setFeature(context, feature, value) {
  if (!context.__aws_sdk_context) {
    context.__aws_sdk_context = {
      features: {}
    };
  } else if (!context.__aws_sdk_context.features) {
    context.__aws_sdk_context.features = {};
  }
  context.__aws_sdk_context.features[feature] = value;
}
var init_setFeature = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/client/setFeature.js"() {
    "use strict";
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/client/setTokenFeature.js
var init_setTokenFeature = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/client/setTokenFeature.js"() {
    "use strict";
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/client/index.js
var init_client2 = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/client/index.js"() {
    "use strict";
    init_emitWarningIfUnsupportedVersion();
    init_setCredentialFeature();
    init_setFeature();
    init_setTokenFeature();
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/utils/getDateHeader.js
var getDateHeader;
var init_getDateHeader = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/utils/getDateHeader.js"() {
    "use strict";
    init_dist_es2();
    getDateHeader = (response) => HttpResponse.isInstance(response) ? response.headers?.date ?? response.headers?.Date : void 0;
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/utils/getSkewCorrectedDate.js
var getSkewCorrectedDate;
var init_getSkewCorrectedDate = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/utils/getSkewCorrectedDate.js"() {
    "use strict";
    getSkewCorrectedDate = (systemClockOffset) => new Date(Date.now() + systemClockOffset);
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/utils/isClockSkewed.js
var isClockSkewed;
var init_isClockSkewed = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/utils/isClockSkewed.js"() {
    "use strict";
    init_getSkewCorrectedDate();
    isClockSkewed = (clockTime, systemClockOffset) => Math.abs(getSkewCorrectedDate(systemClockOffset).getTime() - clockTime) >= 3e5;
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/utils/getUpdatedSystemClockOffset.js
var getUpdatedSystemClockOffset;
var init_getUpdatedSystemClockOffset = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/utils/getUpdatedSystemClockOffset.js"() {
    "use strict";
    init_isClockSkewed();
    getUpdatedSystemClockOffset = (clockTime, currentSystemClockOffset) => {
      const clockTimeInMs = Date.parse(clockTime);
      if (isClockSkewed(clockTimeInMs, currentSystemClockOffset)) {
        return clockTimeInMs - Date.now();
      }
      return currentSystemClockOffset;
    };
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/utils/index.js
var init_utils = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/utils/index.js"() {
    "use strict";
    init_getDateHeader();
    init_getSkewCorrectedDate();
    init_getUpdatedSystemClockOffset();
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/AwsSdkSigV4Signer.js
var throwSigningPropertyError, validateSigningProperties, AwsSdkSigV4Signer;
var init_AwsSdkSigV4Signer = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/AwsSdkSigV4Signer.js"() {
    "use strict";
    init_dist_es2();
    init_utils();
    throwSigningPropertyError = (name, property) => {
      if (!property) {
        throw new Error(`Property \`${name}\` is not resolved for AWS SDK SigV4Auth`);
      }
      return property;
    };
    validateSigningProperties = async (signingProperties) => {
      const context = throwSigningPropertyError("context", signingProperties.context);
      const config = throwSigningPropertyError("config", signingProperties.config);
      const authScheme = context.endpointV2?.properties?.authSchemes?.[0];
      const signerFunction = throwSigningPropertyError("signer", config.signer);
      const signer = await signerFunction(authScheme);
      const signingRegion = signingProperties?.signingRegion;
      const signingRegionSet = signingProperties?.signingRegionSet;
      const signingName = signingProperties?.signingName;
      return {
        config,
        signer,
        signingRegion,
        signingRegionSet,
        signingName
      };
    };
    AwsSdkSigV4Signer = class {
      async sign(httpRequest, identity, signingProperties) {
        if (!HttpRequest.isInstance(httpRequest)) {
          throw new Error("The request is not an instance of `HttpRequest` and cannot be signed");
        }
        const validatedProps = await validateSigningProperties(signingProperties);
        const { config, signer } = validatedProps;
        let { signingRegion, signingName } = validatedProps;
        const handlerExecutionContext = signingProperties.context;
        if (handlerExecutionContext?.authSchemes?.length ?? 0 > 1) {
          const [first, second] = handlerExecutionContext.authSchemes;
          if (first?.name === "sigv4a" && second?.name === "sigv4") {
            signingRegion = second?.signingRegion ?? signingRegion;
            signingName = second?.signingName ?? signingName;
          }
        }
        const signedRequest = await signer.sign(httpRequest, {
          signingDate: getSkewCorrectedDate(config.systemClockOffset),
          signingRegion,
          signingService: signingName
        });
        return signedRequest;
      }
      errorHandler(signingProperties) {
        return (error) => {
          const serverTime = error.ServerTime ?? getDateHeader(error.$response);
          if (serverTime) {
            const config = throwSigningPropertyError("config", signingProperties.config);
            const initialSystemClockOffset = config.systemClockOffset;
            config.systemClockOffset = getUpdatedSystemClockOffset(serverTime, config.systemClockOffset);
            const clockSkewCorrected = config.systemClockOffset !== initialSystemClockOffset;
            if (clockSkewCorrected && error.$metadata) {
              error.$metadata.clockSkewCorrected = true;
            }
          }
          throw error;
        };
      }
      successHandler(httpResponse, signingProperties) {
        const dateHeader = getDateHeader(httpResponse);
        if (dateHeader) {
          const config = throwSigningPropertyError("config", signingProperties.config);
          config.systemClockOffset = getUpdatedSystemClockOffset(dateHeader, config.systemClockOffset);
        }
      }
    };
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/AwsSdkSigV4ASigner.js
var AwsSdkSigV4ASigner;
var init_AwsSdkSigV4ASigner = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/AwsSdkSigV4ASigner.js"() {
    "use strict";
    init_dist_es2();
    init_utils();
    init_AwsSdkSigV4Signer();
    AwsSdkSigV4ASigner = class extends AwsSdkSigV4Signer {
      async sign(httpRequest, identity, signingProperties) {
        if (!HttpRequest.isInstance(httpRequest)) {
          throw new Error("The request is not an instance of `HttpRequest` and cannot be signed");
        }
        const { config, signer, signingRegion, signingRegionSet, signingName } = await validateSigningProperties(signingProperties);
        const configResolvedSigningRegionSet = await config.sigv4aSigningRegionSet?.();
        const multiRegionOverride = (configResolvedSigningRegionSet ?? signingRegionSet ?? [signingRegion]).join(",");
        const signedRequest = await signer.sign(httpRequest, {
          signingDate: getSkewCorrectedDate(config.systemClockOffset),
          signingRegion: multiRegionOverride,
          signingService: signingName
        });
        return signedRequest;
      }
    };
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/utils/getBearerTokenEnvKey.js
var init_getBearerTokenEnvKey = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/utils/getBearerTokenEnvKey.js"() {
    "use strict";
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/NODE_AUTH_SCHEME_PREFERENCE_OPTIONS.js
var init_NODE_AUTH_SCHEME_PREFERENCE_OPTIONS = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/NODE_AUTH_SCHEME_PREFERENCE_OPTIONS.js"() {
    "use strict";
  }
});

// node_modules/@smithy/core/dist-es/getSmithyContext.js
var init_getSmithyContext = __esm({
  "node_modules/@smithy/core/dist-es/getSmithyContext.js"() {
    "use strict";
  }
});

// node_modules/@smithy/util-middleware/dist-es/getSmithyContext.js
var getSmithyContext;
var init_getSmithyContext2 = __esm({
  "node_modules/@smithy/util-middleware/dist-es/getSmithyContext.js"() {
    "use strict";
    init_dist_es();
    getSmithyContext = (context) => context[SMITHY_CONTEXT_KEY] || (context[SMITHY_CONTEXT_KEY] = {});
  }
});

// node_modules/@smithy/util-middleware/dist-es/normalizeProvider.js
var normalizeProvider;
var init_normalizeProvider = __esm({
  "node_modules/@smithy/util-middleware/dist-es/normalizeProvider.js"() {
    "use strict";
    normalizeProvider = (input) => {
      if (typeof input === "function")
        return input;
      const promisified = Promise.resolve(input);
      return () => promisified;
    };
  }
});

// node_modules/@smithy/util-middleware/dist-es/index.js
var init_dist_es4 = __esm({
  "node_modules/@smithy/util-middleware/dist-es/index.js"() {
    "use strict";
    init_getSmithyContext2();
    init_normalizeProvider();
  }
});

// node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/resolveAuthOptions.js
var resolveAuthOptions;
var init_resolveAuthOptions = __esm({
  "node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/resolveAuthOptions.js"() {
    "use strict";
    resolveAuthOptions = (candidateAuthOptions, authSchemePreference) => {
      if (!authSchemePreference || authSchemePreference.length === 0) {
        return candidateAuthOptions;
      }
      const preferredAuthOptions = [];
      for (const preferredSchemeName of authSchemePreference) {
        for (const candidateAuthOption of candidateAuthOptions) {
          const candidateAuthSchemeName = candidateAuthOption.schemeId.split("#")[1];
          if (candidateAuthSchemeName === preferredSchemeName) {
            preferredAuthOptions.push(candidateAuthOption);
          }
        }
      }
      for (const candidateAuthOption of candidateAuthOptions) {
        if (!preferredAuthOptions.find(({ schemeId }) => schemeId === candidateAuthOption.schemeId)) {
          preferredAuthOptions.push(candidateAuthOption);
        }
      }
      return preferredAuthOptions;
    };
  }
});

// node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/httpAuthSchemeMiddleware.js
function convertHttpAuthSchemesToMap(httpAuthSchemes) {
  const map2 = /* @__PURE__ */ new Map();
  for (const scheme of httpAuthSchemes) {
    map2.set(scheme.schemeId, scheme);
  }
  return map2;
}
var httpAuthSchemeMiddleware;
var init_httpAuthSchemeMiddleware = __esm({
  "node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/httpAuthSchemeMiddleware.js"() {
    "use strict";
    init_dist_es4();
    init_resolveAuthOptions();
    httpAuthSchemeMiddleware = (config, mwOptions) => (next, context) => async (args) => {
      const options = config.httpAuthSchemeProvider(await mwOptions.httpAuthSchemeParametersProvider(config, context, args.input));
      const authSchemePreference = config.authSchemePreference ? await config.authSchemePreference() : [];
      const resolvedOptions = resolveAuthOptions(options, authSchemePreference);
      const authSchemes = convertHttpAuthSchemesToMap(config.httpAuthSchemes);
      const smithyContext = getSmithyContext(context);
      const failureReasons = [];
      for (const option of resolvedOptions) {
        const scheme = authSchemes.get(option.schemeId);
        if (!scheme) {
          failureReasons.push(`HttpAuthScheme \`${option.schemeId}\` was not enabled for this service.`);
          continue;
        }
        const identityProvider = scheme.identityProvider(await mwOptions.identityProviderConfigProvider(config));
        if (!identityProvider) {
          failureReasons.push(`HttpAuthScheme \`${option.schemeId}\` did not have an IdentityProvider configured.`);
          continue;
        }
        const { identityProperties = {}, signingProperties = {} } = option.propertiesExtractor?.(config, context) || {};
        option.identityProperties = Object.assign(option.identityProperties || {}, identityProperties);
        option.signingProperties = Object.assign(option.signingProperties || {}, signingProperties);
        smithyContext.selectedHttpAuthScheme = {
          httpAuthOption: option,
          identity: await identityProvider(option.identityProperties),
          signer: scheme.signer
        };
        break;
      }
      if (!smithyContext.selectedHttpAuthScheme) {
        throw new Error(failureReasons.join("\n"));
      }
      return next(args);
    };
  }
});

// node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/getHttpAuthSchemeEndpointRuleSetPlugin.js
var httpAuthSchemeEndpointRuleSetMiddlewareOptions, getHttpAuthSchemeEndpointRuleSetPlugin;
var init_getHttpAuthSchemeEndpointRuleSetPlugin = __esm({
  "node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/getHttpAuthSchemeEndpointRuleSetPlugin.js"() {
    "use strict";
    init_httpAuthSchemeMiddleware();
    httpAuthSchemeEndpointRuleSetMiddlewareOptions = {
      step: "serialize",
      tags: ["HTTP_AUTH_SCHEME"],
      name: "httpAuthSchemeMiddleware",
      override: true,
      relation: "before",
      toMiddleware: "endpointV2Middleware"
    };
    getHttpAuthSchemeEndpointRuleSetPlugin = (config, { httpAuthSchemeParametersProvider, identityProviderConfigProvider }) => ({
      applyToStack: (clientStack) => {
        clientStack.addRelativeTo(httpAuthSchemeMiddleware(config, {
          httpAuthSchemeParametersProvider,
          identityProviderConfigProvider
        }), httpAuthSchemeEndpointRuleSetMiddlewareOptions);
      }
    });
  }
});

// node_modules/@smithy/middleware-serde/dist-es/deserializerMiddleware.js
var deserializerMiddleware, findHeader;
var init_deserializerMiddleware = __esm({
  "node_modules/@smithy/middleware-serde/dist-es/deserializerMiddleware.js"() {
    "use strict";
    init_dist_es2();
    deserializerMiddleware = (options, deserializer) => (next, context) => async (args) => {
      const { response } = await next(args);
      try {
        const parsed = await deserializer(response, options);
        return {
          response,
          output: parsed
        };
      } catch (error) {
        Object.defineProperty(error, "$response", {
          value: response
        });
        if (!("$metadata" in error)) {
          const hint = `Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.`;
          try {
            error.message += "\n  " + hint;
          } catch (e2) {
            if (!context.logger || context.logger?.constructor?.name === "NoOpLogger") {
              console.warn(hint);
            } else {
              context.logger?.warn?.(hint);
            }
          }
          if (typeof error.$responseBodyText !== "undefined") {
            if (error.$response) {
              error.$response.body = error.$responseBodyText;
            }
          }
          try {
            if (HttpResponse.isInstance(response)) {
              const { headers = {} } = response;
              const headerEntries = Object.entries(headers);
              error.$metadata = {
                httpStatusCode: response.statusCode,
                requestId: findHeader(/^x-[\w-]+-request-?id$/, headerEntries),
                extendedRequestId: findHeader(/^x-[\w-]+-id-2$/, headerEntries),
                cfId: findHeader(/^x-[\w-]+-cf-id$/, headerEntries)
              };
            }
          } catch (e2) {
          }
        }
        throw error;
      }
    };
    findHeader = (pattern, headers) => {
      return (headers.find(([k2]) => {
        return k2.match(pattern);
      }) || [void 0, void 0])[1];
    };
  }
});

// node_modules/@smithy/middleware-serde/dist-es/serializerMiddleware.js
var serializerMiddleware;
var init_serializerMiddleware = __esm({
  "node_modules/@smithy/middleware-serde/dist-es/serializerMiddleware.js"() {
    "use strict";
    serializerMiddleware = (options, serializer) => (next, context) => async (args) => {
      const endpointConfig = options;
      const endpoint = context.endpointV2?.url && endpointConfig.urlParser ? async () => endpointConfig.urlParser(context.endpointV2.url) : endpointConfig.endpoint;
      if (!endpoint) {
        throw new Error("No valid endpoint provider available.");
      }
      const request = await serializer(args.input, { ...options, endpoint });
      return next({
        ...args,
        request
      });
    };
  }
});

// node_modules/@smithy/middleware-serde/dist-es/serdePlugin.js
function getSerdePlugin(config, serializer, deserializer) {
  return {
    applyToStack: (commandStack) => {
      commandStack.add(deserializerMiddleware(config, deserializer), deserializerMiddlewareOption);
      commandStack.add(serializerMiddleware(config, serializer), serializerMiddlewareOption);
    }
  };
}
var deserializerMiddlewareOption, serializerMiddlewareOption;
var init_serdePlugin = __esm({
  "node_modules/@smithy/middleware-serde/dist-es/serdePlugin.js"() {
    "use strict";
    init_deserializerMiddleware();
    init_serializerMiddleware();
    deserializerMiddlewareOption = {
      name: "deserializerMiddleware",
      step: "deserialize",
      tags: ["DESERIALIZER"],
      override: true
    };
    serializerMiddlewareOption = {
      name: "serializerMiddleware",
      step: "serialize",
      tags: ["SERIALIZER"],
      override: true
    };
  }
});

// node_modules/@smithy/middleware-serde/dist-es/index.js
var init_dist_es5 = __esm({
  "node_modules/@smithy/middleware-serde/dist-es/index.js"() {
    "use strict";
    init_deserializerMiddleware();
    init_serdePlugin();
    init_serializerMiddleware();
  }
});

// node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/getHttpAuthSchemePlugin.js
var httpAuthSchemeMiddlewareOptions;
var init_getHttpAuthSchemePlugin = __esm({
  "node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/getHttpAuthSchemePlugin.js"() {
    "use strict";
    init_dist_es5();
    httpAuthSchemeMiddlewareOptions = {
      step: "serialize",
      tags: ["HTTP_AUTH_SCHEME"],
      name: "httpAuthSchemeMiddleware",
      override: true,
      relation: "before",
      toMiddleware: serializerMiddlewareOption.name
    };
  }
});

// node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/index.js
var init_middleware_http_auth_scheme = __esm({
  "node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/index.js"() {
    "use strict";
    init_httpAuthSchemeMiddleware();
    init_getHttpAuthSchemeEndpointRuleSetPlugin();
    init_getHttpAuthSchemePlugin();
  }
});

// node_modules/@smithy/core/dist-es/middleware-http-signing/httpSigningMiddleware.js
var defaultErrorHandler, defaultSuccessHandler, httpSigningMiddleware;
var init_httpSigningMiddleware = __esm({
  "node_modules/@smithy/core/dist-es/middleware-http-signing/httpSigningMiddleware.js"() {
    "use strict";
    init_dist_es2();
    init_dist_es4();
    defaultErrorHandler = (signingProperties) => (error) => {
      throw error;
    };
    defaultSuccessHandler = (httpResponse, signingProperties) => {
    };
    httpSigningMiddleware = (config) => (next, context) => async (args) => {
      if (!HttpRequest.isInstance(args.request)) {
        return next(args);
      }
      const smithyContext = getSmithyContext(context);
      const scheme = smithyContext.selectedHttpAuthScheme;
      if (!scheme) {
        throw new Error(`No HttpAuthScheme was selected: unable to sign request`);
      }
      const { httpAuthOption: { signingProperties = {} }, identity, signer } = scheme;
      const output = await next({
        ...args,
        request: await signer.sign(args.request, identity, signingProperties)
      }).catch((signer.errorHandler || defaultErrorHandler)(signingProperties));
      (signer.successHandler || defaultSuccessHandler)(output.response, signingProperties);
      return output;
    };
  }
});

// node_modules/@smithy/core/dist-es/middleware-http-signing/getHttpSigningMiddleware.js
var httpSigningMiddlewareOptions, getHttpSigningPlugin;
var init_getHttpSigningMiddleware = __esm({
  "node_modules/@smithy/core/dist-es/middleware-http-signing/getHttpSigningMiddleware.js"() {
    "use strict";
    init_httpSigningMiddleware();
    httpSigningMiddlewareOptions = {
      step: "finalizeRequest",
      tags: ["HTTP_SIGNING"],
      name: "httpSigningMiddleware",
      aliases: ["apiKeyMiddleware", "tokenMiddleware", "awsAuthMiddleware"],
      override: true,
      relation: "after",
      toMiddleware: "retryMiddleware"
    };
    getHttpSigningPlugin = (config) => ({
      applyToStack: (clientStack) => {
        clientStack.addRelativeTo(httpSigningMiddleware(config), httpSigningMiddlewareOptions);
      }
    });
  }
});

// node_modules/@smithy/core/dist-es/middleware-http-signing/index.js
var init_middleware_http_signing = __esm({
  "node_modules/@smithy/core/dist-es/middleware-http-signing/index.js"() {
    "use strict";
    init_httpSigningMiddleware();
    init_getHttpSigningMiddleware();
  }
});

// node_modules/@smithy/core/dist-es/normalizeProvider.js
var normalizeProvider2;
var init_normalizeProvider2 = __esm({
  "node_modules/@smithy/core/dist-es/normalizeProvider.js"() {
    "use strict";
    normalizeProvider2 = (input) => {
      if (typeof input === "function")
        return input;
      const promisified = Promise.resolve(input);
      return () => promisified;
    };
  }
});

// node_modules/@smithy/core/dist-es/pagination/createPaginator.js
function createPaginator(ClientCtor, CommandCtor, inputTokenName, outputTokenName, pageSizeTokenName) {
  return async function* paginateOperation(config, input, ...additionalArguments) {
    const _input = input;
    let token = config.startingToken ?? _input[inputTokenName];
    let hasNext = true;
    let page;
    while (hasNext) {
      _input[inputTokenName] = token;
      if (pageSizeTokenName) {
        _input[pageSizeTokenName] = _input[pageSizeTokenName] ?? config.pageSize;
      }
      if (config.client instanceof ClientCtor) {
        page = await makePagedClientRequest(CommandCtor, config.client, input, config.withCommand, ...additionalArguments);
      } else {
        throw new Error(`Invalid client, expected instance of ${ClientCtor.name}`);
      }
      yield page;
      const prevToken = token;
      token = get(page, outputTokenName);
      hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return void 0;
  };
}
var makePagedClientRequest, get;
var init_createPaginator = __esm({
  "node_modules/@smithy/core/dist-es/pagination/createPaginator.js"() {
    "use strict";
    makePagedClientRequest = async (CommandCtor, client, input, withCommand = (_) => _, ...args) => {
      let command = new CommandCtor(input);
      command = withCommand(command) ?? command;
      return await client.send(command, ...args);
    };
    get = (fromObject, path) => {
      let cursor = fromObject;
      const pathComponents = path.split(".");
      for (const step of pathComponents) {
        if (!cursor || typeof cursor !== "object") {
          return void 0;
        }
        cursor = cursor[step];
      }
      return cursor;
    };
  }
});

// node_modules/@smithy/util-base64/dist-es/constants.browser.js
var chars, alphabetByEncoding, alphabetByValue, bitsPerLetter, bitsPerByte, maxLetterValue;
var init_constants_browser = __esm({
  "node_modules/@smithy/util-base64/dist-es/constants.browser.js"() {
    "use strict";
    chars = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/`;
    alphabetByEncoding = Object.entries(chars).reduce((acc, [i2, c2]) => {
      acc[c2] = Number(i2);
      return acc;
    }, {});
    alphabetByValue = chars.split("");
    bitsPerLetter = 6;
    bitsPerByte = 8;
    maxLetterValue = 63;
  }
});

// node_modules/@smithy/util-base64/dist-es/fromBase64.browser.js
var fromBase64;
var init_fromBase64_browser = __esm({
  "node_modules/@smithy/util-base64/dist-es/fromBase64.browser.js"() {
    "use strict";
    init_constants_browser();
    fromBase64 = (input) => {
      let totalByteLength = input.length / 4 * 3;
      if (input.slice(-2) === "==") {
        totalByteLength -= 2;
      } else if (input.slice(-1) === "=") {
        totalByteLength--;
      }
      const out = new ArrayBuffer(totalByteLength);
      const dataView = new DataView(out);
      for (let i2 = 0; i2 < input.length; i2 += 4) {
        let bits = 0;
        let bitLength = 0;
        for (let j2 = i2, limit = i2 + 3; j2 <= limit; j2++) {
          if (input[j2] !== "=") {
            if (!(input[j2] in alphabetByEncoding)) {
              throw new TypeError(`Invalid character ${input[j2]} in base64 string.`);
            }
            bits |= alphabetByEncoding[input[j2]] << (limit - j2) * bitsPerLetter;
            bitLength += bitsPerLetter;
          } else {
            bits >>= bitsPerLetter;
          }
        }
        const chunkOffset = i2 / 4 * 3;
        bits >>= bitLength % bitsPerByte;
        const byteLength = Math.floor(bitLength / bitsPerByte);
        for (let k2 = 0; k2 < byteLength; k2++) {
          const offset = (byteLength - k2 - 1) * bitsPerByte;
          dataView.setUint8(chunkOffset + k2, (bits & 255 << offset) >> offset);
        }
      }
      return new Uint8Array(out);
    };
  }
});

// node_modules/@smithy/util-utf8/dist-es/fromUtf8.browser.js
var fromUtf8;
var init_fromUtf8_browser = __esm({
  "node_modules/@smithy/util-utf8/dist-es/fromUtf8.browser.js"() {
    "use strict";
    fromUtf8 = (input) => new TextEncoder().encode(input);
  }
});

// node_modules/@smithy/util-utf8/dist-es/toUint8Array.js
var toUint8Array;
var init_toUint8Array = __esm({
  "node_modules/@smithy/util-utf8/dist-es/toUint8Array.js"() {
    "use strict";
    init_fromUtf8_browser();
    toUint8Array = (data) => {
      if (typeof data === "string") {
        return fromUtf8(data);
      }
      if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
      }
      return new Uint8Array(data);
    };
  }
});

// node_modules/@smithy/util-utf8/dist-es/toUtf8.browser.js
var toUtf8;
var init_toUtf8_browser = __esm({
  "node_modules/@smithy/util-utf8/dist-es/toUtf8.browser.js"() {
    "use strict";
    toUtf8 = (input) => {
      if (typeof input === "string") {
        return input;
      }
      if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
        throw new Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.");
      }
      return new TextDecoder("utf-8").decode(input);
    };
  }
});

// node_modules/@smithy/util-utf8/dist-es/index.js
var init_dist_es6 = __esm({
  "node_modules/@smithy/util-utf8/dist-es/index.js"() {
    "use strict";
    init_fromUtf8_browser();
    init_toUint8Array();
    init_toUtf8_browser();
  }
});

// node_modules/@smithy/util-base64/dist-es/toBase64.browser.js
function toBase64(_input) {
  let input;
  if (typeof _input === "string") {
    input = fromUtf8(_input);
  } else {
    input = _input;
  }
  const isArrayLike = typeof input === "object" && typeof input.length === "number";
  const isUint8Array = typeof input === "object" && typeof input.byteOffset === "number" && typeof input.byteLength === "number";
  if (!isArrayLike && !isUint8Array) {
    throw new Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.");
  }
  let str = "";
  for (let i2 = 0; i2 < input.length; i2 += 3) {
    let bits = 0;
    let bitLength = 0;
    for (let j2 = i2, limit = Math.min(i2 + 3, input.length); j2 < limit; j2++) {
      bits |= input[j2] << (limit - j2 - 1) * bitsPerByte;
      bitLength += bitsPerByte;
    }
    const bitClusterCount = Math.ceil(bitLength / bitsPerLetter);
    bits <<= bitClusterCount * bitsPerLetter - bitLength;
    for (let k2 = 1; k2 <= bitClusterCount; k2++) {
      const offset = (bitClusterCount - k2) * bitsPerLetter;
      str += alphabetByValue[(bits & maxLetterValue << offset) >> offset];
    }
    str += "==".slice(0, 4 - bitClusterCount);
  }
  return str;
}
var init_toBase64_browser = __esm({
  "node_modules/@smithy/util-base64/dist-es/toBase64.browser.js"() {
    "use strict";
    init_dist_es6();
    init_constants_browser();
  }
});

// node_modules/@smithy/util-base64/dist-es/index.js
var init_dist_es7 = __esm({
  "node_modules/@smithy/util-base64/dist-es/index.js"() {
    "use strict";
    init_fromBase64_browser();
    init_toBase64_browser();
  }
});

// node_modules/@smithy/util-stream/dist-es/blob/Uint8ArrayBlobAdapter.js
var Uint8ArrayBlobAdapter;
var init_Uint8ArrayBlobAdapter = __esm({
  "node_modules/@smithy/util-stream/dist-es/blob/Uint8ArrayBlobAdapter.js"() {
    "use strict";
    init_dist_es7();
    init_dist_es6();
    Uint8ArrayBlobAdapter = class _Uint8ArrayBlobAdapter extends Uint8Array {
      static fromString(source, encoding = "utf-8") {
        if (typeof source === "string") {
          if (encoding === "base64") {
            return _Uint8ArrayBlobAdapter.mutate(fromBase64(source));
          }
          return _Uint8ArrayBlobAdapter.mutate(fromUtf8(source));
        }
        throw new Error(`Unsupported conversion from ${typeof source} to Uint8ArrayBlobAdapter.`);
      }
      static mutate(source) {
        Object.setPrototypeOf(source, _Uint8ArrayBlobAdapter.prototype);
        return source;
      }
      transformToString(encoding = "utf-8") {
        if (encoding === "base64") {
          return toBase64(this);
        }
        return toUtf8(this);
      }
    };
  }
});

// node_modules/@smithy/util-stream/dist-es/checksum/ChecksumStream.browser.js
var ReadableStreamRef, ChecksumStream;
var init_ChecksumStream_browser = __esm({
  "node_modules/@smithy/util-stream/dist-es/checksum/ChecksumStream.browser.js"() {
    "use strict";
    ReadableStreamRef = typeof ReadableStream === "function" ? ReadableStream : function() {
    };
    ChecksumStream = class extends ReadableStreamRef {
    };
  }
});

// node_modules/@smithy/util-stream/dist-es/stream-type-check.js
var isReadableStream;
var init_stream_type_check = __esm({
  "node_modules/@smithy/util-stream/dist-es/stream-type-check.js"() {
    "use strict";
    isReadableStream = (stream) => typeof ReadableStream === "function" && (stream?.constructor?.name === ReadableStream.name || stream instanceof ReadableStream);
  }
});

// node_modules/@smithy/util-stream/dist-es/checksum/createChecksumStream.browser.js
var createChecksumStream;
var init_createChecksumStream_browser = __esm({
  "node_modules/@smithy/util-stream/dist-es/checksum/createChecksumStream.browser.js"() {
    "use strict";
    init_dist_es7();
    init_stream_type_check();
    init_ChecksumStream_browser();
    createChecksumStream = ({ expectedChecksum, checksum, source, checksumSourceLocation, base64Encoder }) => {
      if (!isReadableStream(source)) {
        throw new Error(`@smithy/util-stream: unsupported source type ${source?.constructor?.name ?? source} in ChecksumStream.`);
      }
      const encoder = base64Encoder ?? toBase64;
      if (typeof TransformStream !== "function") {
        throw new Error("@smithy/util-stream: unable to instantiate ChecksumStream because API unavailable: ReadableStream/TransformStream.");
      }
      const transform = new TransformStream({
        start() {
        },
        async transform(chunk, controller) {
          checksum.update(chunk);
          controller.enqueue(chunk);
        },
        async flush(controller) {
          const digest = await checksum.digest();
          const received = encoder(digest);
          if (expectedChecksum !== received) {
            const error = new Error(`Checksum mismatch: expected "${expectedChecksum}" but received "${received}" in response header "${checksumSourceLocation}".`);
            controller.error(error);
          } else {
            controller.terminate();
          }
        }
      });
      source.pipeThrough(transform);
      const readable = transform.readable;
      Object.setPrototypeOf(readable, ChecksumStream.prototype);
      return readable;
    };
  }
});

// node_modules/@smithy/util-stream/dist-es/ByteArrayCollector.js
var ByteArrayCollector;
var init_ByteArrayCollector = __esm({
  "node_modules/@smithy/util-stream/dist-es/ByteArrayCollector.js"() {
    "use strict";
    ByteArrayCollector = class {
      allocByteArray;
      byteLength = 0;
      byteArrays = [];
      constructor(allocByteArray) {
        this.allocByteArray = allocByteArray;
      }
      push(byteArray) {
        this.byteArrays.push(byteArray);
        this.byteLength += byteArray.byteLength;
      }
      flush() {
        if (this.byteArrays.length === 1) {
          const bytes = this.byteArrays[0];
          this.reset();
          return bytes;
        }
        const aggregation = this.allocByteArray(this.byteLength);
        let cursor = 0;
        for (let i2 = 0; i2 < this.byteArrays.length; ++i2) {
          const bytes = this.byteArrays[i2];
          aggregation.set(bytes, cursor);
          cursor += bytes.byteLength;
        }
        this.reset();
        return aggregation;
      }
      reset() {
        this.byteArrays = [];
        this.byteLength = 0;
      }
    };
  }
});

// node_modules/@smithy/util-stream/dist-es/createBufferedReadableStream.js
function createBufferedReadableStream(upstream, size, logger2) {
  const reader = upstream.getReader();
  let streamBufferingLoggedWarning = false;
  let bytesSeen = 0;
  const buffers = ["", new ByteArrayCollector((size2) => new Uint8Array(size2))];
  let mode = -1;
  const pull = async (controller) => {
    const { value, done } = await reader.read();
    const chunk = value;
    if (done) {
      if (mode !== -1) {
        const remainder = flush(buffers, mode);
        if (sizeOf(remainder) > 0) {
          controller.enqueue(remainder);
        }
      }
      controller.close();
    } else {
      const chunkMode = modeOf(chunk, false);
      if (mode !== chunkMode) {
        if (mode >= 0) {
          controller.enqueue(flush(buffers, mode));
        }
        mode = chunkMode;
      }
      if (mode === -1) {
        controller.enqueue(chunk);
        return;
      }
      const chunkSize = sizeOf(chunk);
      bytesSeen += chunkSize;
      const bufferSize = sizeOf(buffers[mode]);
      if (chunkSize >= size && bufferSize === 0) {
        controller.enqueue(chunk);
      } else {
        const newSize = merge(buffers, mode, chunk);
        if (!streamBufferingLoggedWarning && bytesSeen > size * 2) {
          streamBufferingLoggedWarning = true;
          logger2?.warn(`@smithy/util-stream - stream chunk size ${chunkSize} is below threshold of ${size}, automatically buffering.`);
        }
        if (newSize >= size) {
          controller.enqueue(flush(buffers, mode));
        } else {
          await pull(controller);
        }
      }
    }
  };
  return new ReadableStream({
    pull
  });
}
function merge(buffers, mode, chunk) {
  switch (mode) {
    case 0:
      buffers[0] += chunk;
      return sizeOf(buffers[0]);
    case 1:
    case 2:
      buffers[mode].push(chunk);
      return sizeOf(buffers[mode]);
  }
}
function flush(buffers, mode) {
  switch (mode) {
    case 0:
      const s2 = buffers[0];
      buffers[0] = "";
      return s2;
    case 1:
    case 2:
      return buffers[mode].flush();
  }
  throw new Error(`@smithy/util-stream - invalid index ${mode} given to flush()`);
}
function sizeOf(chunk) {
  return chunk?.byteLength ?? chunk?.length ?? 0;
}
function modeOf(chunk, allowBuffer = true) {
  if (allowBuffer && typeof Buffer !== "undefined" && chunk instanceof Buffer) {
    return 2;
  }
  if (chunk instanceof Uint8Array) {
    return 1;
  }
  if (typeof chunk === "string") {
    return 0;
  }
  return -1;
}
var createBufferedReadable;
var init_createBufferedReadableStream = __esm({
  "node_modules/@smithy/util-stream/dist-es/createBufferedReadableStream.js"() {
    "use strict";
    init_ByteArrayCollector();
    createBufferedReadable = createBufferedReadableStream;
  }
});

// node_modules/@smithy/util-stream/dist-es/getAwsChunkedEncodingStream.browser.js
var getAwsChunkedEncodingStream;
var init_getAwsChunkedEncodingStream_browser = __esm({
  "node_modules/@smithy/util-stream/dist-es/getAwsChunkedEncodingStream.browser.js"() {
    "use strict";
    getAwsChunkedEncodingStream = (readableStream, options) => {
      const { base64Encoder, bodyLengthChecker, checksumAlgorithmFn, checksumLocationName, streamHasher } = options;
      const checksumRequired = base64Encoder !== void 0 && bodyLengthChecker !== void 0 && checksumAlgorithmFn !== void 0 && checksumLocationName !== void 0 && streamHasher !== void 0;
      const digest = checksumRequired ? streamHasher(checksumAlgorithmFn, readableStream) : void 0;
      const reader = readableStream.getReader();
      return new ReadableStream({
        async pull(controller) {
          const { value, done } = await reader.read();
          if (done) {
            controller.enqueue(`0\r
`);
            if (checksumRequired) {
              const checksum = base64Encoder(await digest);
              controller.enqueue(`${checksumLocationName}:${checksum}\r
`);
              controller.enqueue(`\r
`);
            }
            controller.close();
          } else {
            controller.enqueue(`${(bodyLengthChecker(value) || 0).toString(16)}\r
${value}\r
`);
          }
        }
      });
    };
  }
});

// node_modules/@smithy/util-stream/dist-es/headStream.browser.js
async function headStream(stream, bytes) {
  let byteLengthCounter = 0;
  const chunks = [];
  const reader = stream.getReader();
  let isDone = false;
  while (!isDone) {
    const { done, value } = await reader.read();
    if (value) {
      chunks.push(value);
      byteLengthCounter += value?.byteLength ?? 0;
    }
    if (byteLengthCounter >= bytes) {
      break;
    }
    isDone = done;
  }
  reader.releaseLock();
  const collected = new Uint8Array(Math.min(bytes, byteLengthCounter));
  let offset = 0;
  for (const chunk of chunks) {
    if (chunk.byteLength > collected.byteLength - offset) {
      collected.set(chunk.subarray(0, collected.byteLength - offset), offset);
      break;
    } else {
      collected.set(chunk, offset);
    }
    offset += chunk.length;
  }
  return collected;
}
var init_headStream_browser = __esm({
  "node_modules/@smithy/util-stream/dist-es/headStream.browser.js"() {
    "use strict";
  }
});

// node_modules/@smithy/util-uri-escape/dist-es/escape-uri.js
var escapeUri, hexEncode;
var init_escape_uri = __esm({
  "node_modules/@smithy/util-uri-escape/dist-es/escape-uri.js"() {
    "use strict";
    escapeUri = (uri) => encodeURIComponent(uri).replace(/[!'()*]/g, hexEncode);
    hexEncode = (c2) => `%${c2.charCodeAt(0).toString(16).toUpperCase()}`;
  }
});

// node_modules/@smithy/util-uri-escape/dist-es/escape-uri-path.js
var init_escape_uri_path = __esm({
  "node_modules/@smithy/util-uri-escape/dist-es/escape-uri-path.js"() {
    "use strict";
  }
});

// node_modules/@smithy/util-uri-escape/dist-es/index.js
var init_dist_es8 = __esm({
  "node_modules/@smithy/util-uri-escape/dist-es/index.js"() {
    "use strict";
    init_escape_uri();
    init_escape_uri_path();
  }
});

// node_modules/@smithy/querystring-builder/dist-es/index.js
function buildQueryString(query) {
  const parts = [];
  for (let key of Object.keys(query).sort()) {
    const value = query[key];
    key = escapeUri(key);
    if (Array.isArray(value)) {
      for (let i2 = 0, iLen = value.length; i2 < iLen; i2++) {
        parts.push(`${key}=${escapeUri(value[i2])}`);
      }
    } else {
      let qsEntry = key;
      if (value || typeof value === "string") {
        qsEntry += `=${escapeUri(value)}`;
      }
      parts.push(qsEntry);
    }
  }
  return parts.join("&");
}
var init_dist_es9 = __esm({
  "node_modules/@smithy/querystring-builder/dist-es/index.js"() {
    "use strict";
    init_dist_es8();
  }
});

// node_modules/@smithy/fetch-http-handler/dist-es/create-request.js
function createRequest(url, requestOptions) {
  return new Request(url, requestOptions);
}
var init_create_request = __esm({
  "node_modules/@smithy/fetch-http-handler/dist-es/create-request.js"() {
    "use strict";
  }
});

// node_modules/@smithy/fetch-http-handler/dist-es/request-timeout.js
function requestTimeout(timeoutInMs = 0) {
  return new Promise((resolve, reject) => {
    if (timeoutInMs) {
      setTimeout(() => {
        const timeoutError = new Error(`Request did not complete within ${timeoutInMs} ms`);
        timeoutError.name = "TimeoutError";
        reject(timeoutError);
      }, timeoutInMs);
    }
  });
}
var init_request_timeout = __esm({
  "node_modules/@smithy/fetch-http-handler/dist-es/request-timeout.js"() {
    "use strict";
  }
});

// node_modules/@smithy/fetch-http-handler/dist-es/fetch-http-handler.js
var keepAliveSupport, FetchHttpHandler;
var init_fetch_http_handler = __esm({
  "node_modules/@smithy/fetch-http-handler/dist-es/fetch-http-handler.js"() {
    "use strict";
    init_dist_es2();
    init_dist_es9();
    init_create_request();
    init_request_timeout();
    keepAliveSupport = {
      supported: void 0
    };
    FetchHttpHandler = class _FetchHttpHandler {
      config;
      configProvider;
      static create(instanceOrOptions) {
        if (typeof instanceOrOptions?.handle === "function") {
          return instanceOrOptions;
        }
        return new _FetchHttpHandler(instanceOrOptions);
      }
      constructor(options) {
        if (typeof options === "function") {
          this.configProvider = options().then((opts) => opts || {});
        } else {
          this.config = options ?? {};
          this.configProvider = Promise.resolve(this.config);
        }
        if (keepAliveSupport.supported === void 0) {
          keepAliveSupport.supported = Boolean(typeof Request !== "undefined" && "keepalive" in createRequest("https://[::1]"));
        }
      }
      destroy() {
      }
      async handle(request, { abortSignal, requestTimeout: requestTimeout2 } = {}) {
        if (!this.config) {
          this.config = await this.configProvider;
        }
        const requestTimeoutInMs = requestTimeout2 ?? this.config.requestTimeout;
        const keepAlive = this.config.keepAlive === true;
        const credentials = this.config.credentials;
        if (abortSignal?.aborted) {
          const abortError = new Error("Request aborted");
          abortError.name = "AbortError";
          return Promise.reject(abortError);
        }
        let path = request.path;
        const queryString = buildQueryString(request.query || {});
        if (queryString) {
          path += `?${queryString}`;
        }
        if (request.fragment) {
          path += `#${request.fragment}`;
        }
        let auth = "";
        if (request.username != null || request.password != null) {
          const username = request.username ?? "";
          const password = request.password ?? "";
          auth = `${username}:${password}@`;
        }
        const { port, method } = request;
        const url = `${request.protocol}//${auth}${request.hostname}${port ? `:${port}` : ""}${path}`;
        const body = method === "GET" || method === "HEAD" ? void 0 : request.body;
        const requestOptions = {
          body,
          headers: new Headers(request.headers),
          method,
          credentials
        };
        if (this.config?.cache) {
          requestOptions.cache = this.config.cache;
        }
        if (body) {
          requestOptions.duplex = "half";
        }
        if (typeof AbortController !== "undefined") {
          requestOptions.signal = abortSignal;
        }
        if (keepAliveSupport.supported) {
          requestOptions.keepalive = keepAlive;
        }
        if (typeof this.config.requestInit === "function") {
          Object.assign(requestOptions, this.config.requestInit(request));
        }
        let removeSignalEventListener = () => {
        };
        const fetchRequest = createRequest(url, requestOptions);
        const raceOfPromises = [
          fetch(fetchRequest).then((response) => {
            const fetchHeaders = response.headers;
            const transformedHeaders = {};
            for (const pair of fetchHeaders.entries()) {
              transformedHeaders[pair[0]] = pair[1];
            }
            const hasReadableStream = response.body != void 0;
            if (!hasReadableStream) {
              return response.blob().then((body2) => ({
                response: new HttpResponse({
                  headers: transformedHeaders,
                  reason: response.statusText,
                  statusCode: response.status,
                  body: body2
                })
              }));
            }
            return {
              response: new HttpResponse({
                headers: transformedHeaders,
                reason: response.statusText,
                statusCode: response.status,
                body: response.body
              })
            };
          }),
          requestTimeout(requestTimeoutInMs)
        ];
        if (abortSignal) {
          raceOfPromises.push(new Promise((resolve, reject) => {
            const onAbort = () => {
              const abortError = new Error("Request aborted");
              abortError.name = "AbortError";
              reject(abortError);
            };
            if (typeof abortSignal.addEventListener === "function") {
              const signal = abortSignal;
              signal.addEventListener("abort", onAbort, { once: true });
              removeSignalEventListener = () => signal.removeEventListener("abort", onAbort);
            } else {
              abortSignal.onabort = onAbort;
            }
          }));
        }
        return Promise.race(raceOfPromises).finally(removeSignalEventListener);
      }
      updateHttpClientConfig(key, value) {
        this.config = void 0;
        this.configProvider = this.configProvider.then((config) => {
          config[key] = value;
          return config;
        });
      }
      httpHandlerConfigs() {
        return this.config ?? {};
      }
    };
  }
});

// node_modules/@smithy/fetch-http-handler/dist-es/stream-collector.js
async function collectBlob(blob) {
  const base64 = await readToBase64(blob);
  const arrayBuffer = fromBase64(base64);
  return new Uint8Array(arrayBuffer);
}
async function collectStream(stream) {
  const chunks = [];
  const reader = stream.getReader();
  let isDone = false;
  let length = 0;
  while (!isDone) {
    const { done, value } = await reader.read();
    if (value) {
      chunks.push(value);
      length += value.length;
    }
    isDone = done;
  }
  const collected = new Uint8Array(length);
  let offset = 0;
  for (const chunk of chunks) {
    collected.set(chunk, offset);
    offset += chunk.length;
  }
  return collected;
}
function readToBase64(blob) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onloadend = () => {
      if (reader.readyState !== 2) {
        return reject(new Error("Reader aborted too early"));
      }
      const result = reader.result ?? "";
      const commaIndex = result.indexOf(",");
      const dataOffset = commaIndex > -1 ? commaIndex + 1 : result.length;
      resolve(result.substring(dataOffset));
    };
    reader.onabort = () => reject(new Error("Read aborted"));
    reader.onerror = () => reject(reader.error);
    reader.readAsDataURL(blob);
  });
}
var streamCollector;
var init_stream_collector = __esm({
  "node_modules/@smithy/fetch-http-handler/dist-es/stream-collector.js"() {
    "use strict";
    init_dist_es7();
    streamCollector = async (stream) => {
      if (typeof Blob === "function" && stream instanceof Blob || stream.constructor?.name === "Blob") {
        if (Blob.prototype.arrayBuffer !== void 0) {
          return new Uint8Array(await stream.arrayBuffer());
        }
        return collectBlob(stream);
      }
      return collectStream(stream);
    };
  }
});

// node_modules/@smithy/fetch-http-handler/dist-es/index.js
var init_dist_es10 = __esm({
  "node_modules/@smithy/fetch-http-handler/dist-es/index.js"() {
    "use strict";
    init_fetch_http_handler();
    init_stream_collector();
  }
});

// node_modules/@smithy/util-hex-encoding/dist-es/index.js
function fromHex(encoded) {
  if (encoded.length % 2 !== 0) {
    throw new Error("Hex encoded strings must have an even number length");
  }
  const out = new Uint8Array(encoded.length / 2);
  for (let i2 = 0; i2 < encoded.length; i2 += 2) {
    const encodedByte = encoded.slice(i2, i2 + 2).toLowerCase();
    if (encodedByte in HEX_TO_SHORT) {
      out[i2 / 2] = HEX_TO_SHORT[encodedByte];
    } else {
      throw new Error(`Cannot decode unrecognized sequence ${encodedByte} as hexadecimal`);
    }
  }
  return out;
}
function toHex(bytes) {
  let out = "";
  for (let i2 = 0; i2 < bytes.byteLength; i2++) {
    out += SHORT_TO_HEX[bytes[i2]];
  }
  return out;
}
var SHORT_TO_HEX, HEX_TO_SHORT;
var init_dist_es11 = __esm({
  "node_modules/@smithy/util-hex-encoding/dist-es/index.js"() {
    "use strict";
    SHORT_TO_HEX = {};
    HEX_TO_SHORT = {};
    for (let i2 = 0; i2 < 256; i2++) {
      let encodedByte = i2.toString(16).toLowerCase();
      if (encodedByte.length === 1) {
        encodedByte = `0${encodedByte}`;
      }
      SHORT_TO_HEX[i2] = encodedByte;
      HEX_TO_SHORT[encodedByte] = i2;
    }
  }
});

// node_modules/@smithy/util-stream/dist-es/sdk-stream-mixin.browser.js
var ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED, sdkStreamMixin, isBlobInstance;
var init_sdk_stream_mixin_browser = __esm({
  "node_modules/@smithy/util-stream/dist-es/sdk-stream-mixin.browser.js"() {
    "use strict";
    init_dist_es10();
    init_dist_es7();
    init_dist_es11();
    init_dist_es6();
    init_stream_type_check();
    ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED = "The stream has already been transformed.";
    sdkStreamMixin = (stream) => {
      if (!isBlobInstance(stream) && !isReadableStream(stream)) {
        const name = stream?.__proto__?.constructor?.name || stream;
        throw new Error(`Unexpected stream implementation, expect Blob or ReadableStream, got ${name}`);
      }
      let transformed = false;
      const transformToByteArray = async () => {
        if (transformed) {
          throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
        }
        transformed = true;
        return await streamCollector(stream);
      };
      const blobToWebStream = (blob) => {
        if (typeof blob.stream !== "function") {
          throw new Error("Cannot transform payload Blob to web stream. Please make sure the Blob.stream() is polyfilled.\nIf you are using React Native, this API is not yet supported, see: https://react-native.canny.io/feature-requests/p/fetch-streaming-body");
        }
        return blob.stream();
      };
      return Object.assign(stream, {
        transformToByteArray,
        transformToString: async (encoding) => {
          const buf = await transformToByteArray();
          if (encoding === "base64") {
            return toBase64(buf);
          } else if (encoding === "hex") {
            return toHex(buf);
          } else if (encoding === void 0 || encoding === "utf8" || encoding === "utf-8") {
            return toUtf8(buf);
          } else if (typeof TextDecoder === "function") {
            return new TextDecoder(encoding).decode(buf);
          } else {
            throw new Error("TextDecoder is not available, please make sure polyfill is provided.");
          }
        },
        transformToWebStream: () => {
          if (transformed) {
            throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
          }
          transformed = true;
          if (isBlobInstance(stream)) {
            return blobToWebStream(stream);
          } else if (isReadableStream(stream)) {
            return stream;
          } else {
            throw new Error(`Cannot transform payload to web stream, got ${stream}`);
          }
        }
      });
    };
    isBlobInstance = (stream) => typeof Blob === "function" && stream instanceof Blob;
  }
});

// node_modules/@smithy/util-stream/dist-es/splitStream.browser.js
async function splitStream(stream) {
  if (typeof stream.stream === "function") {
    stream = stream.stream();
  }
  const readableStream = stream;
  return readableStream.tee();
}
var init_splitStream_browser = __esm({
  "node_modules/@smithy/util-stream/dist-es/splitStream.browser.js"() {
    "use strict";
  }
});

// node_modules/@smithy/util-stream/dist-es/index.js
var init_dist_es12 = __esm({
  "node_modules/@smithy/util-stream/dist-es/index.js"() {
    "use strict";
    init_Uint8ArrayBlobAdapter();
    init_ChecksumStream_browser();
    init_createChecksumStream_browser();
    init_createBufferedReadableStream();
    init_getAwsChunkedEncodingStream_browser();
    init_headStream_browser();
    init_sdk_stream_mixin_browser();
    init_splitStream_browser();
    init_stream_type_check();
  }
});

// node_modules/@smithy/core/dist-es/submodules/protocols/collect-stream-body.js
var collectBody;
var init_collect_stream_body = __esm({
  "node_modules/@smithy/core/dist-es/submodules/protocols/collect-stream-body.js"() {
    "use strict";
    init_dist_es12();
    collectBody = async (streamBody = new Uint8Array(), context) => {
      if (streamBody instanceof Uint8Array) {
        return Uint8ArrayBlobAdapter.mutate(streamBody);
      }
      if (!streamBody) {
        return Uint8ArrayBlobAdapter.mutate(new Uint8Array());
      }
      const fromContext = context.streamCollector(streamBody);
      return Uint8ArrayBlobAdapter.mutate(await fromContext);
    };
  }
});

// node_modules/@smithy/core/dist-es/submodules/protocols/extended-encode-uri-component.js
function extendedEncodeURIComponent(str) {
  return encodeURIComponent(str).replace(/[!'()*]/g, function(c2) {
    return "%" + c2.charCodeAt(0).toString(16).toUpperCase();
  });
}
var init_extended_encode_uri_component = __esm({
  "node_modules/@smithy/core/dist-es/submodules/protocols/extended-encode-uri-component.js"() {
    "use strict";
  }
});

// node_modules/@smithy/core/dist-es/submodules/schema/deref.js
var deref;
var init_deref = __esm({
  "node_modules/@smithy/core/dist-es/submodules/schema/deref.js"() {
    "use strict";
    deref = (schemaRef) => {
      if (typeof schemaRef === "function") {
        return schemaRef();
      }
      return schemaRef;
    };
  }
});

// node_modules/@smithy/core/dist-es/submodules/schema/schemas/operation.js
var init_operation = __esm({
  "node_modules/@smithy/core/dist-es/submodules/schema/schemas/operation.js"() {
    "use strict";
  }
});

// node_modules/@smithy/core/dist-es/submodules/schema/middleware/getSchemaSerdePlugin.js
var init_getSchemaSerdePlugin = __esm({
  "node_modules/@smithy/core/dist-es/submodules/schema/middleware/getSchemaSerdePlugin.js"() {
    "use strict";
  }
});

// node_modules/@smithy/core/dist-es/submodules/schema/schemas/Schema.js
var Schema;
var init_Schema = __esm({
  "node_modules/@smithy/core/dist-es/submodules/schema/schemas/Schema.js"() {
    "use strict";
    Schema = class {
      name;
      namespace;
      traits;
      static assign(instance, values) {
        const schema = Object.assign(instance, values);
        return schema;
      }
      static [Symbol.hasInstance](lhs) {
        const isPrototype = this.prototype.isPrototypeOf(lhs);
        if (!isPrototype && typeof lhs === "object" && lhs !== null) {
          const list = lhs;
          return list.symbol === this.symbol;
        }
        return isPrototype;
      }
      getName() {
        return this.namespace + "#" + this.name;
      }
    };
  }
});

// node_modules/@smithy/core/dist-es/submodules/schema/schemas/ListSchema.js
var ListSchema;
var init_ListSchema = __esm({
  "node_modules/@smithy/core/dist-es/submodules/schema/schemas/ListSchema.js"() {
    "use strict";
    init_Schema();
    ListSchema = class _ListSchema extends Schema {
      static symbol = Symbol.for("@smithy/lis");
      name;
      traits;
      valueSchema;
      symbol = _ListSchema.symbol;
    };
  }
});

// node_modules/@smithy/core/dist-es/submodules/schema/schemas/MapSchema.js
var MapSchema;
var init_MapSchema = __esm({
  "node_modules/@smithy/core/dist-es/submodules/schema/schemas/MapSchema.js"() {
    "use strict";
    init_Schema();
    MapSchema = class _MapSchema extends Schema {
      static symbol = Symbol.for("@smithy/map");
      name;
      traits;
      keySchema;
      valueSchema;
      symbol = _MapSchema.symbol;
    };
  }
});

// node_modules/@smithy/core/dist-es/submodules/schema/schemas/OperationSchema.js
var OperationSchema;
var init_OperationSchema = __esm({
  "node_modules/@smithy/core/dist-es/submodules/schema/schemas/OperationSchema.js"() {
    "use strict";
    init_Schema();
    OperationSchema = class _OperationSchema extends Schema {
      static symbol = Symbol.for("@smithy/ope");
      name;
      traits;
      input;
      output;
      symbol = _OperationSchema.symbol;
    };
  }
});

// node_modules/@smithy/core/dist-es/submodules/schema/schemas/StructureSchema.js
var StructureSchema;
var init_StructureSchema = __esm({
  "node_modules/@smithy/core/dist-es/submodules/schema/schemas/StructureSchema.js"() {
    "use strict";
    init_Schema();
    StructureSchema = class _StructureSchema extends Schema {
      static symbol = Symbol.for("@smithy/str");
      name;
      traits;
      memberNames;
      memberList;
      symbol = _StructureSchema.symbol;
    };
  }
});

// node_modules/@smithy/core/dist-es/submodules/schema/schemas/ErrorSchema.js
var ErrorSchema;
var init_ErrorSchema = __esm({
  "node_modules/@smithy/core/dist-es/submodules/schema/schemas/ErrorSchema.js"() {
    "use strict";
    init_StructureSchema();
    ErrorSchema = class _ErrorSchema extends StructureSchema {
      static symbol = Symbol.for("@smithy/err");
      ctor;
      symbol = _ErrorSchema.symbol;
    };
  }
});

// node_modules/@smithy/core/dist-es/submodules/schema/schemas/translateTraits.js
function translateTraits(indicator) {
  if (typeof indicator === "object") {
    return indicator;
  }
  indicator = indicator | 0;
  const traits = {};
  let i2 = 0;
  for (const trait of [
    "httpLabel",
    "idempotent",
    "idempotencyToken",
    "sensitive",
    "httpPayload",
    "httpResponseCode",
    "httpQueryParams"
  ]) {
    if ((indicator >> i2++ & 1) === 1) {
      traits[trait] = 1;
    }
  }
  return traits;
}
var init_translateTraits = __esm({
  "node_modules/@smithy/core/dist-es/submodules/schema/schemas/translateTraits.js"() {
    "use strict";
  }
});

// node_modules/@smithy/core/dist-es/submodules/schema/schemas/NormalizedSchema.js
function member(memberSchema, memberName) {
  if (memberSchema instanceof NormalizedSchema) {
    return Object.assign(memberSchema, {
      memberName,
      _isMemberSchema: true
    });
  }
  const internalCtorAccess = NormalizedSchema;
  return new internalCtorAccess(memberSchema, memberName);
}
var NormalizedSchema, isMemberSchema, isStaticSchema;
var init_NormalizedSchema = __esm({
  "node_modules/@smithy/core/dist-es/submodules/schema/schemas/NormalizedSchema.js"() {
    "use strict";
    init_deref();
    init_translateTraits();
    NormalizedSchema = class _NormalizedSchema {
      ref;
      memberName;
      static symbol = Symbol.for("@smithy/nor");
      symbol = _NormalizedSchema.symbol;
      name;
      schema;
      _isMemberSchema;
      traits;
      memberTraits;
      normalizedTraits;
      constructor(ref, memberName) {
        this.ref = ref;
        this.memberName = memberName;
        const traitStack = [];
        let _ref = ref;
        let schema = ref;
        this._isMemberSchema = false;
        while (isMemberSchema(_ref)) {
          traitStack.push(_ref[1]);
          _ref = _ref[0];
          schema = deref(_ref);
          this._isMemberSchema = true;
        }
        if (traitStack.length > 0) {
          this.memberTraits = {};
          for (let i2 = traitStack.length - 1; i2 >= 0; --i2) {
            const traitSet = traitStack[i2];
            Object.assign(this.memberTraits, translateTraits(traitSet));
          }
        } else {
          this.memberTraits = 0;
        }
        if (schema instanceof _NormalizedSchema) {
          const computedMemberTraits = this.memberTraits;
          Object.assign(this, schema);
          this.memberTraits = Object.assign({}, computedMemberTraits, schema.getMemberTraits(), this.getMemberTraits());
          this.normalizedTraits = void 0;
          this.memberName = memberName ?? schema.memberName;
          return;
        }
        this.schema = deref(schema);
        if (isStaticSchema(this.schema)) {
          this.name = `${this.schema[1]}#${this.schema[2]}`;
          this.traits = this.schema[3];
        } else {
          this.name = this.memberName ?? String(schema);
          this.traits = 0;
        }
        if (this._isMemberSchema && !memberName) {
          throw new Error(`@smithy/core/schema - NormalizedSchema member init ${this.getName(true)} missing member name.`);
        }
      }
      static [Symbol.hasInstance](lhs) {
        const isPrototype = this.prototype.isPrototypeOf(lhs);
        if (!isPrototype && typeof lhs === "object" && lhs !== null) {
          const ns = lhs;
          return ns.symbol === this.symbol;
        }
        return isPrototype;
      }
      static of(ref) {
        const sc = deref(ref);
        if (sc instanceof _NormalizedSchema) {
          return sc;
        }
        if (isMemberSchema(sc)) {
          const [ns, traits] = sc;
          if (ns instanceof _NormalizedSchema) {
            Object.assign(ns.getMergedTraits(), translateTraits(traits));
            return ns;
          }
          throw new Error(`@smithy/core/schema - may not init unwrapped member schema=${JSON.stringify(ref, null, 2)}.`);
        }
        return new _NormalizedSchema(sc);
      }
      getSchema() {
        const sc = this.schema;
        if (sc[0] === 0) {
          return sc[4];
        }
        return sc;
      }
      getName(withNamespace = false) {
        const { name } = this;
        const short = !withNamespace && name && name.includes("#");
        return short ? name.split("#")[1] : name || void 0;
      }
      getMemberName() {
        return this.memberName;
      }
      isMemberSchema() {
        return this._isMemberSchema;
      }
      isListSchema() {
        const sc = this.getSchema();
        return typeof sc === "number" ? sc >= 64 && sc < 128 : sc[0] === 1;
      }
      isMapSchema() {
        const sc = this.getSchema();
        return typeof sc === "number" ? sc >= 128 && sc <= 255 : sc[0] === 2;
      }
      isStructSchema() {
        const sc = this.getSchema();
        return sc[0] === 3 || sc[0] === -3;
      }
      isBlobSchema() {
        const sc = this.getSchema();
        return sc === 21 || sc === 42;
      }
      isTimestampSchema() {
        const sc = this.getSchema();
        return typeof sc === "number" && sc >= 4 && sc <= 7;
      }
      isUnitSchema() {
        return this.getSchema() === "unit";
      }
      isDocumentSchema() {
        return this.getSchema() === 15;
      }
      isStringSchema() {
        return this.getSchema() === 0;
      }
      isBooleanSchema() {
        return this.getSchema() === 2;
      }
      isNumericSchema() {
        return this.getSchema() === 1;
      }
      isBigIntegerSchema() {
        return this.getSchema() === 17;
      }
      isBigDecimalSchema() {
        return this.getSchema() === 19;
      }
      isStreaming() {
        const { streaming } = this.getMergedTraits();
        return !!streaming || this.getSchema() === 42;
      }
      isIdempotencyToken() {
        const match = (traits2) => (traits2 & 4) === 4 || !!traits2?.idempotencyToken;
        const { normalizedTraits, traits, memberTraits } = this;
        return match(normalizedTraits) || match(traits) || match(memberTraits);
      }
      getMergedTraits() {
        return this.normalizedTraits ?? (this.normalizedTraits = {
          ...this.getOwnTraits(),
          ...this.getMemberTraits()
        });
      }
      getMemberTraits() {
        return translateTraits(this.memberTraits);
      }
      getOwnTraits() {
        return translateTraits(this.traits);
      }
      getKeySchema() {
        const [isDoc, isMap] = [this.isDocumentSchema(), this.isMapSchema()];
        if (!isDoc && !isMap) {
          throw new Error(`@smithy/core/schema - cannot get key for non-map: ${this.getName(true)}`);
        }
        const schema = this.getSchema();
        const memberSchema = isDoc ? 15 : schema[4] ?? 0;
        return member([memberSchema, 0], "key");
      }
      getValueSchema() {
        const sc = this.getSchema();
        const [isDoc, isMap, isList] = [this.isDocumentSchema(), this.isMapSchema(), this.isListSchema()];
        const memberSchema = typeof sc === "number" ? 63 & sc : sc && typeof sc === "object" && (isMap || isList) ? sc[3 + sc[0]] : isDoc ? 15 : void 0;
        if (memberSchema != null) {
          return member([memberSchema, 0], isMap ? "value" : "member");
        }
        throw new Error(`@smithy/core/schema - ${this.getName(true)} has no value member.`);
      }
      getMemberSchema(memberName) {
        const struct = this.getSchema();
        if (this.isStructSchema() && struct[4].includes(memberName)) {
          const i2 = struct[4].indexOf(memberName);
          const memberSchema = struct[5][i2];
          return member(isMemberSchema(memberSchema) ? memberSchema : [memberSchema, 0], memberName);
        }
        if (this.isDocumentSchema()) {
          return member([15, 0], memberName);
        }
        throw new Error(`@smithy/core/schema - ${this.getName(true)} has no no member=${memberName}.`);
      }
      getMemberSchemas() {
        const buffer = {};
        try {
          for (const [k2, v2] of this.structIterator()) {
            buffer[k2] = v2;
          }
        } catch (ignored) {
        }
        return buffer;
      }
      getEventStreamMember() {
        if (this.isStructSchema()) {
          for (const [memberName, memberSchema] of this.structIterator()) {
            if (memberSchema.isStreaming() && memberSchema.isStructSchema()) {
              return memberName;
            }
          }
        }
        return "";
      }
      *structIterator() {
        if (this.isUnitSchema()) {
          return;
        }
        if (!this.isStructSchema()) {
          throw new Error("@smithy/core/schema - cannot iterate non-struct schema.");
        }
        const struct = this.getSchema();
        for (let i2 = 0; i2 < struct[4].length; ++i2) {
          yield [struct[4][i2], member([struct[5][i2], 0], struct[4][i2])];
        }
      }
    };
    isMemberSchema = (sc) => Array.isArray(sc) && sc.length === 2;
    isStaticSchema = (sc) => Array.isArray(sc) && sc.length >= 5;
  }
});

// node_modules/@smithy/core/dist-es/submodules/schema/schemas/SimpleSchema.js
var SimpleSchema;
var init_SimpleSchema = __esm({
  "node_modules/@smithy/core/dist-es/submodules/schema/schemas/SimpleSchema.js"() {
    "use strict";
    init_Schema();
    SimpleSchema = class _SimpleSchema extends Schema {
      static symbol = Symbol.for("@smithy/sim");
      name;
      schemaRef;
      traits;
      symbol = _SimpleSchema.symbol;
    };
  }
});

// node_modules/@smithy/core/dist-es/submodules/schema/schemas/sentinels.js
var init_sentinels2 = __esm({
  "node_modules/@smithy/core/dist-es/submodules/schema/schemas/sentinels.js"() {
    "use strict";
  }
});

// node_modules/@smithy/core/dist-es/submodules/schema/TypeRegistry.js
var init_TypeRegistry = __esm({
  "node_modules/@smithy/core/dist-es/submodules/schema/TypeRegistry.js"() {
    "use strict";
  }
});

// node_modules/@smithy/core/dist-es/submodules/schema/index.js
var init_schema2 = __esm({
  "node_modules/@smithy/core/dist-es/submodules/schema/index.js"() {
    "use strict";
    init_deref();
    init_getSchemaSerdePlugin();
    init_ListSchema();
    init_MapSchema();
    init_OperationSchema();
    init_operation();
    init_ErrorSchema();
    init_NormalizedSchema();
    init_Schema();
    init_SimpleSchema();
    init_StructureSchema();
    init_sentinels2();
    init_translateTraits();
    init_TypeRegistry();
  }
});

// node_modules/@smithy/core/dist-es/submodules/serde/copyDocumentWithTransform.js
var init_copyDocumentWithTransform = __esm({
  "node_modules/@smithy/core/dist-es/submodules/serde/copyDocumentWithTransform.js"() {
    "use strict";
  }
});

// node_modules/@smithy/core/dist-es/submodules/serde/parse-utils.js
var parseBoolean, expectNumber, MAX_FLOAT, expectFloat32, expectLong, expectInt32, expectShort, expectByte, expectSizedInt, castInt, expectNonNull, expectObject, expectString, expectUnion, strictParseFloat32, NUMBER_REGEX, parseNumber, strictParseLong, strictParseInt32, strictParseShort, strictParseByte, stackTraceWarning, logger;
var init_parse_utils = __esm({
  "node_modules/@smithy/core/dist-es/submodules/serde/parse-utils.js"() {
    "use strict";
    parseBoolean = (value) => {
      switch (value) {
        case "true":
          return true;
        case "false":
          return false;
        default:
          throw new Error(`Unable to parse boolean value "${value}"`);
      }
    };
    expectNumber = (value) => {
      if (value === null || value === void 0) {
        return void 0;
      }
      if (typeof value === "string") {
        const parsed = parseFloat(value);
        if (!Number.isNaN(parsed)) {
          if (String(parsed) !== String(value)) {
            logger.warn(stackTraceWarning(`Expected number but observed string: ${value}`));
          }
          return parsed;
        }
      }
      if (typeof value === "number") {
        return value;
      }
      throw new TypeError(`Expected number, got ${typeof value}: ${value}`);
    };
    MAX_FLOAT = Math.ceil(2 ** 127 * (2 - 2 ** -23));
    expectFloat32 = (value) => {
      const expected = expectNumber(value);
      if (expected !== void 0 && !Number.isNaN(expected) && expected !== Infinity && expected !== -Infinity) {
        if (Math.abs(expected) > MAX_FLOAT) {
          throw new TypeError(`Expected 32-bit float, got ${value}`);
        }
      }
      return expected;
    };
    expectLong = (value) => {
      if (value === null || value === void 0) {
        return void 0;
      }
      if (Number.isInteger(value) && !Number.isNaN(value)) {
        return value;
      }
      throw new TypeError(`Expected integer, got ${typeof value}: ${value}`);
    };
    expectInt32 = (value) => expectSizedInt(value, 32);
    expectShort = (value) => expectSizedInt(value, 16);
    expectByte = (value) => expectSizedInt(value, 8);
    expectSizedInt = (value, size) => {
      const expected = expectLong(value);
      if (expected !== void 0 && castInt(expected, size) !== expected) {
        throw new TypeError(`Expected ${size}-bit integer, got ${value}`);
      }
      return expected;
    };
    castInt = (value, size) => {
      switch (size) {
        case 32:
          return Int32Array.of(value)[0];
        case 16:
          return Int16Array.of(value)[0];
        case 8:
          return Int8Array.of(value)[0];
      }
    };
    expectNonNull = (value, location) => {
      if (value === null || value === void 0) {
        if (location) {
          throw new TypeError(`Expected a non-null value for ${location}`);
        }
        throw new TypeError("Expected a non-null value");
      }
      return value;
    };
    expectObject = (value) => {
      if (value === null || value === void 0) {
        return void 0;
      }
      if (typeof value === "object" && !Array.isArray(value)) {
        return value;
      }
      const receivedType = Array.isArray(value) ? "array" : typeof value;
      throw new TypeError(`Expected object, got ${receivedType}: ${value}`);
    };
    expectString = (value) => {
      if (value === null || value === void 0) {
        return void 0;
      }
      if (typeof value === "string") {
        return value;
      }
      if (["boolean", "number", "bigint"].includes(typeof value)) {
        logger.warn(stackTraceWarning(`Expected string, got ${typeof value}: ${value}`));
        return String(value);
      }
      throw new TypeError(`Expected string, got ${typeof value}: ${value}`);
    };
    expectUnion = (value) => {
      if (value === null || value === void 0) {
        return void 0;
      }
      const asObject = expectObject(value);
      const setKeys = Object.entries(asObject).filter(([, v2]) => v2 != null).map(([k2]) => k2);
      if (setKeys.length === 0) {
        throw new TypeError(`Unions must have exactly one non-null member. None were found.`);
      }
      if (setKeys.length > 1) {
        throw new TypeError(`Unions must have exactly one non-null member. Keys ${setKeys} were not null.`);
      }
      return asObject;
    };
    strictParseFloat32 = (value) => {
      if (typeof value == "string") {
        return expectFloat32(parseNumber(value));
      }
      return expectFloat32(value);
    };
    NUMBER_REGEX = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g;
    parseNumber = (value) => {
      const matches = value.match(NUMBER_REGEX);
      if (matches === null || matches[0].length !== value.length) {
        throw new TypeError(`Expected real number, got implicit NaN`);
      }
      return parseFloat(value);
    };
    strictParseLong = (value) => {
      if (typeof value === "string") {
        return expectLong(parseNumber(value));
      }
      return expectLong(value);
    };
    strictParseInt32 = (value) => {
      if (typeof value === "string") {
        return expectInt32(parseNumber(value));
      }
      return expectInt32(value);
    };
    strictParseShort = (value) => {
      if (typeof value === "string") {
        return expectShort(parseNumber(value));
      }
      return expectShort(value);
    };
    strictParseByte = (value) => {
      if (typeof value === "string") {
        return expectByte(parseNumber(value));
      }
      return expectByte(value);
    };
    stackTraceWarning = (message) => {
      return String(new TypeError(message).stack || message).split("\n").slice(0, 5).filter((s2) => !s2.includes("stackTraceWarning")).join("\n");
    };
    logger = {
      warn: console.warn
    };
  }
});

// node_modules/@smithy/core/dist-es/submodules/serde/date-utils.js
function dateToUtcString(date2) {
  const year2 = date2.getUTCFullYear();
  const month = date2.getUTCMonth();
  const dayOfWeek = date2.getUTCDay();
  const dayOfMonthInt = date2.getUTCDate();
  const hoursInt = date2.getUTCHours();
  const minutesInt = date2.getUTCMinutes();
  const secondsInt = date2.getUTCSeconds();
  const dayOfMonthString = dayOfMonthInt < 10 ? `0${dayOfMonthInt}` : `${dayOfMonthInt}`;
  const hoursString = hoursInt < 10 ? `0${hoursInt}` : `${hoursInt}`;
  const minutesString = minutesInt < 10 ? `0${minutesInt}` : `${minutesInt}`;
  const secondsString = secondsInt < 10 ? `0${secondsInt}` : `${secondsInt}`;
  return `${DAYS[dayOfWeek]}, ${dayOfMonthString} ${MONTHS[month]} ${year2} ${hoursString}:${minutesString}:${secondsString} GMT`;
}
var DAYS, MONTHS, RFC3339, RFC3339_WITH_OFFSET, parseRfc3339DateTimeWithOffset, IMF_FIXDATE, RFC_850_DATE, ASC_TIME, parseRfc7231DateTime, buildDate, parseTwoDigitYear, FIFTY_YEARS_IN_MILLIS, adjustRfc850Year, parseMonthByShortName, DAYS_IN_MONTH, validateDayOfMonth, isLeapYear, parseDateValue, parseMilliseconds, parseOffsetToMilliseconds, stripLeadingZeroes;
var init_date_utils = __esm({
  "node_modules/@smithy/core/dist-es/submodules/serde/date-utils.js"() {
    "use strict";
    init_parse_utils();
    DAYS = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
    MONTHS = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    RFC3339 = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/);
    RFC3339_WITH_OFFSET = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/);
    parseRfc3339DateTimeWithOffset = (value) => {
      if (value === null || value === void 0) {
        return void 0;
      }
      if (typeof value !== "string") {
        throw new TypeError("RFC-3339 date-times must be expressed as strings");
      }
      const match = RFC3339_WITH_OFFSET.exec(value);
      if (!match) {
        throw new TypeError("Invalid RFC-3339 date-time value");
      }
      const [_, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, offsetStr] = match;
      const year2 = strictParseShort(stripLeadingZeroes(yearStr));
      const month = parseDateValue(monthStr, "month", 1, 12);
      const day = parseDateValue(dayStr, "day", 1, 31);
      const date2 = buildDate(year2, month, day, { hours, minutes, seconds, fractionalMilliseconds });
      if (offsetStr.toUpperCase() != "Z") {
        date2.setTime(date2.getTime() - parseOffsetToMilliseconds(offsetStr));
      }
      return date2;
    };
    IMF_FIXDATE = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
    RFC_850_DATE = new RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
    ASC_TIME = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/);
    parseRfc7231DateTime = (value) => {
      if (value === null || value === void 0) {
        return void 0;
      }
      if (typeof value !== "string") {
        throw new TypeError("RFC-7231 date-times must be expressed as strings");
      }
      let match = IMF_FIXDATE.exec(value);
      if (match) {
        const [_, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;
        return buildDate(strictParseShort(stripLeadingZeroes(yearStr)), parseMonthByShortName(monthStr), parseDateValue(dayStr, "day", 1, 31), { hours, minutes, seconds, fractionalMilliseconds });
      }
      match = RFC_850_DATE.exec(value);
      if (match) {
        const [_, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;
        return adjustRfc850Year(buildDate(parseTwoDigitYear(yearStr), parseMonthByShortName(monthStr), parseDateValue(dayStr, "day", 1, 31), {
          hours,
          minutes,
          seconds,
          fractionalMilliseconds
        }));
      }
      match = ASC_TIME.exec(value);
      if (match) {
        const [_, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, yearStr] = match;
        return buildDate(strictParseShort(stripLeadingZeroes(yearStr)), parseMonthByShortName(monthStr), parseDateValue(dayStr.trimLeft(), "day", 1, 31), { hours, minutes, seconds, fractionalMilliseconds });
      }
      throw new TypeError("Invalid RFC-7231 date-time value");
    };
    buildDate = (year2, month, day, time2) => {
      const adjustedMonth = month - 1;
      validateDayOfMonth(year2, adjustedMonth, day);
      return new Date(Date.UTC(year2, adjustedMonth, day, parseDateValue(time2.hours, "hour", 0, 23), parseDateValue(time2.minutes, "minute", 0, 59), parseDateValue(time2.seconds, "seconds", 0, 60), parseMilliseconds(time2.fractionalMilliseconds)));
    };
    parseTwoDigitYear = (value) => {
      const thisYear = (/* @__PURE__ */ new Date()).getUTCFullYear();
      const valueInThisCentury = Math.floor(thisYear / 100) * 100 + strictParseShort(stripLeadingZeroes(value));
      if (valueInThisCentury < thisYear) {
        return valueInThisCentury + 100;
      }
      return valueInThisCentury;
    };
    FIFTY_YEARS_IN_MILLIS = 50 * 365 * 24 * 60 * 60 * 1e3;
    adjustRfc850Year = (input) => {
      if (input.getTime() - (/* @__PURE__ */ new Date()).getTime() > FIFTY_YEARS_IN_MILLIS) {
        return new Date(Date.UTC(input.getUTCFullYear() - 100, input.getUTCMonth(), input.getUTCDate(), input.getUTCHours(), input.getUTCMinutes(), input.getUTCSeconds(), input.getUTCMilliseconds()));
      }
      return input;
    };
    parseMonthByShortName = (value) => {
      const monthIdx = MONTHS.indexOf(value);
      if (monthIdx < 0) {
        throw new TypeError(`Invalid month: ${value}`);
      }
      return monthIdx + 1;
    };
    DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    validateDayOfMonth = (year2, month, day) => {
      let maxDays = DAYS_IN_MONTH[month];
      if (month === 1 && isLeapYear(year2)) {
        maxDays = 29;
      }
      if (day > maxDays) {
        throw new TypeError(`Invalid day for ${MONTHS[month]} in ${year2}: ${day}`);
      }
    };
    isLeapYear = (year2) => {
      return year2 % 4 === 0 && (year2 % 100 !== 0 || year2 % 400 === 0);
    };
    parseDateValue = (value, type, lower, upper) => {
      const dateVal = strictParseByte(stripLeadingZeroes(value));
      if (dateVal < lower || dateVal > upper) {
        throw new TypeError(`${type} must be between ${lower} and ${upper}, inclusive`);
      }
      return dateVal;
    };
    parseMilliseconds = (value) => {
      if (value === null || value === void 0) {
        return 0;
      }
      return strictParseFloat32("0." + value) * 1e3;
    };
    parseOffsetToMilliseconds = (value) => {
      const directionStr = value[0];
      let direction = 1;
      if (directionStr == "+") {
        direction = 1;
      } else if (directionStr == "-") {
        direction = -1;
      } else {
        throw new TypeError(`Offset direction, ${directionStr}, must be "+" or "-"`);
      }
      const hour = Number(value.substring(1, 3));
      const minute = Number(value.substring(4, 6));
      return direction * (hour * 60 + minute) * 60 * 1e3;
    };
    stripLeadingZeroes = (value) => {
      let idx = 0;
      while (idx < value.length - 1 && value.charAt(idx) === "0") {
        idx++;
      }
      if (idx === 0) {
        return value;
      }
      return value.slice(idx);
    };
  }
});

// node_modules/@smithy/uuid/dist-es/randomUUID.browser.js
var randomUUID;
var init_randomUUID_browser = __esm({
  "node_modules/@smithy/uuid/dist-es/randomUUID.browser.js"() {
    "use strict";
    randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
  }
});

// node_modules/@smithy/uuid/dist-es/v4.js
var decimalToHex, v4;
var init_v4 = __esm({
  "node_modules/@smithy/uuid/dist-es/v4.js"() {
    "use strict";
    init_randomUUID_browser();
    decimalToHex = Array.from({ length: 256 }, (_, i2) => i2.toString(16).padStart(2, "0"));
    v4 = () => {
      if (randomUUID) {
        return randomUUID();
      }
      const rnds = new Uint8Array(16);
      crypto.getRandomValues(rnds);
      rnds[6] = rnds[6] & 15 | 64;
      rnds[8] = rnds[8] & 63 | 128;
      return decimalToHex[rnds[0]] + decimalToHex[rnds[1]] + decimalToHex[rnds[2]] + decimalToHex[rnds[3]] + "-" + decimalToHex[rnds[4]] + decimalToHex[rnds[5]] + "-" + decimalToHex[rnds[6]] + decimalToHex[rnds[7]] + "-" + decimalToHex[rnds[8]] + decimalToHex[rnds[9]] + "-" + decimalToHex[rnds[10]] + decimalToHex[rnds[11]] + decimalToHex[rnds[12]] + decimalToHex[rnds[13]] + decimalToHex[rnds[14]] + decimalToHex[rnds[15]];
    };
  }
});

// node_modules/@smithy/uuid/dist-es/index.js
var init_dist_es13 = __esm({
  "node_modules/@smithy/uuid/dist-es/index.js"() {
    "use strict";
    init_v4();
  }
});

// node_modules/@smithy/core/dist-es/submodules/serde/generateIdempotencyToken.js
var init_generateIdempotencyToken = __esm({
  "node_modules/@smithy/core/dist-es/submodules/serde/generateIdempotencyToken.js"() {
    "use strict";
  }
});

// node_modules/@smithy/core/dist-es/submodules/serde/lazy-json.js
var LazyJsonString;
var init_lazy_json = __esm({
  "node_modules/@smithy/core/dist-es/submodules/serde/lazy-json.js"() {
    "use strict";
    LazyJsonString = function LazyJsonString2(val) {
      const str = Object.assign(new String(val), {
        deserializeJSON() {
          return JSON.parse(String(val));
        },
        toString() {
          return String(val);
        },
        toJSON() {
          return String(val);
        }
      });
      return str;
    };
    LazyJsonString.from = (object) => {
      if (object && typeof object === "object" && (object instanceof LazyJsonString || "deserializeJSON" in object)) {
        return object;
      } else if (typeof object === "string" || Object.getPrototypeOf(object) === String.prototype) {
        return LazyJsonString(String(object));
      }
      return LazyJsonString(JSON.stringify(object));
    };
    LazyJsonString.fromObject = LazyJsonString.from;
  }
});

// node_modules/@smithy/core/dist-es/submodules/serde/quote-header.js
function quoteHeader(part) {
  if (part.includes(",") || part.includes('"')) {
    part = `"${part.replace(/"/g, '\\"')}"`;
  }
  return part;
}
var init_quote_header = __esm({
  "node_modules/@smithy/core/dist-es/submodules/serde/quote-header.js"() {
    "use strict";
  }
});

// node_modules/@smithy/core/dist-es/submodules/serde/schema-serde-lib/schema-date-utils.js
var ddd, mmm, time, date, year, RFC3339_WITH_OFFSET2, IMF_FIXDATE2, RFC_850_DATE2, ASC_TIME2;
var init_schema_date_utils = __esm({
  "node_modules/@smithy/core/dist-es/submodules/serde/schema-serde-lib/schema-date-utils.js"() {
    "use strict";
    ddd = `(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun)(?:[ne|u?r]?s?day)?`;
    mmm = `(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)`;
    time = `(\\d?\\d):(\\d{2}):(\\d{2})(?:\\.(\\d+))?`;
    date = `(\\d?\\d)`;
    year = `(\\d{4})`;
    RFC3339_WITH_OFFSET2 = new RegExp(/^(\d{4})-(\d\d)-(\d\d)[tT](\d\d):(\d\d):(\d\d)(\.(\d+))?(([-+]\d\d:\d\d)|[zZ])$/);
    IMF_FIXDATE2 = new RegExp(`^${ddd}, ${date} ${mmm} ${year} ${time} GMT$`);
    RFC_850_DATE2 = new RegExp(`^${ddd}, ${date}-${mmm}-(\\d\\d) ${time} GMT$`);
    ASC_TIME2 = new RegExp(`^${ddd} ${mmm} ( [1-9]|\\d\\d) ${time} ${year}$`);
  }
});

// node_modules/@smithy/core/dist-es/submodules/serde/split-every.js
var init_split_every = __esm({
  "node_modules/@smithy/core/dist-es/submodules/serde/split-every.js"() {
    "use strict";
  }
});

// node_modules/@smithy/core/dist-es/submodules/serde/split-header.js
var init_split_header = __esm({
  "node_modules/@smithy/core/dist-es/submodules/serde/split-header.js"() {
    "use strict";
  }
});

// node_modules/@smithy/core/dist-es/submodules/serde/value/NumericValue.js
var init_NumericValue = __esm({
  "node_modules/@smithy/core/dist-es/submodules/serde/value/NumericValue.js"() {
    "use strict";
  }
});

// node_modules/@smithy/core/dist-es/submodules/serde/index.js
var init_serde2 = __esm({
  "node_modules/@smithy/core/dist-es/submodules/serde/index.js"() {
    "use strict";
    init_copyDocumentWithTransform();
    init_date_utils();
    init_generateIdempotencyToken();
    init_lazy_json();
    init_parse_utils();
    init_quote_header();
    init_schema_date_utils();
    init_split_every();
    init_split_header();
    init_NumericValue();
  }
});

// node_modules/@smithy/core/dist-es/submodules/protocols/SerdeContext.js
var init_SerdeContext = __esm({
  "node_modules/@smithy/core/dist-es/submodules/protocols/SerdeContext.js"() {
    "use strict";
  }
});

// node_modules/@smithy/core/dist-es/submodules/protocols/HttpProtocol.js
var init_HttpProtocol = __esm({
  "node_modules/@smithy/core/dist-es/submodules/protocols/HttpProtocol.js"() {
    "use strict";
  }
});

// node_modules/@smithy/core/dist-es/submodules/protocols/HttpBindingProtocol.js
var init_HttpBindingProtocol = __esm({
  "node_modules/@smithy/core/dist-es/submodules/protocols/HttpBindingProtocol.js"() {
    "use strict";
  }
});

// node_modules/@smithy/core/dist-es/submodules/protocols/RpcProtocol.js
var init_RpcProtocol = __esm({
  "node_modules/@smithy/core/dist-es/submodules/protocols/RpcProtocol.js"() {
    "use strict";
  }
});

// node_modules/@smithy/core/dist-es/submodules/protocols/resolve-path.js
var resolvedPath;
var init_resolve_path = __esm({
  "node_modules/@smithy/core/dist-es/submodules/protocols/resolve-path.js"() {
    "use strict";
    init_extended_encode_uri_component();
    resolvedPath = (resolvedPath2, input, memberName, labelValueProvider, uriLabel, isGreedyLabel) => {
      if (input != null && input[memberName] !== void 0) {
        const labelValue = labelValueProvider();
        if (labelValue.length <= 0) {
          throw new Error("Empty value provided for input HTTP label: " + memberName + ".");
        }
        resolvedPath2 = resolvedPath2.replace(uriLabel, isGreedyLabel ? labelValue.split("/").map((segment) => extendedEncodeURIComponent(segment)).join("/") : extendedEncodeURIComponent(labelValue));
      } else {
        throw new Error("No value provided for input HTTP label: " + memberName + ".");
      }
      return resolvedPath2;
    };
  }
});

// node_modules/@smithy/core/dist-es/submodules/protocols/requestBuilder.js
function requestBuilder(input, context) {
  return new RequestBuilder(input, context);
}
var RequestBuilder;
var init_requestBuilder = __esm({
  "node_modules/@smithy/core/dist-es/submodules/protocols/requestBuilder.js"() {
    "use strict";
    init_dist_es2();
    init_resolve_path();
    RequestBuilder = class {
      input;
      context;
      query = {};
      method = "";
      headers = {};
      path = "";
      body = null;
      hostname = "";
      resolvePathStack = [];
      constructor(input, context) {
        this.input = input;
        this.context = context;
      }
      async build() {
        const { hostname, protocol = "https", port, path: basePath } = await this.context.endpoint();
        this.path = basePath;
        for (const resolvePath of this.resolvePathStack) {
          resolvePath(this.path);
        }
        return new HttpRequest({
          protocol,
          hostname: this.hostname || hostname,
          port,
          method: this.method,
          path: this.path,
          query: this.query,
          body: this.body,
          headers: this.headers
        });
      }
      hn(hostname) {
        this.hostname = hostname;
        return this;
      }
      bp(uriLabel) {
        this.resolvePathStack.push((basePath) => {
          this.path = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + uriLabel;
        });
        return this;
      }
      p(memberName, labelValueProvider, uriLabel, isGreedyLabel) {
        this.resolvePathStack.push((path) => {
          this.path = resolvedPath(path, this.input, memberName, labelValueProvider, uriLabel, isGreedyLabel);
        });
        return this;
      }
      h(headers) {
        this.headers = headers;
        return this;
      }
      q(query) {
        this.query = query;
        return this;
      }
      b(body) {
        this.body = body;
        return this;
      }
      m(method) {
        this.method = method;
        return this;
      }
    };
  }
});

// node_modules/@smithy/core/dist-es/submodules/protocols/serde/determineTimestampFormat.js
var init_determineTimestampFormat = __esm({
  "node_modules/@smithy/core/dist-es/submodules/protocols/serde/determineTimestampFormat.js"() {
    "use strict";
  }
});

// node_modules/@smithy/core/dist-es/submodules/protocols/serde/FromStringShapeDeserializer.js
var init_FromStringShapeDeserializer = __esm({
  "node_modules/@smithy/core/dist-es/submodules/protocols/serde/FromStringShapeDeserializer.js"() {
    "use strict";
  }
});

// node_modules/@smithy/core/dist-es/submodules/protocols/serde/HttpInterceptingShapeDeserializer.js
var init_HttpInterceptingShapeDeserializer = __esm({
  "node_modules/@smithy/core/dist-es/submodules/protocols/serde/HttpInterceptingShapeDeserializer.js"() {
    "use strict";
  }
});

// node_modules/@smithy/core/dist-es/submodules/protocols/serde/ToStringShapeSerializer.js
var init_ToStringShapeSerializer = __esm({
  "node_modules/@smithy/core/dist-es/submodules/protocols/serde/ToStringShapeSerializer.js"() {
    "use strict";
  }
});

// node_modules/@smithy/core/dist-es/submodules/protocols/serde/HttpInterceptingShapeSerializer.js
var init_HttpInterceptingShapeSerializer = __esm({
  "node_modules/@smithy/core/dist-es/submodules/protocols/serde/HttpInterceptingShapeSerializer.js"() {
    "use strict";
  }
});

// node_modules/@smithy/core/dist-es/submodules/protocols/index.js
var init_protocols = __esm({
  "node_modules/@smithy/core/dist-es/submodules/protocols/index.js"() {
    "use strict";
    init_collect_stream_body();
    init_extended_encode_uri_component();
    init_HttpBindingProtocol();
    init_HttpProtocol();
    init_RpcProtocol();
    init_requestBuilder();
    init_resolve_path();
    init_FromStringShapeDeserializer();
    init_HttpInterceptingShapeDeserializer();
    init_HttpInterceptingShapeSerializer();
    init_ToStringShapeSerializer();
    init_determineTimestampFormat();
    init_SerdeContext();
  }
});

// node_modules/@smithy/core/dist-es/request-builder/requestBuilder.js
var init_requestBuilder2 = __esm({
  "node_modules/@smithy/core/dist-es/request-builder/requestBuilder.js"() {
    "use strict";
    init_protocols();
  }
});

// node_modules/@smithy/core/dist-es/setFeature.js
function setFeature2(context, feature, value) {
  if (!context.__smithy_context) {
    context.__smithy_context = {
      features: {}
    };
  } else if (!context.__smithy_context.features) {
    context.__smithy_context.features = {};
  }
  context.__smithy_context.features[feature] = value;
}
var init_setFeature2 = __esm({
  "node_modules/@smithy/core/dist-es/setFeature.js"() {
    "use strict";
  }
});

// node_modules/@smithy/core/dist-es/util-identity-and-auth/DefaultIdentityProviderConfig.js
var DefaultIdentityProviderConfig;
var init_DefaultIdentityProviderConfig = __esm({
  "node_modules/@smithy/core/dist-es/util-identity-and-auth/DefaultIdentityProviderConfig.js"() {
    "use strict";
    DefaultIdentityProviderConfig = class {
      authSchemes = /* @__PURE__ */ new Map();
      constructor(config) {
        for (const [key, value] of Object.entries(config)) {
          if (value !== void 0) {
            this.authSchemes.set(key, value);
          }
        }
      }
      getIdentityProvider(schemeId) {
        return this.authSchemes.get(schemeId);
      }
    };
  }
});

// node_modules/@smithy/core/dist-es/util-identity-and-auth/httpAuthSchemes/httpApiKeyAuth.js
var init_httpApiKeyAuth = __esm({
  "node_modules/@smithy/core/dist-es/util-identity-and-auth/httpAuthSchemes/httpApiKeyAuth.js"() {
    "use strict";
  }
});

// node_modules/@smithy/core/dist-es/util-identity-and-auth/httpAuthSchemes/httpBearerAuth.js
var init_httpBearerAuth = __esm({
  "node_modules/@smithy/core/dist-es/util-identity-and-auth/httpAuthSchemes/httpBearerAuth.js"() {
    "use strict";
  }
});

// node_modules/@smithy/core/dist-es/util-identity-and-auth/httpAuthSchemes/noAuth.js
var init_noAuth = __esm({
  "node_modules/@smithy/core/dist-es/util-identity-and-auth/httpAuthSchemes/noAuth.js"() {
    "use strict";
  }
});

// node_modules/@smithy/core/dist-es/util-identity-and-auth/httpAuthSchemes/index.js
var init_httpAuthSchemes = __esm({
  "node_modules/@smithy/core/dist-es/util-identity-and-auth/httpAuthSchemes/index.js"() {
    "use strict";
    init_httpApiKeyAuth();
    init_httpBearerAuth();
    init_noAuth();
  }
});

// node_modules/@smithy/core/dist-es/util-identity-and-auth/memoizeIdentityProvider.js
var createIsIdentityExpiredFunction, EXPIRATION_MS, isIdentityExpired, doesIdentityRequireRefresh, memoizeIdentityProvider;
var init_memoizeIdentityProvider = __esm({
  "node_modules/@smithy/core/dist-es/util-identity-and-auth/memoizeIdentityProvider.js"() {
    "use strict";
    createIsIdentityExpiredFunction = (expirationMs) => function isIdentityExpired2(identity) {
      return doesIdentityRequireRefresh(identity) && identity.expiration.getTime() - Date.now() < expirationMs;
    };
    EXPIRATION_MS = 3e5;
    isIdentityExpired = createIsIdentityExpiredFunction(EXPIRATION_MS);
    doesIdentityRequireRefresh = (identity) => identity.expiration !== void 0;
    memoizeIdentityProvider = (provider, isExpired, requiresRefresh) => {
      if (provider === void 0) {
        return void 0;
      }
      const normalizedProvider = typeof provider !== "function" ? async () => Promise.resolve(provider) : provider;
      let resolved;
      let pending;
      let hasResult;
      let isConstant = false;
      const coalesceProvider = async (options) => {
        if (!pending) {
          pending = normalizedProvider(options);
        }
        try {
          resolved = await pending;
          hasResult = true;
          isConstant = false;
        } finally {
          pending = void 0;
        }
        return resolved;
      };
      if (isExpired === void 0) {
        return async (options) => {
          if (!hasResult || options?.forceRefresh) {
            resolved = await coalesceProvider(options);
          }
          return resolved;
        };
      }
      return async (options) => {
        if (!hasResult || options?.forceRefresh) {
          resolved = await coalesceProvider(options);
        }
        if (isConstant) {
          return resolved;
        }
        if (!requiresRefresh(resolved)) {
          isConstant = true;
          return resolved;
        }
        if (isExpired(resolved)) {
          await coalesceProvider(options);
          return resolved;
        }
        return resolved;
      };
    };
  }
});

// node_modules/@smithy/core/dist-es/util-identity-and-auth/index.js
var init_util_identity_and_auth = __esm({
  "node_modules/@smithy/core/dist-es/util-identity-and-auth/index.js"() {
    "use strict";
    init_DefaultIdentityProviderConfig();
    init_httpAuthSchemes();
    init_memoizeIdentityProvider();
  }
});

// node_modules/@smithy/core/dist-es/index.js
var init_dist_es14 = __esm({
  "node_modules/@smithy/core/dist-es/index.js"() {
    "use strict";
    init_getSmithyContext();
    init_middleware_http_auth_scheme();
    init_middleware_http_signing();
    init_normalizeProvider2();
    init_createPaginator();
    init_requestBuilder2();
    init_setFeature2();
    init_util_identity_and_auth();
  }
});

// node_modules/@smithy/property-provider/dist-es/ProviderError.js
var init_ProviderError = __esm({
  "node_modules/@smithy/property-provider/dist-es/ProviderError.js"() {
    "use strict";
  }
});

// node_modules/@smithy/property-provider/dist-es/CredentialsProviderError.js
var init_CredentialsProviderError = __esm({
  "node_modules/@smithy/property-provider/dist-es/CredentialsProviderError.js"() {
    "use strict";
  }
});

// node_modules/@smithy/property-provider/dist-es/TokenProviderError.js
var init_TokenProviderError = __esm({
  "node_modules/@smithy/property-provider/dist-es/TokenProviderError.js"() {
    "use strict";
  }
});

// node_modules/@smithy/property-provider/dist-es/chain.js
var init_chain = __esm({
  "node_modules/@smithy/property-provider/dist-es/chain.js"() {
    "use strict";
  }
});

// node_modules/@smithy/property-provider/dist-es/fromStatic.js
var init_fromStatic = __esm({
  "node_modules/@smithy/property-provider/dist-es/fromStatic.js"() {
    "use strict";
  }
});

// node_modules/@smithy/property-provider/dist-es/memoize.js
var memoize;
var init_memoize = __esm({
  "node_modules/@smithy/property-provider/dist-es/memoize.js"() {
    "use strict";
    memoize = (provider, isExpired, requiresRefresh) => {
      let resolved;
      let pending;
      let hasResult;
      let isConstant = false;
      const coalesceProvider = async () => {
        if (!pending) {
          pending = provider();
        }
        try {
          resolved = await pending;
          hasResult = true;
          isConstant = false;
        } finally {
          pending = void 0;
        }
        return resolved;
      };
      if (isExpired === void 0) {
        return async (options) => {
          if (!hasResult || options?.forceRefresh) {
            resolved = await coalesceProvider();
          }
          return resolved;
        };
      }
      return async (options) => {
        if (!hasResult || options?.forceRefresh) {
          resolved = await coalesceProvider();
        }
        if (isConstant) {
          return resolved;
        }
        if (requiresRefresh && !requiresRefresh(resolved)) {
          isConstant = true;
          return resolved;
        }
        if (isExpired(resolved)) {
          await coalesceProvider();
          return resolved;
        }
        return resolved;
      };
    };
  }
});

// node_modules/@smithy/property-provider/dist-es/index.js
var init_dist_es15 = __esm({
  "node_modules/@smithy/property-provider/dist-es/index.js"() {
    "use strict";
    init_CredentialsProviderError();
    init_ProviderError();
    init_TokenProviderError();
    init_chain();
    init_fromStatic();
    init_memoize();
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/resolveAwsSdkSigV4AConfig.js
var resolveAwsSdkSigV4AConfig;
var init_resolveAwsSdkSigV4AConfig = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/resolveAwsSdkSigV4AConfig.js"() {
    "use strict";
    init_dist_es14();
    resolveAwsSdkSigV4AConfig = (config) => {
      config.sigv4aSigningRegionSet = normalizeProvider2(config.sigv4aSigningRegionSet);
      return config;
    };
  }
});

// node_modules/@smithy/signature-v4/dist-es/constants.js
var ALGORITHM_QUERY_PARAM, CREDENTIAL_QUERY_PARAM, AMZ_DATE_QUERY_PARAM, SIGNED_HEADERS_QUERY_PARAM, EXPIRES_QUERY_PARAM, SIGNATURE_QUERY_PARAM, TOKEN_QUERY_PARAM, AUTH_HEADER, AMZ_DATE_HEADER, DATE_HEADER, GENERATED_HEADERS, SIGNATURE_HEADER, SHA256_HEADER, TOKEN_HEADER, ALWAYS_UNSIGNABLE_HEADERS, PROXY_HEADER_PATTERN, SEC_HEADER_PATTERN, ALGORITHM_IDENTIFIER, EVENT_ALGORITHM_IDENTIFIER, UNSIGNED_PAYLOAD, MAX_CACHE_SIZE, KEY_TYPE_IDENTIFIER, MAX_PRESIGNED_TTL;
var init_constants2 = __esm({
  "node_modules/@smithy/signature-v4/dist-es/constants.js"() {
    "use strict";
    ALGORITHM_QUERY_PARAM = "X-Amz-Algorithm";
    CREDENTIAL_QUERY_PARAM = "X-Amz-Credential";
    AMZ_DATE_QUERY_PARAM = "X-Amz-Date";
    SIGNED_HEADERS_QUERY_PARAM = "X-Amz-SignedHeaders";
    EXPIRES_QUERY_PARAM = "X-Amz-Expires";
    SIGNATURE_QUERY_PARAM = "X-Amz-Signature";
    TOKEN_QUERY_PARAM = "X-Amz-Security-Token";
    AUTH_HEADER = "authorization";
    AMZ_DATE_HEADER = AMZ_DATE_QUERY_PARAM.toLowerCase();
    DATE_HEADER = "date";
    GENERATED_HEADERS = [AUTH_HEADER, AMZ_DATE_HEADER, DATE_HEADER];
    SIGNATURE_HEADER = SIGNATURE_QUERY_PARAM.toLowerCase();
    SHA256_HEADER = "x-amz-content-sha256";
    TOKEN_HEADER = TOKEN_QUERY_PARAM.toLowerCase();
    ALWAYS_UNSIGNABLE_HEADERS = {
      authorization: true,
      "cache-control": true,
      connection: true,
      expect: true,
      from: true,
      "keep-alive": true,
      "max-forwards": true,
      pragma: true,
      referer: true,
      te: true,
      trailer: true,
      "transfer-encoding": true,
      upgrade: true,
      "user-agent": true,
      "x-amzn-trace-id": true
    };
    PROXY_HEADER_PATTERN = /^proxy-/;
    SEC_HEADER_PATTERN = /^sec-/;
    ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256";
    EVENT_ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256-PAYLOAD";
    UNSIGNED_PAYLOAD = "UNSIGNED-PAYLOAD";
    MAX_CACHE_SIZE = 50;
    KEY_TYPE_IDENTIFIER = "aws4_request";
    MAX_PRESIGNED_TTL = 60 * 60 * 24 * 7;
  }
});

// node_modules/@smithy/signature-v4/dist-es/credentialDerivation.js
var signingKeyCache, cacheQueue, createScope, getSigningKey, hmac;
var init_credentialDerivation = __esm({
  "node_modules/@smithy/signature-v4/dist-es/credentialDerivation.js"() {
    "use strict";
    init_dist_es11();
    init_dist_es6();
    init_constants2();
    signingKeyCache = {};
    cacheQueue = [];
    createScope = (shortDate, region, service) => `${shortDate}/${region}/${service}/${KEY_TYPE_IDENTIFIER}`;
    getSigningKey = async (sha256Constructor, credentials, shortDate, region, service) => {
      const credsHash = await hmac(sha256Constructor, credentials.secretAccessKey, credentials.accessKeyId);
      const cacheKey = `${shortDate}:${region}:${service}:${toHex(credsHash)}:${credentials.sessionToken}`;
      if (cacheKey in signingKeyCache) {
        return signingKeyCache[cacheKey];
      }
      cacheQueue.push(cacheKey);
      while (cacheQueue.length > MAX_CACHE_SIZE) {
        delete signingKeyCache[cacheQueue.shift()];
      }
      let key = `AWS4${credentials.secretAccessKey}`;
      for (const signable of [shortDate, region, service, KEY_TYPE_IDENTIFIER]) {
        key = await hmac(sha256Constructor, key, signable);
      }
      return signingKeyCache[cacheKey] = key;
    };
    hmac = (ctor, secret, data) => {
      const hash = new ctor(secret);
      hash.update(toUint8Array(data));
      return hash.digest();
    };
  }
});

// node_modules/@smithy/signature-v4/dist-es/getCanonicalHeaders.js
var getCanonicalHeaders;
var init_getCanonicalHeaders = __esm({
  "node_modules/@smithy/signature-v4/dist-es/getCanonicalHeaders.js"() {
    "use strict";
    init_constants2();
    getCanonicalHeaders = ({ headers }, unsignableHeaders, signableHeaders) => {
      const canonical = {};
      for (const headerName of Object.keys(headers).sort()) {
        if (headers[headerName] == void 0) {
          continue;
        }
        const canonicalHeaderName = headerName.toLowerCase();
        if (canonicalHeaderName in ALWAYS_UNSIGNABLE_HEADERS || unsignableHeaders?.has(canonicalHeaderName) || PROXY_HEADER_PATTERN.test(canonicalHeaderName) || SEC_HEADER_PATTERN.test(canonicalHeaderName)) {
          if (!signableHeaders || signableHeaders && !signableHeaders.has(canonicalHeaderName)) {
            continue;
          }
        }
        canonical[canonicalHeaderName] = headers[headerName].trim().replace(/\s+/g, " ");
      }
      return canonical;
    };
  }
});

// node_modules/@smithy/is-array-buffer/dist-es/index.js
var isArrayBuffer;
var init_dist_es16 = __esm({
  "node_modules/@smithy/is-array-buffer/dist-es/index.js"() {
    "use strict";
    isArrayBuffer = (arg) => typeof ArrayBuffer === "function" && arg instanceof ArrayBuffer || Object.prototype.toString.call(arg) === "[object ArrayBuffer]";
  }
});

// node_modules/@smithy/signature-v4/dist-es/getPayloadHash.js
var getPayloadHash;
var init_getPayloadHash = __esm({
  "node_modules/@smithy/signature-v4/dist-es/getPayloadHash.js"() {
    "use strict";
    init_dist_es16();
    init_dist_es11();
    init_dist_es6();
    init_constants2();
    getPayloadHash = async ({ headers, body }, hashConstructor) => {
      for (const headerName of Object.keys(headers)) {
        if (headerName.toLowerCase() === SHA256_HEADER) {
          return headers[headerName];
        }
      }
      if (body == void 0) {
        return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
      } else if (typeof body === "string" || ArrayBuffer.isView(body) || isArrayBuffer(body)) {
        const hashCtor = new hashConstructor();
        hashCtor.update(toUint8Array(body));
        return toHex(await hashCtor.digest());
      }
      return UNSIGNED_PAYLOAD;
    };
  }
});

// node_modules/@smithy/signature-v4/dist-es/HeaderFormatter.js
function negate(bytes) {
  for (let i2 = 0; i2 < 8; i2++) {
    bytes[i2] ^= 255;
  }
  for (let i2 = 7; i2 > -1; i2--) {
    bytes[i2]++;
    if (bytes[i2] !== 0)
      break;
  }
}
var HeaderFormatter, HEADER_VALUE_TYPE, UUID_PATTERN, Int64;
var init_HeaderFormatter = __esm({
  "node_modules/@smithy/signature-v4/dist-es/HeaderFormatter.js"() {
    "use strict";
    init_dist_es11();
    init_dist_es6();
    HeaderFormatter = class {
      format(headers) {
        const chunks = [];
        for (const headerName of Object.keys(headers)) {
          const bytes = fromUtf8(headerName);
          chunks.push(Uint8Array.from([bytes.byteLength]), bytes, this.formatHeaderValue(headers[headerName]));
        }
        const out = new Uint8Array(chunks.reduce((carry, bytes) => carry + bytes.byteLength, 0));
        let position = 0;
        for (const chunk of chunks) {
          out.set(chunk, position);
          position += chunk.byteLength;
        }
        return out;
      }
      formatHeaderValue(header) {
        switch (header.type) {
          case "boolean":
            return Uint8Array.from([header.value ? 0 : 1]);
          case "byte":
            return Uint8Array.from([2, header.value]);
          case "short":
            const shortView = new DataView(new ArrayBuffer(3));
            shortView.setUint8(0, 3);
            shortView.setInt16(1, header.value, false);
            return new Uint8Array(shortView.buffer);
          case "integer":
            const intView = new DataView(new ArrayBuffer(5));
            intView.setUint8(0, 4);
            intView.setInt32(1, header.value, false);
            return new Uint8Array(intView.buffer);
          case "long":
            const longBytes = new Uint8Array(9);
            longBytes[0] = 5;
            longBytes.set(header.value.bytes, 1);
            return longBytes;
          case "binary":
            const binView = new DataView(new ArrayBuffer(3 + header.value.byteLength));
            binView.setUint8(0, 6);
            binView.setUint16(1, header.value.byteLength, false);
            const binBytes = new Uint8Array(binView.buffer);
            binBytes.set(header.value, 3);
            return binBytes;
          case "string":
            const utf8Bytes = fromUtf8(header.value);
            const strView = new DataView(new ArrayBuffer(3 + utf8Bytes.byteLength));
            strView.setUint8(0, 7);
            strView.setUint16(1, utf8Bytes.byteLength, false);
            const strBytes = new Uint8Array(strView.buffer);
            strBytes.set(utf8Bytes, 3);
            return strBytes;
          case "timestamp":
            const tsBytes = new Uint8Array(9);
            tsBytes[0] = 8;
            tsBytes.set(Int64.fromNumber(header.value.valueOf()).bytes, 1);
            return tsBytes;
          case "uuid":
            if (!UUID_PATTERN.test(header.value)) {
              throw new Error(`Invalid UUID received: ${header.value}`);
            }
            const uuidBytes = new Uint8Array(17);
            uuidBytes[0] = 9;
            uuidBytes.set(fromHex(header.value.replace(/\-/g, "")), 1);
            return uuidBytes;
        }
      }
    };
    (function(HEADER_VALUE_TYPE3) {
      HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["boolTrue"] = 0] = "boolTrue";
      HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["boolFalse"] = 1] = "boolFalse";
      HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["byte"] = 2] = "byte";
      HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["short"] = 3] = "short";
      HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["integer"] = 4] = "integer";
      HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["long"] = 5] = "long";
      HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["byteArray"] = 6] = "byteArray";
      HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["string"] = 7] = "string";
      HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["timestamp"] = 8] = "timestamp";
      HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["uuid"] = 9] = "uuid";
    })(HEADER_VALUE_TYPE || (HEADER_VALUE_TYPE = {}));
    UUID_PATTERN = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
    Int64 = class _Int64 {
      bytes;
      constructor(bytes) {
        this.bytes = bytes;
        if (bytes.byteLength !== 8) {
          throw new Error("Int64 buffers must be exactly 8 bytes");
        }
      }
      static fromNumber(number) {
        if (number > 9223372036854776e3 || number < -9223372036854776e3) {
          throw new Error(`${number} is too large (or, if negative, too small) to represent as an Int64`);
        }
        const bytes = new Uint8Array(8);
        for (let i2 = 7, remaining = Math.abs(Math.round(number)); i2 > -1 && remaining > 0; i2--, remaining /= 256) {
          bytes[i2] = remaining;
        }
        if (number < 0) {
          negate(bytes);
        }
        return new _Int64(bytes);
      }
      valueOf() {
        const bytes = this.bytes.slice(0);
        const negative = bytes[0] & 128;
        if (negative) {
          negate(bytes);
        }
        return parseInt(toHex(bytes), 16) * (negative ? -1 : 1);
      }
      toString() {
        return String(this.valueOf());
      }
    };
  }
});

// node_modules/@smithy/signature-v4/dist-es/headerUtil.js
var hasHeader;
var init_headerUtil = __esm({
  "node_modules/@smithy/signature-v4/dist-es/headerUtil.js"() {
    "use strict";
    hasHeader = (soughtHeader, headers) => {
      soughtHeader = soughtHeader.toLowerCase();
      for (const headerName of Object.keys(headers)) {
        if (soughtHeader === headerName.toLowerCase()) {
          return true;
        }
      }
      return false;
    };
  }
});

// node_modules/@smithy/signature-v4/dist-es/moveHeadersToQuery.js
var moveHeadersToQuery;
var init_moveHeadersToQuery = __esm({
  "node_modules/@smithy/signature-v4/dist-es/moveHeadersToQuery.js"() {
    "use strict";
    init_dist_es2();
    moveHeadersToQuery = (request, options = {}) => {
      const { headers, query = {} } = HttpRequest.clone(request);
      for (const name of Object.keys(headers)) {
        const lname = name.toLowerCase();
        if (lname.slice(0, 6) === "x-amz-" && !options.unhoistableHeaders?.has(lname) || options.hoistableHeaders?.has(lname)) {
          query[name] = headers[name];
          delete headers[name];
        }
      }
      return {
        ...request,
        headers,
        query
      };
    };
  }
});

// node_modules/@smithy/signature-v4/dist-es/prepareRequest.js
var prepareRequest;
var init_prepareRequest = __esm({
  "node_modules/@smithy/signature-v4/dist-es/prepareRequest.js"() {
    "use strict";
    init_dist_es2();
    init_constants2();
    prepareRequest = (request) => {
      request = HttpRequest.clone(request);
      for (const headerName of Object.keys(request.headers)) {
        if (GENERATED_HEADERS.indexOf(headerName.toLowerCase()) > -1) {
          delete request.headers[headerName];
        }
      }
      return request;
    };
  }
});

// node_modules/@smithy/signature-v4/dist-es/getCanonicalQuery.js
var getCanonicalQuery;
var init_getCanonicalQuery = __esm({
  "node_modules/@smithy/signature-v4/dist-es/getCanonicalQuery.js"() {
    "use strict";
    init_dist_es8();
    init_constants2();
    getCanonicalQuery = ({ query = {} }) => {
      const keys = [];
      const serialized = {};
      for (const key of Object.keys(query)) {
        if (key.toLowerCase() === SIGNATURE_HEADER) {
          continue;
        }
        const encodedKey = escapeUri(key);
        keys.push(encodedKey);
        const value = query[key];
        if (typeof value === "string") {
          serialized[encodedKey] = `${encodedKey}=${escapeUri(value)}`;
        } else if (Array.isArray(value)) {
          serialized[encodedKey] = value.slice(0).reduce((encoded, value2) => encoded.concat([`${encodedKey}=${escapeUri(value2)}`]), []).sort().join("&");
        }
      }
      return keys.sort().map((key) => serialized[key]).filter((serialized2) => serialized2).join("&");
    };
  }
});

// node_modules/@smithy/signature-v4/dist-es/utilDate.js
var iso8601, toDate;
var init_utilDate = __esm({
  "node_modules/@smithy/signature-v4/dist-es/utilDate.js"() {
    "use strict";
    iso8601 = (time2) => toDate(time2).toISOString().replace(/\.\d{3}Z$/, "Z");
    toDate = (time2) => {
      if (typeof time2 === "number") {
        return new Date(time2 * 1e3);
      }
      if (typeof time2 === "string") {
        if (Number(time2)) {
          return new Date(Number(time2) * 1e3);
        }
        return new Date(time2);
      }
      return time2;
    };
  }
});

// node_modules/@smithy/signature-v4/dist-es/SignatureV4Base.js
var SignatureV4Base;
var init_SignatureV4Base = __esm({
  "node_modules/@smithy/signature-v4/dist-es/SignatureV4Base.js"() {
    "use strict";
    init_dist_es11();
    init_dist_es4();
    init_dist_es8();
    init_dist_es6();
    init_getCanonicalQuery();
    init_utilDate();
    SignatureV4Base = class {
      service;
      regionProvider;
      credentialProvider;
      sha256;
      uriEscapePath;
      applyChecksum;
      constructor({ applyChecksum, credentials, region, service, sha256, uriEscapePath = true }) {
        this.service = service;
        this.sha256 = sha256;
        this.uriEscapePath = uriEscapePath;
        this.applyChecksum = typeof applyChecksum === "boolean" ? applyChecksum : true;
        this.regionProvider = normalizeProvider(region);
        this.credentialProvider = normalizeProvider(credentials);
      }
      createCanonicalRequest(request, canonicalHeaders, payloadHash) {
        const sortedHeaders = Object.keys(canonicalHeaders).sort();
        return `${request.method}
${this.getCanonicalPath(request)}
${getCanonicalQuery(request)}
${sortedHeaders.map((name) => `${name}:${canonicalHeaders[name]}`).join("\n")}

${sortedHeaders.join(";")}
${payloadHash}`;
      }
      async createStringToSign(longDate, credentialScope, canonicalRequest, algorithmIdentifier) {
        const hash = new this.sha256();
        hash.update(toUint8Array(canonicalRequest));
        const hashedRequest = await hash.digest();
        return `${algorithmIdentifier}
${longDate}
${credentialScope}
${toHex(hashedRequest)}`;
      }
      getCanonicalPath({ path }) {
        if (this.uriEscapePath) {
          const normalizedPathSegments = [];
          for (const pathSegment of path.split("/")) {
            if (pathSegment?.length === 0)
              continue;
            if (pathSegment === ".")
              continue;
            if (pathSegment === "..") {
              normalizedPathSegments.pop();
            } else {
              normalizedPathSegments.push(pathSegment);
            }
          }
          const normalizedPath = `${path?.startsWith("/") ? "/" : ""}${normalizedPathSegments.join("/")}${normalizedPathSegments.length > 0 && path?.endsWith("/") ? "/" : ""}`;
          const doubleEncoded = escapeUri(normalizedPath);
          return doubleEncoded.replace(/%2F/g, "/");
        }
        return path;
      }
      validateResolvedCredentials(credentials) {
        if (typeof credentials !== "object" || typeof credentials.accessKeyId !== "string" || typeof credentials.secretAccessKey !== "string") {
          throw new Error("Resolved credential object is not valid");
        }
      }
      formatDate(now) {
        const longDate = iso8601(now).replace(/[\-:]/g, "");
        return {
          longDate,
          shortDate: longDate.slice(0, 8)
        };
      }
      getCanonicalHeaderList(headers) {
        return Object.keys(headers).sort().join(";");
      }
    };
  }
});

// node_modules/@smithy/signature-v4/dist-es/SignatureV4.js
var SignatureV4;
var init_SignatureV4 = __esm({
  "node_modules/@smithy/signature-v4/dist-es/SignatureV4.js"() {
    "use strict";
    init_dist_es11();
    init_dist_es6();
    init_constants2();
    init_credentialDerivation();
    init_getCanonicalHeaders();
    init_getPayloadHash();
    init_HeaderFormatter();
    init_headerUtil();
    init_moveHeadersToQuery();
    init_prepareRequest();
    init_SignatureV4Base();
    SignatureV4 = class extends SignatureV4Base {
      headerFormatter = new HeaderFormatter();
      constructor({ applyChecksum, credentials, region, service, sha256, uriEscapePath = true }) {
        super({
          applyChecksum,
          credentials,
          region,
          service,
          sha256,
          uriEscapePath
        });
      }
      async presign(originalRequest, options = {}) {
        const { signingDate = /* @__PURE__ */ new Date(), expiresIn = 3600, unsignableHeaders, unhoistableHeaders, signableHeaders, hoistableHeaders, signingRegion, signingService } = options;
        const credentials = await this.credentialProvider();
        this.validateResolvedCredentials(credentials);
        const region = signingRegion ?? await this.regionProvider();
        const { longDate, shortDate } = this.formatDate(signingDate);
        if (expiresIn > MAX_PRESIGNED_TTL) {
          return Promise.reject("Signature version 4 presigned URLs must have an expiration date less than one week in the future");
        }
        const scope = createScope(shortDate, region, signingService ?? this.service);
        const request = moveHeadersToQuery(prepareRequest(originalRequest), { unhoistableHeaders, hoistableHeaders });
        if (credentials.sessionToken) {
          request.query[TOKEN_QUERY_PARAM] = credentials.sessionToken;
        }
        request.query[ALGORITHM_QUERY_PARAM] = ALGORITHM_IDENTIFIER;
        request.query[CREDENTIAL_QUERY_PARAM] = `${credentials.accessKeyId}/${scope}`;
        request.query[AMZ_DATE_QUERY_PARAM] = longDate;
        request.query[EXPIRES_QUERY_PARAM] = expiresIn.toString(10);
        const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);
        request.query[SIGNED_HEADERS_QUERY_PARAM] = this.getCanonicalHeaderList(canonicalHeaders);
        request.query[SIGNATURE_QUERY_PARAM] = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, await getPayloadHash(originalRequest, this.sha256)));
        return request;
      }
      async sign(toSign, options) {
        if (typeof toSign === "string") {
          return this.signString(toSign, options);
        } else if (toSign.headers && toSign.payload) {
          return this.signEvent(toSign, options);
        } else if (toSign.message) {
          return this.signMessage(toSign, options);
        } else {
          return this.signRequest(toSign, options);
        }
      }
      async signEvent({ headers, payload }, { signingDate = /* @__PURE__ */ new Date(), priorSignature, signingRegion, signingService }) {
        const region = signingRegion ?? await this.regionProvider();
        const { shortDate, longDate } = this.formatDate(signingDate);
        const scope = createScope(shortDate, region, signingService ?? this.service);
        const hashedPayload = await getPayloadHash({ headers: {}, body: payload }, this.sha256);
        const hash = new this.sha256();
        hash.update(headers);
        const hashedHeaders = toHex(await hash.digest());
        const stringToSign = [
          EVENT_ALGORITHM_IDENTIFIER,
          longDate,
          scope,
          priorSignature,
          hashedHeaders,
          hashedPayload
        ].join("\n");
        return this.signString(stringToSign, { signingDate, signingRegion: region, signingService });
      }
      async signMessage(signableMessage, { signingDate = /* @__PURE__ */ new Date(), signingRegion, signingService }) {
        const promise = this.signEvent({
          headers: this.headerFormatter.format(signableMessage.message.headers),
          payload: signableMessage.message.body
        }, {
          signingDate,
          signingRegion,
          signingService,
          priorSignature: signableMessage.priorSignature
        });
        return promise.then((signature) => {
          return { message: signableMessage.message, signature };
        });
      }
      async signString(stringToSign, { signingDate = /* @__PURE__ */ new Date(), signingRegion, signingService } = {}) {
        const credentials = await this.credentialProvider();
        this.validateResolvedCredentials(credentials);
        const region = signingRegion ?? await this.regionProvider();
        const { shortDate } = this.formatDate(signingDate);
        const hash = new this.sha256(await this.getSigningKey(credentials, region, shortDate, signingService));
        hash.update(toUint8Array(stringToSign));
        return toHex(await hash.digest());
      }
      async signRequest(requestToSign, { signingDate = /* @__PURE__ */ new Date(), signableHeaders, unsignableHeaders, signingRegion, signingService } = {}) {
        const credentials = await this.credentialProvider();
        this.validateResolvedCredentials(credentials);
        const region = signingRegion ?? await this.regionProvider();
        const request = prepareRequest(requestToSign);
        const { longDate, shortDate } = this.formatDate(signingDate);
        const scope = createScope(shortDate, region, signingService ?? this.service);
        request.headers[AMZ_DATE_HEADER] = longDate;
        if (credentials.sessionToken) {
          request.headers[TOKEN_HEADER] = credentials.sessionToken;
        }
        const payloadHash = await getPayloadHash(request, this.sha256);
        if (!hasHeader(SHA256_HEADER, request.headers) && this.applyChecksum) {
          request.headers[SHA256_HEADER] = payloadHash;
        }
        const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);
        const signature = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, payloadHash));
        request.headers[AUTH_HEADER] = `${ALGORITHM_IDENTIFIER} Credential=${credentials.accessKeyId}/${scope}, SignedHeaders=${this.getCanonicalHeaderList(canonicalHeaders)}, Signature=${signature}`;
        return request;
      }
      async getSignature(longDate, credentialScope, keyPromise, canonicalRequest) {
        const stringToSign = await this.createStringToSign(longDate, credentialScope, canonicalRequest, ALGORITHM_IDENTIFIER);
        const hash = new this.sha256(await keyPromise);
        hash.update(toUint8Array(stringToSign));
        return toHex(await hash.digest());
      }
      getSigningKey(credentials, region, shortDate, service) {
        return getSigningKey(this.sha256, credentials, shortDate, region, service || this.service);
      }
    };
  }
});

// node_modules/@smithy/signature-v4/dist-es/signature-v4a-container.js
var signatureV4aContainer;
var init_signature_v4a_container = __esm({
  "node_modules/@smithy/signature-v4/dist-es/signature-v4a-container.js"() {
    "use strict";
    signatureV4aContainer = {
      SignatureV4a: null
    };
  }
});

// node_modules/@smithy/signature-v4/dist-es/index.js
var init_dist_es17 = __esm({
  "node_modules/@smithy/signature-v4/dist-es/index.js"() {
    "use strict";
    init_SignatureV4();
    init_constants2();
    init_credentialDerivation();
    init_signature_v4a_container();
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/resolveAwsSdkSigV4Config.js
function normalizeCredentialProvider(config, { credentials, credentialDefaultProvider }) {
  let credentialsProvider;
  if (credentials) {
    if (!credentials?.memoized) {
      credentialsProvider = memoizeIdentityProvider(credentials, isIdentityExpired, doesIdentityRequireRefresh);
    } else {
      credentialsProvider = credentials;
    }
  } else {
    if (credentialDefaultProvider) {
      credentialsProvider = normalizeProvider2(credentialDefaultProvider(Object.assign({}, config, {
        parentClientConfig: config
      })));
    } else {
      credentialsProvider = async () => {
        throw new Error("@aws-sdk/core::resolveAwsSdkSigV4Config - `credentials` not provided and no credentialDefaultProvider was configured.");
      };
    }
  }
  credentialsProvider.memoized = true;
  return credentialsProvider;
}
function bindCallerConfig(config, credentialsProvider) {
  if (credentialsProvider.configBound) {
    return credentialsProvider;
  }
  const fn = async (options) => credentialsProvider({ ...options, callerClientConfig: config });
  fn.memoized = credentialsProvider.memoized;
  fn.configBound = true;
  return fn;
}
var resolveAwsSdkSigV4Config;
var init_resolveAwsSdkSigV4Config = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/resolveAwsSdkSigV4Config.js"() {
    "use strict";
    init_client2();
    init_dist_es14();
    init_dist_es17();
    resolveAwsSdkSigV4Config = (config) => {
      let inputCredentials = config.credentials;
      let isUserSupplied = !!config.credentials;
      let resolvedCredentials = void 0;
      Object.defineProperty(config, "credentials", {
        set(credentials) {
          if (credentials && credentials !== inputCredentials && credentials !== resolvedCredentials) {
            isUserSupplied = true;
          }
          inputCredentials = credentials;
          const memoizedProvider = normalizeCredentialProvider(config, {
            credentials: inputCredentials,
            credentialDefaultProvider: config.credentialDefaultProvider
          });
          const boundProvider = bindCallerConfig(config, memoizedProvider);
          if (isUserSupplied && !boundProvider.attributed) {
            resolvedCredentials = async (options) => boundProvider(options).then((creds) => setCredentialFeature(creds, "CREDENTIALS_CODE", "e"));
            resolvedCredentials.memoized = boundProvider.memoized;
            resolvedCredentials.configBound = boundProvider.configBound;
            resolvedCredentials.attributed = true;
          } else {
            resolvedCredentials = boundProvider;
          }
        },
        get() {
          return resolvedCredentials;
        },
        enumerable: true,
        configurable: true
      });
      config.credentials = inputCredentials;
      const { signingEscapePath = true, systemClockOffset = config.systemClockOffset || 0, sha256 } = config;
      let signer;
      if (config.signer) {
        signer = normalizeProvider2(config.signer);
      } else if (config.regionInfoProvider) {
        signer = () => normalizeProvider2(config.region)().then(async (region) => [
          await config.regionInfoProvider(region, {
            useFipsEndpoint: await config.useFipsEndpoint(),
            useDualstackEndpoint: await config.useDualstackEndpoint()
          }) || {},
          region
        ]).then(([regionInfo, region]) => {
          const { signingRegion, signingService } = regionInfo;
          config.signingRegion = config.signingRegion || signingRegion || region;
          config.signingName = config.signingName || signingService || config.serviceId;
          const params = {
            ...config,
            credentials: config.credentials,
            region: config.signingRegion,
            service: config.signingName,
            sha256,
            uriEscapePath: signingEscapePath
          };
          const SignerCtor = config.signerConstructor || SignatureV4;
          return new SignerCtor(params);
        });
      } else {
        signer = async (authScheme) => {
          authScheme = Object.assign({}, {
            name: "sigv4",
            signingName: config.signingName || config.defaultSigningName,
            signingRegion: await normalizeProvider2(config.region)(),
            properties: {}
          }, authScheme);
          const signingRegion = authScheme.signingRegion;
          const signingService = authScheme.signingName;
          config.signingRegion = config.signingRegion || signingRegion;
          config.signingName = config.signingName || signingService || config.serviceId;
          const params = {
            ...config,
            credentials: config.credentials,
            region: config.signingRegion,
            service: config.signingName,
            sha256,
            uriEscapePath: signingEscapePath
          };
          const SignerCtor = config.signerConstructor || SignatureV4;
          return new SignerCtor(params);
        };
      }
      const resolvedConfig = Object.assign(config, {
        systemClockOffset,
        signingEscapePath,
        signer
      });
      return resolvedConfig;
    };
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/index.js
var init_aws_sdk = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/index.js"() {
    "use strict";
    init_AwsSdkSigV4Signer();
    init_AwsSdkSigV4ASigner();
    init_NODE_AUTH_SCHEME_PREFERENCE_OPTIONS();
    init_resolveAwsSdkSigV4AConfig();
    init_resolveAwsSdkSigV4Config();
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/index.js
var init_httpAuthSchemes2 = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/index.js"() {
    "use strict";
    init_aws_sdk();
    init_getBearerTokenEnvKey();
  }
});

// node_modules/@smithy/util-body-length-browser/dist-es/calculateBodyLength.js
var TEXT_ENCODER, calculateBodyLength;
var init_calculateBodyLength = __esm({
  "node_modules/@smithy/util-body-length-browser/dist-es/calculateBodyLength.js"() {
    "use strict";
    TEXT_ENCODER = typeof TextEncoder == "function" ? new TextEncoder() : null;
    calculateBodyLength = (body) => {
      if (typeof body === "string") {
        if (TEXT_ENCODER) {
          return TEXT_ENCODER.encode(body).byteLength;
        }
        let len = body.length;
        for (let i2 = len - 1; i2 >= 0; i2--) {
          const code = body.charCodeAt(i2);
          if (code > 127 && code <= 2047)
            len++;
          else if (code > 2047 && code <= 65535)
            len += 2;
          if (code >= 56320 && code <= 57343)
            i2--;
        }
        return len;
      } else if (typeof body.byteLength === "number") {
        return body.byteLength;
      } else if (typeof body.size === "number") {
        return body.size;
      }
      throw new Error(`Body Length computation failed for ${body}`);
    };
  }
});

// node_modules/@smithy/util-body-length-browser/dist-es/index.js
var init_dist_es18 = __esm({
  "node_modules/@smithy/util-body-length-browser/dist-es/index.js"() {
    "use strict";
    init_calculateBodyLength();
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/protocols/cbor/AwsSmithyRpcV2CborProtocol.js
var init_AwsSmithyRpcV2CborProtocol = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/protocols/cbor/AwsSmithyRpcV2CborProtocol.js"() {
    "use strict";
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/protocols/coercing-serializers.js
var init_coercing_serializers = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/protocols/coercing-serializers.js"() {
    "use strict";
  }
});

// node_modules/@smithy/middleware-stack/dist-es/MiddlewareStack.js
var getAllAliases, getMiddlewareNameWithAliases, constructStack, stepWeights, priorityWeights;
var init_MiddlewareStack = __esm({
  "node_modules/@smithy/middleware-stack/dist-es/MiddlewareStack.js"() {
    "use strict";
    getAllAliases = (name, aliases) => {
      const _aliases = [];
      if (name) {
        _aliases.push(name);
      }
      if (aliases) {
        for (const alias of aliases) {
          _aliases.push(alias);
        }
      }
      return _aliases;
    };
    getMiddlewareNameWithAliases = (name, aliases) => {
      return `${name || "anonymous"}${aliases && aliases.length > 0 ? ` (a.k.a. ${aliases.join(",")})` : ""}`;
    };
    constructStack = () => {
      let absoluteEntries = [];
      let relativeEntries = [];
      let identifyOnResolve = false;
      const entriesNameSet = /* @__PURE__ */ new Set();
      const sort = (entries) => entries.sort((a2, b2) => stepWeights[b2.step] - stepWeights[a2.step] || priorityWeights[b2.priority || "normal"] - priorityWeights[a2.priority || "normal"]);
      const removeByName = (toRemove) => {
        let isRemoved = false;
        const filterCb = (entry) => {
          const aliases = getAllAliases(entry.name, entry.aliases);
          if (aliases.includes(toRemove)) {
            isRemoved = true;
            for (const alias of aliases) {
              entriesNameSet.delete(alias);
            }
            return false;
          }
          return true;
        };
        absoluteEntries = absoluteEntries.filter(filterCb);
        relativeEntries = relativeEntries.filter(filterCb);
        return isRemoved;
      };
      const removeByReference = (toRemove) => {
        let isRemoved = false;
        const filterCb = (entry) => {
          if (entry.middleware === toRemove) {
            isRemoved = true;
            for (const alias of getAllAliases(entry.name, entry.aliases)) {
              entriesNameSet.delete(alias);
            }
            return false;
          }
          return true;
        };
        absoluteEntries = absoluteEntries.filter(filterCb);
        relativeEntries = relativeEntries.filter(filterCb);
        return isRemoved;
      };
      const cloneTo = (toStack) => {
        absoluteEntries.forEach((entry) => {
          toStack.add(entry.middleware, { ...entry });
        });
        relativeEntries.forEach((entry) => {
          toStack.addRelativeTo(entry.middleware, { ...entry });
        });
        toStack.identifyOnResolve?.(stack.identifyOnResolve());
        return toStack;
      };
      const expandRelativeMiddlewareList = (from) => {
        const expandedMiddlewareList = [];
        from.before.forEach((entry) => {
          if (entry.before.length === 0 && entry.after.length === 0) {
            expandedMiddlewareList.push(entry);
          } else {
            expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
          }
        });
        expandedMiddlewareList.push(from);
        from.after.reverse().forEach((entry) => {
          if (entry.before.length === 0 && entry.after.length === 0) {
            expandedMiddlewareList.push(entry);
          } else {
            expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
          }
        });
        return expandedMiddlewareList;
      };
      const getMiddlewareList = (debug = false) => {
        const normalizedAbsoluteEntries = [];
        const normalizedRelativeEntries = [];
        const normalizedEntriesNameMap = {};
        absoluteEntries.forEach((entry) => {
          const normalizedEntry = {
            ...entry,
            before: [],
            after: []
          };
          for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
            normalizedEntriesNameMap[alias] = normalizedEntry;
          }
          normalizedAbsoluteEntries.push(normalizedEntry);
        });
        relativeEntries.forEach((entry) => {
          const normalizedEntry = {
            ...entry,
            before: [],
            after: []
          };
          for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
            normalizedEntriesNameMap[alias] = normalizedEntry;
          }
          normalizedRelativeEntries.push(normalizedEntry);
        });
        normalizedRelativeEntries.forEach((entry) => {
          if (entry.toMiddleware) {
            const toMiddleware = normalizedEntriesNameMap[entry.toMiddleware];
            if (toMiddleware === void 0) {
              if (debug) {
                return;
              }
              throw new Error(`${entry.toMiddleware} is not found when adding ${getMiddlewareNameWithAliases(entry.name, entry.aliases)} middleware ${entry.relation} ${entry.toMiddleware}`);
            }
            if (entry.relation === "after") {
              toMiddleware.after.push(entry);
            }
            if (entry.relation === "before") {
              toMiddleware.before.push(entry);
            }
          }
        });
        const mainChain = sort(normalizedAbsoluteEntries).map(expandRelativeMiddlewareList).reduce((wholeList, expandedMiddlewareList) => {
          wholeList.push(...expandedMiddlewareList);
          return wholeList;
        }, []);
        return mainChain;
      };
      const stack = {
        add: (middleware, options = {}) => {
          const { name, override, aliases: _aliases } = options;
          const entry = {
            step: "initialize",
            priority: "normal",
            middleware,
            ...options
          };
          const aliases = getAllAliases(name, _aliases);
          if (aliases.length > 0) {
            if (aliases.some((alias) => entriesNameSet.has(alias))) {
              if (!override)
                throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);
              for (const alias of aliases) {
                const toOverrideIndex = absoluteEntries.findIndex((entry2) => entry2.name === alias || entry2.aliases?.some((a2) => a2 === alias));
                if (toOverrideIndex === -1) {
                  continue;
                }
                const toOverride = absoluteEntries[toOverrideIndex];
                if (toOverride.step !== entry.step || entry.priority !== toOverride.priority) {
                  throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware with ${toOverride.priority} priority in ${toOverride.step} step cannot be overridden by "${getMiddlewareNameWithAliases(name, _aliases)}" middleware with ${entry.priority} priority in ${entry.step} step.`);
                }
                absoluteEntries.splice(toOverrideIndex, 1);
              }
            }
            for (const alias of aliases) {
              entriesNameSet.add(alias);
            }
          }
          absoluteEntries.push(entry);
        },
        addRelativeTo: (middleware, options) => {
          const { name, override, aliases: _aliases } = options;
          const entry = {
            middleware,
            ...options
          };
          const aliases = getAllAliases(name, _aliases);
          if (aliases.length > 0) {
            if (aliases.some((alias) => entriesNameSet.has(alias))) {
              if (!override)
                throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);
              for (const alias of aliases) {
                const toOverrideIndex = relativeEntries.findIndex((entry2) => entry2.name === alias || entry2.aliases?.some((a2) => a2 === alias));
                if (toOverrideIndex === -1) {
                  continue;
                }
                const toOverride = relativeEntries[toOverrideIndex];
                if (toOverride.toMiddleware !== entry.toMiddleware || toOverride.relation !== entry.relation) {
                  throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware ${toOverride.relation} "${toOverride.toMiddleware}" middleware cannot be overridden by "${getMiddlewareNameWithAliases(name, _aliases)}" middleware ${entry.relation} "${entry.toMiddleware}" middleware.`);
                }
                relativeEntries.splice(toOverrideIndex, 1);
              }
            }
            for (const alias of aliases) {
              entriesNameSet.add(alias);
            }
          }
          relativeEntries.push(entry);
        },
        clone: () => cloneTo(constructStack()),
        use: (plugin) => {
          plugin.applyToStack(stack);
        },
        remove: (toRemove) => {
          if (typeof toRemove === "string")
            return removeByName(toRemove);
          else
            return removeByReference(toRemove);
        },
        removeByTag: (toRemove) => {
          let isRemoved = false;
          const filterCb = (entry) => {
            const { tags, name, aliases: _aliases } = entry;
            if (tags && tags.includes(toRemove)) {
              const aliases = getAllAliases(name, _aliases);
              for (const alias of aliases) {
                entriesNameSet.delete(alias);
              }
              isRemoved = true;
              return false;
            }
            return true;
          };
          absoluteEntries = absoluteEntries.filter(filterCb);
          relativeEntries = relativeEntries.filter(filterCb);
          return isRemoved;
        },
        concat: (from) => {
          const cloned = cloneTo(constructStack());
          cloned.use(from);
          cloned.identifyOnResolve(identifyOnResolve || cloned.identifyOnResolve() || (from.identifyOnResolve?.() ?? false));
          return cloned;
        },
        applyToStack: cloneTo,
        identify: () => {
          return getMiddlewareList(true).map((mw) => {
            const step = mw.step ?? mw.relation + " " + mw.toMiddleware;
            return getMiddlewareNameWithAliases(mw.name, mw.aliases) + " - " + step;
          });
        },
        identifyOnResolve(toggle) {
          if (typeof toggle === "boolean")
            identifyOnResolve = toggle;
          return identifyOnResolve;
        },
        resolve: (handler, context) => {
          for (const middleware of getMiddlewareList().map((entry) => entry.middleware).reverse()) {
            handler = middleware(handler, context);
          }
          if (identifyOnResolve) {
            console.log(stack.identify());
          }
          return handler;
        }
      };
      return stack;
    };
    stepWeights = {
      initialize: 5,
      serialize: 4,
      build: 3,
      finalizeRequest: 2,
      deserialize: 1
    };
    priorityWeights = {
      high: 3,
      normal: 2,
      low: 1
    };
  }
});

// node_modules/@smithy/middleware-stack/dist-es/index.js
var init_dist_es19 = __esm({
  "node_modules/@smithy/middleware-stack/dist-es/index.js"() {
    "use strict";
    init_MiddlewareStack();
  }
});

// node_modules/@smithy/smithy-client/dist-es/client.js
var Client;
var init_client3 = __esm({
  "node_modules/@smithy/smithy-client/dist-es/client.js"() {
    "use strict";
    init_dist_es19();
    Client = class {
      config;
      middlewareStack = constructStack();
      initConfig;
      handlers;
      constructor(config) {
        this.config = config;
      }
      send(command, optionsOrCb, cb2) {
        const options = typeof optionsOrCb !== "function" ? optionsOrCb : void 0;
        const callback = typeof optionsOrCb === "function" ? optionsOrCb : cb2;
        const useHandlerCache = options === void 0 && this.config.cacheMiddleware === true;
        let handler;
        if (useHandlerCache) {
          if (!this.handlers) {
            this.handlers = /* @__PURE__ */ new WeakMap();
          }
          const handlers = this.handlers;
          if (handlers.has(command.constructor)) {
            handler = handlers.get(command.constructor);
          } else {
            handler = command.resolveMiddleware(this.middlewareStack, this.config, options);
            handlers.set(command.constructor, handler);
          }
        } else {
          delete this.handlers;
          handler = command.resolveMiddleware(this.middlewareStack, this.config, options);
        }
        if (callback) {
          handler(command).then((result) => callback(null, result.output), (err) => callback(err)).catch(() => {
          });
        } else {
          return handler(command).then((result) => result.output);
        }
      }
      destroy() {
        this.config?.requestHandler?.destroy?.();
        delete this.handlers;
      }
    };
  }
});

// node_modules/@smithy/smithy-client/dist-es/collect-stream-body.js
var init_collect_stream_body2 = __esm({
  "node_modules/@smithy/smithy-client/dist-es/collect-stream-body.js"() {
    "use strict";
    init_protocols();
  }
});

// node_modules/@smithy/smithy-client/dist-es/schemaLogFilter.js
function schemaLogFilter(schema, data) {
  if (data == null) {
    return data;
  }
  const ns = NormalizedSchema.of(schema);
  if (ns.getMergedTraits().sensitive) {
    return SENSITIVE_STRING;
  }
  if (ns.isListSchema()) {
    const isSensitive = !!ns.getValueSchema().getMergedTraits().sensitive;
    if (isSensitive) {
      return SENSITIVE_STRING;
    }
  } else if (ns.isMapSchema()) {
    const isSensitive = !!ns.getKeySchema().getMergedTraits().sensitive || !!ns.getValueSchema().getMergedTraits().sensitive;
    if (isSensitive) {
      return SENSITIVE_STRING;
    }
  } else if (ns.isStructSchema() && typeof data === "object") {
    const object = data;
    const newObject = {};
    for (const [member2, memberNs] of ns.structIterator()) {
      if (object[member2] != null) {
        newObject[member2] = schemaLogFilter(memberNs, object[member2]);
      }
    }
    return newObject;
  }
  return data;
}
var SENSITIVE_STRING;
var init_schemaLogFilter = __esm({
  "node_modules/@smithy/smithy-client/dist-es/schemaLogFilter.js"() {
    "use strict";
    init_schema2();
    SENSITIVE_STRING = "***SensitiveInformation***";
  }
});

// node_modules/@smithy/smithy-client/dist-es/command.js
var Command, ClassBuilder;
var init_command2 = __esm({
  "node_modules/@smithy/smithy-client/dist-es/command.js"() {
    "use strict";
    init_dist_es19();
    init_dist_es();
    init_schemaLogFilter();
    Command = class {
      middlewareStack = constructStack();
      schema;
      static classBuilder() {
        return new ClassBuilder();
      }
      resolveMiddlewareWithContext(clientStack, configuration, options, { middlewareFn, clientName, commandName, inputFilterSensitiveLog, outputFilterSensitiveLog, smithyContext, additionalContext, CommandCtor }) {
        for (const mw of middlewareFn.bind(this)(CommandCtor, clientStack, configuration, options)) {
          this.middlewareStack.use(mw);
        }
        const stack = clientStack.concat(this.middlewareStack);
        const { logger: logger2 } = configuration;
        const handlerExecutionContext = {
          logger: logger2,
          clientName,
          commandName,
          inputFilterSensitiveLog,
          outputFilterSensitiveLog,
          [SMITHY_CONTEXT_KEY]: {
            commandInstance: this,
            ...smithyContext
          },
          ...additionalContext
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
      }
    };
    ClassBuilder = class {
      _init = () => {
      };
      _ep = {};
      _middlewareFn = () => [];
      _commandName = "";
      _clientName = "";
      _additionalContext = {};
      _smithyContext = {};
      _inputFilterSensitiveLog = void 0;
      _outputFilterSensitiveLog = void 0;
      _serializer = null;
      _deserializer = null;
      _operationSchema;
      init(cb2) {
        this._init = cb2;
      }
      ep(endpointParameterInstructions) {
        this._ep = endpointParameterInstructions;
        return this;
      }
      m(middlewareSupplier) {
        this._middlewareFn = middlewareSupplier;
        return this;
      }
      s(service, operation, smithyContext = {}) {
        this._smithyContext = {
          service,
          operation,
          ...smithyContext
        };
        return this;
      }
      c(additionalContext = {}) {
        this._additionalContext = additionalContext;
        return this;
      }
      n(clientName, commandName) {
        this._clientName = clientName;
        this._commandName = commandName;
        return this;
      }
      f(inputFilter = (_) => _, outputFilter = (_) => _) {
        this._inputFilterSensitiveLog = inputFilter;
        this._outputFilterSensitiveLog = outputFilter;
        return this;
      }
      ser(serializer) {
        this._serializer = serializer;
        return this;
      }
      de(deserializer) {
        this._deserializer = deserializer;
        return this;
      }
      sc(operation) {
        this._operationSchema = operation;
        this._smithyContext.operationSchema = operation;
        return this;
      }
      build() {
        const closure = this;
        let CommandRef;
        return CommandRef = class extends Command {
          input;
          static getEndpointParameterInstructions() {
            return closure._ep;
          }
          constructor(...[input]) {
            super();
            this.input = input ?? {};
            closure._init(this);
            this.schema = closure._operationSchema;
          }
          resolveMiddleware(stack, configuration, options) {
            const op = closure._operationSchema;
            const input = op?.[4] ?? op?.input;
            const output = op?.[5] ?? op?.output;
            return this.resolveMiddlewareWithContext(stack, configuration, options, {
              CommandCtor: CommandRef,
              middlewareFn: closure._middlewareFn,
              clientName: closure._clientName,
              commandName: closure._commandName,
              inputFilterSensitiveLog: closure._inputFilterSensitiveLog ?? (op ? schemaLogFilter.bind(null, input) : (_) => _),
              outputFilterSensitiveLog: closure._outputFilterSensitiveLog ?? (op ? schemaLogFilter.bind(null, output) : (_) => _),
              smithyContext: closure._smithyContext,
              additionalContext: closure._additionalContext
            });
          }
          serialize = closure._serializer;
          deserialize = closure._deserializer;
        };
      }
    };
  }
});

// node_modules/@smithy/smithy-client/dist-es/constants.js
var SENSITIVE_STRING2;
var init_constants3 = __esm({
  "node_modules/@smithy/smithy-client/dist-es/constants.js"() {
    "use strict";
    SENSITIVE_STRING2 = "***SensitiveInformation***";
  }
});

// node_modules/@smithy/smithy-client/dist-es/create-aggregated-client.js
var createAggregatedClient;
var init_create_aggregated_client = __esm({
  "node_modules/@smithy/smithy-client/dist-es/create-aggregated-client.js"() {
    "use strict";
    createAggregatedClient = (commands2, Client2) => {
      for (const command of Object.keys(commands2)) {
        const CommandCtor = commands2[command];
        const methodImpl = async function(args, optionsOrCb, cb2) {
          const command2 = new CommandCtor(args);
          if (typeof optionsOrCb === "function") {
            this.send(command2, optionsOrCb);
          } else if (typeof cb2 === "function") {
            if (typeof optionsOrCb !== "object")
              throw new Error(`Expected http options but got ${typeof optionsOrCb}`);
            this.send(command2, optionsOrCb || {}, cb2);
          } else {
            return this.send(command2, optionsOrCb);
          }
        };
        const methodName = (command[0].toLowerCase() + command.slice(1)).replace(/Command$/, "");
        Client2.prototype[methodName] = methodImpl;
      }
    };
  }
});

// node_modules/@smithy/smithy-client/dist-es/exceptions.js
var ServiceException, decorateServiceException;
var init_exceptions = __esm({
  "node_modules/@smithy/smithy-client/dist-es/exceptions.js"() {
    "use strict";
    ServiceException = class _ServiceException extends Error {
      $fault;
      $response;
      $retryable;
      $metadata;
      constructor(options) {
        super(options.message);
        Object.setPrototypeOf(this, Object.getPrototypeOf(this).constructor.prototype);
        this.name = options.name;
        this.$fault = options.$fault;
        this.$metadata = options.$metadata;
      }
      static isInstance(value) {
        if (!value)
          return false;
        const candidate = value;
        return _ServiceException.prototype.isPrototypeOf(candidate) || Boolean(candidate.$fault) && Boolean(candidate.$metadata) && (candidate.$fault === "client" || candidate.$fault === "server");
      }
      static [Symbol.hasInstance](instance) {
        if (!instance)
          return false;
        const candidate = instance;
        if (this === _ServiceException) {
          return _ServiceException.isInstance(instance);
        }
        if (_ServiceException.isInstance(instance)) {
          if (candidate.name && this.name) {
            return this.prototype.isPrototypeOf(instance) || candidate.name === this.name;
          }
          return this.prototype.isPrototypeOf(instance);
        }
        return false;
      }
    };
    decorateServiceException = (exception, additions = {}) => {
      Object.entries(additions).filter(([, v2]) => v2 !== void 0).forEach(([k2, v2]) => {
        if (exception[k2] == void 0 || exception[k2] === "") {
          exception[k2] = v2;
        }
      });
      const message = exception.message || exception.Message || "UnknownError";
      exception.message = message;
      delete exception.Message;
      return exception;
    };
  }
});

// node_modules/@smithy/smithy-client/dist-es/default-error-handler.js
var throwDefaultError, withBaseException, deserializeMetadata;
var init_default_error_handler = __esm({
  "node_modules/@smithy/smithy-client/dist-es/default-error-handler.js"() {
    "use strict";
    init_exceptions();
    throwDefaultError = ({ output, parsedBody, exceptionCtor, errorCode }) => {
      const $metadata = deserializeMetadata(output);
      const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : void 0;
      const response = new exceptionCtor({
        name: parsedBody?.code || parsedBody?.Code || errorCode || statusCode || "UnknownError",
        $fault: "client",
        $metadata
      });
      throw decorateServiceException(response, parsedBody);
    };
    withBaseException = (ExceptionCtor) => {
      return ({ output, parsedBody, errorCode }) => {
        throwDefaultError({ output, parsedBody, exceptionCtor: ExceptionCtor, errorCode });
      };
    };
    deserializeMetadata = (output) => ({
      httpStatusCode: output.statusCode,
      requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
      extendedRequestId: output.headers["x-amz-id-2"],
      cfId: output.headers["x-amz-cf-id"]
    });
  }
});

// node_modules/@smithy/smithy-client/dist-es/defaults-mode.js
var loadConfigsForDefaultMode;
var init_defaults_mode = __esm({
  "node_modules/@smithy/smithy-client/dist-es/defaults-mode.js"() {
    "use strict";
    loadConfigsForDefaultMode = (mode) => {
      switch (mode) {
        case "standard":
          return {
            retryMode: "standard",
            connectionTimeout: 3100
          };
        case "in-region":
          return {
            retryMode: "standard",
            connectionTimeout: 1100
          };
        case "cross-region":
          return {
            retryMode: "standard",
            connectionTimeout: 3100
          };
        case "mobile":
          return {
            retryMode: "standard",
            connectionTimeout: 3e4
          };
        default:
          return {};
      }
    };
  }
});

// node_modules/@smithy/smithy-client/dist-es/emitWarningIfUnsupportedVersion.js
var init_emitWarningIfUnsupportedVersion2 = __esm({
  "node_modules/@smithy/smithy-client/dist-es/emitWarningIfUnsupportedVersion.js"() {
    "use strict";
  }
});

// node_modules/@smithy/smithy-client/dist-es/extended-encode-uri-component.js
var init_extended_encode_uri_component2 = __esm({
  "node_modules/@smithy/smithy-client/dist-es/extended-encode-uri-component.js"() {
    "use strict";
  }
});

// node_modules/@smithy/smithy-client/dist-es/extensions/checksum.js
var getChecksumConfiguration, resolveChecksumRuntimeConfig;
var init_checksum3 = __esm({
  "node_modules/@smithy/smithy-client/dist-es/extensions/checksum.js"() {
    "use strict";
    init_dist_es();
    getChecksumConfiguration = (runtimeConfig) => {
      const checksumAlgorithms = [];
      for (const id in AlgorithmId) {
        const algorithmId = AlgorithmId[id];
        if (runtimeConfig[algorithmId] === void 0) {
          continue;
        }
        checksumAlgorithms.push({
          algorithmId: () => algorithmId,
          checksumConstructor: () => runtimeConfig[algorithmId]
        });
      }
      return {
        addChecksumAlgorithm(algo) {
          checksumAlgorithms.push(algo);
        },
        checksumAlgorithms() {
          return checksumAlgorithms;
        }
      };
    };
    resolveChecksumRuntimeConfig = (clientConfig) => {
      const runtimeConfig = {};
      clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
        runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
      });
      return runtimeConfig;
    };
  }
});

// node_modules/@smithy/smithy-client/dist-es/extensions/retry.js
var getRetryConfiguration, resolveRetryRuntimeConfig;
var init_retry2 = __esm({
  "node_modules/@smithy/smithy-client/dist-es/extensions/retry.js"() {
    "use strict";
    getRetryConfiguration = (runtimeConfig) => {
      return {
        setRetryStrategy(retryStrategy) {
          runtimeConfig.retryStrategy = retryStrategy;
        },
        retryStrategy() {
          return runtimeConfig.retryStrategy;
        }
      };
    };
    resolveRetryRuntimeConfig = (retryStrategyConfiguration) => {
      const runtimeConfig = {};
      runtimeConfig.retryStrategy = retryStrategyConfiguration.retryStrategy();
      return runtimeConfig;
    };
  }
});

// node_modules/@smithy/smithy-client/dist-es/extensions/defaultExtensionConfiguration.js
var getDefaultExtensionConfiguration, resolveDefaultRuntimeConfig;
var init_defaultExtensionConfiguration2 = __esm({
  "node_modules/@smithy/smithy-client/dist-es/extensions/defaultExtensionConfiguration.js"() {
    "use strict";
    init_checksum3();
    init_retry2();
    getDefaultExtensionConfiguration = (runtimeConfig) => {
      return Object.assign(getChecksumConfiguration(runtimeConfig), getRetryConfiguration(runtimeConfig));
    };
    resolveDefaultRuntimeConfig = (config) => {
      return Object.assign(resolveChecksumRuntimeConfig(config), resolveRetryRuntimeConfig(config));
    };
  }
});

// node_modules/@smithy/smithy-client/dist-es/extensions/index.js
var init_extensions3 = __esm({
  "node_modules/@smithy/smithy-client/dist-es/extensions/index.js"() {
    "use strict";
    init_defaultExtensionConfiguration2();
  }
});

// node_modules/@smithy/smithy-client/dist-es/get-array-if-single-item.js
var getArrayIfSingleItem;
var init_get_array_if_single_item = __esm({
  "node_modules/@smithy/smithy-client/dist-es/get-array-if-single-item.js"() {
    "use strict";
    getArrayIfSingleItem = (mayBeArray) => Array.isArray(mayBeArray) ? mayBeArray : [mayBeArray];
  }
});

// node_modules/@smithy/smithy-client/dist-es/get-value-from-text-node.js
var getValueFromTextNode;
var init_get_value_from_text_node = __esm({
  "node_modules/@smithy/smithy-client/dist-es/get-value-from-text-node.js"() {
    "use strict";
    getValueFromTextNode = (obj) => {
      const textNodeName = "#text";
      for (const key in obj) {
        if (obj.hasOwnProperty(key) && obj[key][textNodeName] !== void 0) {
          obj[key] = obj[key][textNodeName];
        } else if (typeof obj[key] === "object" && obj[key] !== null) {
          obj[key] = getValueFromTextNode(obj[key]);
        }
      }
      return obj;
    };
  }
});

// node_modules/@smithy/smithy-client/dist-es/is-serializable-header-value.js
var isSerializableHeaderValue;
var init_is_serializable_header_value = __esm({
  "node_modules/@smithy/smithy-client/dist-es/is-serializable-header-value.js"() {
    "use strict";
    isSerializableHeaderValue = (value) => {
      return value != null;
    };
  }
});

// node_modules/@smithy/smithy-client/dist-es/NoOpLogger.js
var NoOpLogger;
var init_NoOpLogger = __esm({
  "node_modules/@smithy/smithy-client/dist-es/NoOpLogger.js"() {
    "use strict";
    NoOpLogger = class {
      trace() {
      }
      debug() {
      }
      info() {
      }
      warn() {
      }
      error() {
      }
    };
  }
});

// node_modules/@smithy/smithy-client/dist-es/object-mapping.js
function map(arg0, arg1, arg2) {
  let target;
  let filter;
  let instructions;
  if (typeof arg1 === "undefined" && typeof arg2 === "undefined") {
    target = {};
    instructions = arg0;
  } else {
    target = arg0;
    if (typeof arg1 === "function") {
      filter = arg1;
      instructions = arg2;
      return mapWithFilter(target, filter, instructions);
    } else {
      instructions = arg1;
    }
  }
  for (const key of Object.keys(instructions)) {
    if (!Array.isArray(instructions[key])) {
      target[key] = instructions[key];
      continue;
    }
    applyInstruction(target, null, instructions, key);
  }
  return target;
}
var mapWithFilter, applyInstruction, nonNullish, pass;
var init_object_mapping = __esm({
  "node_modules/@smithy/smithy-client/dist-es/object-mapping.js"() {
    "use strict";
    mapWithFilter = (target, filter, instructions) => {
      return map(target, Object.entries(instructions).reduce((_instructions, [key, value]) => {
        if (Array.isArray(value)) {
          _instructions[key] = value;
        } else {
          if (typeof value === "function") {
            _instructions[key] = [filter, value()];
          } else {
            _instructions[key] = [filter, value];
          }
        }
        return _instructions;
      }, {}));
    };
    applyInstruction = (target, source, instructions, targetKey) => {
      if (source !== null) {
        let instruction = instructions[targetKey];
        if (typeof instruction === "function") {
          instruction = [, instruction];
        }
        const [filter2 = nonNullish, valueFn = pass, sourceKey = targetKey] = instruction;
        if (typeof filter2 === "function" && filter2(source[sourceKey]) || typeof filter2 !== "function" && !!filter2) {
          target[targetKey] = valueFn(source[sourceKey]);
        }
        return;
      }
      let [filter, value] = instructions[targetKey];
      if (typeof value === "function") {
        let _value;
        const defaultFilterPassed = filter === void 0 && (_value = value()) != null;
        const customFilterPassed = typeof filter === "function" && !!filter(void 0) || typeof filter !== "function" && !!filter;
        if (defaultFilterPassed) {
          target[targetKey] = _value;
        } else if (customFilterPassed) {
          target[targetKey] = value();
        }
      } else {
        const defaultFilterPassed = filter === void 0 && value != null;
        const customFilterPassed = typeof filter === "function" && !!filter(value) || typeof filter !== "function" && !!filter;
        if (defaultFilterPassed || customFilterPassed) {
          target[targetKey] = value;
        }
      }
    };
    nonNullish = (_) => _ != null;
    pass = (_) => _;
  }
});

// node_modules/@smithy/smithy-client/dist-es/resolve-path.js
var init_resolve_path2 = __esm({
  "node_modules/@smithy/smithy-client/dist-es/resolve-path.js"() {
    "use strict";
  }
});

// node_modules/@smithy/smithy-client/dist-es/ser-utils.js
var serializeDateTime;
var init_ser_utils = __esm({
  "node_modules/@smithy/smithy-client/dist-es/ser-utils.js"() {
    "use strict";
    serializeDateTime = (date2) => date2.toISOString().replace(".000Z", "Z");
  }
});

// node_modules/@smithy/smithy-client/dist-es/serde-json.js
var init_serde_json = __esm({
  "node_modules/@smithy/smithy-client/dist-es/serde-json.js"() {
    "use strict";
  }
});

// node_modules/@smithy/smithy-client/dist-es/index.js
var init_dist_es20 = __esm({
  "node_modules/@smithy/smithy-client/dist-es/index.js"() {
    "use strict";
    init_client3();
    init_collect_stream_body2();
    init_command2();
    init_constants3();
    init_create_aggregated_client();
    init_default_error_handler();
    init_defaults_mode();
    init_emitWarningIfUnsupportedVersion2();
    init_exceptions();
    init_extended_encode_uri_component2();
    init_extensions3();
    init_get_array_if_single_item();
    init_get_value_from_text_node();
    init_is_serializable_header_value();
    init_NoOpLogger();
    init_object_mapping();
    init_resolve_path2();
    init_ser_utils();
    init_serde_json();
    init_serde2();
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/protocols/common.js
var collectBodyString;
var init_common = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/protocols/common.js"() {
    "use strict";
    init_dist_es20();
    init_dist_es6();
    collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => (context?.utf8Encoder ?? toUtf8)(body));
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/parseJsonBody.js
var init_parseJsonBody = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/parseJsonBody.js"() {
    "use strict";
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/JsonShapeDeserializer.js
var init_JsonShapeDeserializer = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/JsonShapeDeserializer.js"() {
    "use strict";
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/JsonShapeSerializer.js
var init_JsonShapeSerializer = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/JsonShapeSerializer.js"() {
    "use strict";
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/JsonCodec.js
var init_JsonCodec = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/JsonCodec.js"() {
    "use strict";
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/AwsJsonRpcProtocol.js
var init_AwsJsonRpcProtocol = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/AwsJsonRpcProtocol.js"() {
    "use strict";
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/AwsJson1_0Protocol.js
var init_AwsJson1_0Protocol = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/AwsJson1_0Protocol.js"() {
    "use strict";
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/AwsJson1_1Protocol.js
var init_AwsJson1_1Protocol = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/AwsJson1_1Protocol.js"() {
    "use strict";
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/AwsRestJsonProtocol.js
var init_AwsRestJsonProtocol = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/AwsRestJsonProtocol.js"() {
    "use strict";
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/awsExpectUnion.js
var init_awsExpectUnion = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/awsExpectUnion.js"() {
    "use strict";
  }
});

// node_modules/@aws-sdk/xml-builder/dist-es/escape-attribute.js
function escapeAttribute(value) {
  return value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
}
var init_escape_attribute = __esm({
  "node_modules/@aws-sdk/xml-builder/dist-es/escape-attribute.js"() {
    "use strict";
  }
});

// node_modules/@aws-sdk/xml-builder/dist-es/escape-element.js
function escapeElement(value) {
  return value.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&apos;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#x0D;").replace(/\n/g, "&#x0A;").replace(/\u0085/g, "&#x85;").replace(/\u2028/, "&#x2028;");
}
var init_escape_element = __esm({
  "node_modules/@aws-sdk/xml-builder/dist-es/escape-element.js"() {
    "use strict";
  }
});

// node_modules/@aws-sdk/xml-builder/dist-es/XmlText.js
var XmlText;
var init_XmlText = __esm({
  "node_modules/@aws-sdk/xml-builder/dist-es/XmlText.js"() {
    "use strict";
    init_escape_element();
    XmlText = class {
      value;
      constructor(value) {
        this.value = value;
      }
      toString() {
        return escapeElement("" + this.value);
      }
    };
  }
});

// node_modules/@aws-sdk/xml-builder/dist-es/XmlNode.js
var XmlNode;
var init_XmlNode = __esm({
  "node_modules/@aws-sdk/xml-builder/dist-es/XmlNode.js"() {
    "use strict";
    init_escape_attribute();
    init_XmlText();
    XmlNode = class _XmlNode {
      name;
      children;
      attributes = {};
      static of(name, childText, withName) {
        const node = new _XmlNode(name);
        if (childText !== void 0) {
          node.addChildNode(new XmlText(childText));
        }
        if (withName !== void 0) {
          node.withName(withName);
        }
        return node;
      }
      constructor(name, children = []) {
        this.name = name;
        this.children = children;
      }
      withName(name) {
        this.name = name;
        return this;
      }
      addAttribute(name, value) {
        this.attributes[name] = value;
        return this;
      }
      addChildNode(child) {
        this.children.push(child);
        return this;
      }
      removeAttribute(name) {
        delete this.attributes[name];
        return this;
      }
      n(name) {
        this.name = name;
        return this;
      }
      c(child) {
        this.children.push(child);
        return this;
      }
      a(name, value) {
        if (value != null) {
          this.attributes[name] = value;
        }
        return this;
      }
      cc(input, field, withName = field) {
        if (input[field] != null) {
          const node = _XmlNode.of(field, input[field]).withName(withName);
          this.c(node);
        }
      }
      l(input, listName, memberName, valueProvider) {
        if (input[listName] != null) {
          const nodes = valueProvider();
          nodes.map((node) => {
            node.withName(memberName);
            this.c(node);
          });
        }
      }
      lc(input, listName, memberName, valueProvider) {
        if (input[listName] != null) {
          const nodes = valueProvider();
          const containerNode = new _XmlNode(memberName);
          nodes.map((node) => {
            containerNode.c(node);
          });
          this.c(containerNode);
        }
      }
      toString() {
        const hasChildren = Boolean(this.children.length);
        let xmlText = `<${this.name}`;
        const attributes = this.attributes;
        for (const attributeName of Object.keys(attributes)) {
          const attribute = attributes[attributeName];
          if (attribute != null) {
            xmlText += ` ${attributeName}="${escapeAttribute("" + attribute)}"`;
          }
        }
        return xmlText += !hasChildren ? "/>" : `>${this.children.map((c2) => c2.toString()).join("")}</${this.name}>`;
      }
    };
  }
});

// node_modules/@aws-sdk/xml-builder/dist-es/xml-parser.browser.js
function parseXML(xmlString) {
  if (!parser) {
    parser = new DOMParser();
  }
  const xmlDocument = parser.parseFromString(xmlString, "application/xml");
  if (xmlDocument.getElementsByTagName("parsererror").length > 0) {
    throw new Error("DOMParser XML parsing error.");
  }
  const xmlToObj = (node) => {
    if (node.nodeType === Node.TEXT_NODE) {
      if (node.textContent?.trim()) {
        return node.textContent;
      }
    }
    if (node.nodeType === Node.ELEMENT_NODE) {
      const element = node;
      if (element.attributes.length === 0 && element.childNodes.length === 0) {
        return "";
      }
      const obj = {};
      const attributes = Array.from(element.attributes);
      for (const attr of attributes) {
        obj[`${attr.name}`] = attr.value;
      }
      const childNodes = Array.from(element.childNodes);
      for (const child of childNodes) {
        const childResult = xmlToObj(child);
        if (childResult != null) {
          const childName = child.nodeName;
          if (childNodes.length === 1 && attributes.length === 0 && childName === "#text") {
            return childResult;
          }
          if (obj[childName]) {
            if (Array.isArray(obj[childName])) {
              obj[childName].push(childResult);
            } else {
              obj[childName] = [obj[childName], childResult];
            }
          } else {
            obj[childName] = childResult;
          }
        } else if (childNodes.length === 1 && attributes.length === 0) {
          return element.textContent;
        }
      }
      return obj;
    }
    return null;
  };
  return {
    [xmlDocument.documentElement.nodeName]: xmlToObj(xmlDocument.documentElement)
  };
}
var parser;
var init_xml_parser_browser = __esm({
  "node_modules/@aws-sdk/xml-builder/dist-es/xml-parser.browser.js"() {
    "use strict";
  }
});

// node_modules/@aws-sdk/xml-builder/dist-es/index.js
var init_dist_es21 = __esm({
  "node_modules/@aws-sdk/xml-builder/dist-es/index.js"() {
    "use strict";
    init_XmlNode();
    init_XmlText();
    init_xml_parser_browser();
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/protocols/xml/XmlShapeDeserializer.js
var init_XmlShapeDeserializer = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/protocols/xml/XmlShapeDeserializer.js"() {
    "use strict";
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/protocols/query/AwsQueryProtocol.js
var init_AwsQueryProtocol = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/protocols/query/AwsQueryProtocol.js"() {
    "use strict";
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/protocols/query/AwsEc2QueryProtocol.js
var init_AwsEc2QueryProtocol = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/protocols/query/AwsEc2QueryProtocol.js"() {
    "use strict";
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/protocols/xml/parseXmlBody.js
var parseXmlBody, parseXmlErrorBody, loadRestXmlErrorCode;
var init_parseXmlBody = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/protocols/xml/parseXmlBody.js"() {
    "use strict";
    init_dist_es21();
    init_dist_es20();
    init_common();
    parseXmlBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
      if (encoded.length) {
        let parsedObj;
        try {
          parsedObj = parseXML(encoded);
        } catch (e2) {
          if (e2 && typeof e2 === "object") {
            Object.defineProperty(e2, "$responseBodyText", {
              value: encoded
            });
          }
          throw e2;
        }
        const textNodeName = "#text";
        const key = Object.keys(parsedObj)[0];
        const parsedObjToReturn = parsedObj[key];
        if (parsedObjToReturn[textNodeName]) {
          parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
          delete parsedObjToReturn[textNodeName];
        }
        return getValueFromTextNode(parsedObjToReturn);
      }
      return {};
    });
    parseXmlErrorBody = async (errorBody, context) => {
      const value = await parseXmlBody(errorBody, context);
      if (value.Error) {
        value.Error.message = value.Error.message ?? value.Error.Message;
      }
      return value;
    };
    loadRestXmlErrorCode = (output, data) => {
      if (data?.Error?.Code !== void 0) {
        return data.Error.Code;
      }
      if (data?.Code !== void 0) {
        return data.Code;
      }
      if (output.statusCode == 404) {
        return "NotFound";
      }
    };
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/protocols/xml/XmlShapeSerializer.js
var init_XmlShapeSerializer = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/protocols/xml/XmlShapeSerializer.js"() {
    "use strict";
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/protocols/xml/XmlCodec.js
var init_XmlCodec = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/protocols/xml/XmlCodec.js"() {
    "use strict";
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/protocols/xml/AwsRestXmlProtocol.js
var init_AwsRestXmlProtocol = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/protocols/xml/AwsRestXmlProtocol.js"() {
    "use strict";
  }
});

// node_modules/@aws-sdk/core/dist-es/submodules/protocols/index.js
var init_protocols2 = __esm({
  "node_modules/@aws-sdk/core/dist-es/submodules/protocols/index.js"() {
    "use strict";
    init_AwsSmithyRpcV2CborProtocol();
    init_coercing_serializers();
    init_AwsJson1_0Protocol();
    init_AwsJson1_1Protocol();
    init_AwsJsonRpcProtocol();
    init_AwsRestJsonProtocol();
    init_JsonCodec();
    init_JsonShapeDeserializer();
    init_JsonShapeSerializer();
    init_awsExpectUnion();
    init_parseJsonBody();
    init_AwsEc2QueryProtocol();
    init_AwsQueryProtocol();
    init_AwsRestXmlProtocol();
    init_XmlCodec();
    init_XmlShapeDeserializer();
    init_XmlShapeSerializer();
    init_parseXmlBody();
  }
});

// node_modules/@aws-sdk/core/dist-es/index.js
var init_dist_es22 = __esm({
  "node_modules/@aws-sdk/core/dist-es/index.js"() {
    "use strict";
    init_client2();
    init_httpAuthSchemes2();
    init_protocols2();
  }
});

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/types.js
var CLIENT_SUPPORTED_ALGORITHMS, PRIORITY_ORDER_ALGORITHMS;
var init_types2 = __esm({
  "node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/types.js"() {
    "use strict";
    init_constants();
    CLIENT_SUPPORTED_ALGORITHMS = [
      ChecksumAlgorithm.CRC32,
      ChecksumAlgorithm.CRC32C,
      ChecksumAlgorithm.CRC64NVME,
      ChecksumAlgorithm.SHA1,
      ChecksumAlgorithm.SHA256
    ];
    PRIORITY_ORDER_ALGORITHMS = [
      ChecksumAlgorithm.SHA256,
      ChecksumAlgorithm.SHA1,
      ChecksumAlgorithm.CRC32,
      ChecksumAlgorithm.CRC32C,
      ChecksumAlgorithm.CRC64NVME
    ];
  }
});

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getChecksumAlgorithmForRequest.js
var getChecksumAlgorithmForRequest;
var init_getChecksumAlgorithmForRequest = __esm({
  "node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getChecksumAlgorithmForRequest.js"() {
    "use strict";
    init_constants();
    init_types2();
    getChecksumAlgorithmForRequest = (input, { requestChecksumRequired, requestAlgorithmMember, requestChecksumCalculation }) => {
      if (!requestAlgorithmMember) {
        return requestChecksumCalculation === RequestChecksumCalculation.WHEN_SUPPORTED || requestChecksumRequired ? DEFAULT_CHECKSUM_ALGORITHM : void 0;
      }
      if (!input[requestAlgorithmMember]) {
        return void 0;
      }
      const checksumAlgorithm = input[requestAlgorithmMember];
      if (!CLIENT_SUPPORTED_ALGORITHMS.includes(checksumAlgorithm)) {
        throw new Error(`The checksum algorithm "${checksumAlgorithm}" is not supported by the client. Select one of ${CLIENT_SUPPORTED_ALGORITHMS}.`);
      }
      return checksumAlgorithm;
    };
  }
});

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getChecksumLocationName.js
var getChecksumLocationName;
var init_getChecksumLocationName = __esm({
  "node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getChecksumLocationName.js"() {
    "use strict";
    init_constants();
    getChecksumLocationName = (algorithm) => algorithm === ChecksumAlgorithm.MD5 ? "content-md5" : `x-amz-checksum-${algorithm.toLowerCase()}`;
  }
});

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/hasHeader.js
var hasHeader2;
var init_hasHeader = __esm({
  "node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/hasHeader.js"() {
    "use strict";
    hasHeader2 = (header, headers) => {
      const soughtHeader = header.toLowerCase();
      for (const headerName of Object.keys(headers)) {
        if (soughtHeader === headerName.toLowerCase()) {
          return true;
        }
      }
      return false;
    };
  }
});

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/hasHeaderWithPrefix.js
var hasHeaderWithPrefix;
var init_hasHeaderWithPrefix = __esm({
  "node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/hasHeaderWithPrefix.js"() {
    "use strict";
    hasHeaderWithPrefix = (headerPrefix, headers) => {
      const soughtHeaderPrefix = headerPrefix.toLowerCase();
      for (const headerName of Object.keys(headers)) {
        if (headerName.toLowerCase().startsWith(soughtHeaderPrefix)) {
          return true;
        }
      }
      return false;
    };
  }
});

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/isStreaming.js
var isStreaming;
var init_isStreaming = __esm({
  "node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/isStreaming.js"() {
    "use strict";
    init_dist_es16();
    isStreaming = (body) => body !== void 0 && typeof body !== "string" && !ArrayBuffer.isView(body) && !isArrayBuffer(body);
  }
});

// node_modules/tslib/tslib.es6.mjs
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t2[0] & 1) throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2 = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g2.next = verb(0), g2["throw"] = verb(1), g2["return"] = verb(2), typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2) throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_ = 0)), _) try {
      if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done) return t2;
      if (y2 = 0, t2) op = [op[0] & 2, t2.value];
      switch (op[0]) {
        case 0:
        case 1:
          t2 = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y2 = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t2[1]) {
            _.label = t2[1];
            t2 = op;
            break;
          }
          if (t2 && _.label < t2[2]) {
            _.label = t2[2];
            _.ops.push(op);
            break;
          }
          if (t2[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e2) {
      op = [6, e2];
      y2 = 0;
    } finally {
      f2 = t2 = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __values(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
  if (m2) return m2.call(o2);
  if (o2 && typeof o2.length === "number") return {
    next: function() {
      if (o2 && i2 >= o2.length) o2 = void 0;
      return { value: o2 && o2[i2++], done: !o2 };
    }
  };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
var init_tslib_es6 = __esm({
  "node_modules/tslib/tslib.es6.mjs"() {
    "use strict";
  }
});

// node_modules/@aws-crypto/util/node_modules/@smithy/util-utf8/dist-es/fromUtf8.browser.js
var fromUtf82;
var init_fromUtf8_browser2 = __esm({
  "node_modules/@aws-crypto/util/node_modules/@smithy/util-utf8/dist-es/fromUtf8.browser.js"() {
    "use strict";
    fromUtf82 = (input) => new TextEncoder().encode(input);
  }
});

// node_modules/@aws-crypto/util/node_modules/@smithy/util-utf8/dist-es/toUint8Array.js
var init_toUint8Array2 = __esm({
  "node_modules/@aws-crypto/util/node_modules/@smithy/util-utf8/dist-es/toUint8Array.js"() {
    "use strict";
    init_fromUtf8_browser2();
  }
});

// node_modules/@aws-crypto/util/node_modules/@smithy/util-utf8/dist-es/toUtf8.browser.js
var init_toUtf8_browser2 = __esm({
  "node_modules/@aws-crypto/util/node_modules/@smithy/util-utf8/dist-es/toUtf8.browser.js"() {
    "use strict";
  }
});

// node_modules/@aws-crypto/util/node_modules/@smithy/util-utf8/dist-es/index.js
var init_dist_es23 = __esm({
  "node_modules/@aws-crypto/util/node_modules/@smithy/util-utf8/dist-es/index.js"() {
    "use strict";
    init_fromUtf8_browser2();
    init_toUint8Array2();
    init_toUtf8_browser2();
  }
});

// node_modules/@aws-crypto/util/build/module/convertToBuffer.js
function convertToBuffer(data) {
  if (data instanceof Uint8Array)
    return data;
  if (typeof data === "string") {
    return fromUtf83(data);
  }
  if (ArrayBuffer.isView(data)) {
    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
  }
  return new Uint8Array(data);
}
var fromUtf83;
var init_convertToBuffer = __esm({
  "node_modules/@aws-crypto/util/build/module/convertToBuffer.js"() {
    "use strict";
    init_dist_es23();
    fromUtf83 = typeof Buffer !== "undefined" && Buffer.from ? function(input) {
      return Buffer.from(input, "utf8");
    } : fromUtf82;
  }
});

// node_modules/@aws-crypto/util/build/module/isEmptyData.js
function isEmptyData(data) {
  if (typeof data === "string") {
    return data.length === 0;
  }
  return data.byteLength === 0;
}
var init_isEmptyData = __esm({
  "node_modules/@aws-crypto/util/build/module/isEmptyData.js"() {
    "use strict";
  }
});

// node_modules/@aws-crypto/util/build/module/numToUint8.js
function numToUint8(num) {
  return new Uint8Array([
    (num & 4278190080) >> 24,
    (num & 16711680) >> 16,
    (num & 65280) >> 8,
    num & 255
  ]);
}
var init_numToUint8 = __esm({
  "node_modules/@aws-crypto/util/build/module/numToUint8.js"() {
    "use strict";
  }
});

// node_modules/@aws-crypto/util/build/module/uint32ArrayFrom.js
function uint32ArrayFrom(a_lookUpTable2) {
  if (!Uint32Array.from) {
    var return_array = new Uint32Array(a_lookUpTable2.length);
    var a_index = 0;
    while (a_index < a_lookUpTable2.length) {
      return_array[a_index] = a_lookUpTable2[a_index];
      a_index += 1;
    }
    return return_array;
  }
  return Uint32Array.from(a_lookUpTable2);
}
var init_uint32ArrayFrom = __esm({
  "node_modules/@aws-crypto/util/build/module/uint32ArrayFrom.js"() {
    "use strict";
  }
});

// node_modules/@aws-crypto/util/build/module/index.js
var init_module = __esm({
  "node_modules/@aws-crypto/util/build/module/index.js"() {
    "use strict";
    init_convertToBuffer();
    init_isEmptyData();
    init_numToUint8();
    init_uint32ArrayFrom();
  }
});

// node_modules/@aws-crypto/crc32c/build/module/aws_crc32c.js
var AwsCrc32c;
var init_aws_crc32c = __esm({
  "node_modules/@aws-crypto/crc32c/build/module/aws_crc32c.js"() {
    "use strict";
    init_tslib_es6();
    init_module();
    init_module2();
    AwsCrc32c = /** @class */
    function() {
      function AwsCrc32c2() {
        this.crc32c = new Crc32c();
      }
      AwsCrc32c2.prototype.update = function(toHash) {
        if (isEmptyData(toHash))
          return;
        this.crc32c.update(convertToBuffer(toHash));
      };
      AwsCrc32c2.prototype.digest = function() {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a2) {
            return [2, numToUint8(this.crc32c.digest())];
          });
        });
      };
      AwsCrc32c2.prototype.reset = function() {
        this.crc32c = new Crc32c();
      };
      return AwsCrc32c2;
    }();
  }
});

// node_modules/@aws-crypto/crc32c/build/module/index.js
var Crc32c, a_lookupTable, lookupTable;
var init_module2 = __esm({
  "node_modules/@aws-crypto/crc32c/build/module/index.js"() {
    "use strict";
    init_tslib_es6();
    init_module();
    init_aws_crc32c();
    Crc32c = /** @class */
    function() {
      function Crc32c2() {
        this.checksum = 4294967295;
      }
      Crc32c2.prototype.update = function(data) {
        var e_1, _a2;
        try {
          for (var data_1 = __values(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
            var byte = data_1_1.value;
            this.checksum = this.checksum >>> 8 ^ lookupTable[(this.checksum ^ byte) & 255];
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (data_1_1 && !data_1_1.done && (_a2 = data_1.return)) _a2.call(data_1);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        return this;
      };
      Crc32c2.prototype.digest = function() {
        return (this.checksum ^ 4294967295) >>> 0;
      };
      return Crc32c2;
    }();
    a_lookupTable = [
      0,
      4067132163,
      3778769143,
      324072436,
      3348797215,
      904991772,
      648144872,
      3570033899,
      2329499855,
      2024987596,
      1809983544,
      2575936315,
      1296289744,
      3207089363,
      2893594407,
      1578318884,
      274646895,
      3795141740,
      4049975192,
      51262619,
      3619967088,
      632279923,
      922689671,
      3298075524,
      2592579488,
      1760304291,
      2075979607,
      2312596564,
      1562183871,
      2943781820,
      3156637768,
      1313733451,
      549293790,
      3537243613,
      3246849577,
      871202090,
      3878099393,
      357341890,
      102525238,
      4101499445,
      2858735121,
      1477399826,
      1264559846,
      3107202533,
      1845379342,
      2677391885,
      2361733625,
      2125378298,
      820201905,
      3263744690,
      3520608582,
      598981189,
      4151959214,
      85089709,
      373468761,
      3827903834,
      3124367742,
      1213305469,
      1526817161,
      2842354314,
      2107672161,
      2412447074,
      2627466902,
      1861252501,
      1098587580,
      3004210879,
      2688576843,
      1378610760,
      2262928035,
      1955203488,
      1742404180,
      2511436119,
      3416409459,
      969524848,
      714683780,
      3639785095,
      205050476,
      4266873199,
      3976438427,
      526918040,
      1361435347,
      2739821008,
      2954799652,
      1114974503,
      2529119692,
      1691668175,
      2005155131,
      2247081528,
      3690758684,
      697762079,
      986182379,
      3366744552,
      476452099,
      3993867776,
      4250756596,
      255256311,
      1640403810,
      2477592673,
      2164122517,
      1922457750,
      2791048317,
      1412925310,
      1197962378,
      3037525897,
      3944729517,
      427051182,
      170179418,
      4165941337,
      746937522,
      3740196785,
      3451792453,
      1070968646,
      1905808397,
      2213795598,
      2426610938,
      1657317369,
      3053634322,
      1147748369,
      1463399397,
      2773627110,
      4215344322,
      153784257,
      444234805,
      3893493558,
      1021025245,
      3467647198,
      3722505002,
      797665321,
      2197175160,
      1889384571,
      1674398607,
      2443626636,
      1164749927,
      3070701412,
      2757221520,
      1446797203,
      137323447,
      4198817972,
      3910406976,
      461344835,
      3484808360,
      1037989803,
      781091935,
      3705997148,
      2460548119,
      1623424788,
      1939049696,
      2180517859,
      1429367560,
      2807687179,
      3020495871,
      1180866812,
      410100952,
      3927582683,
      4182430767,
      186734380,
      3756733383,
      763408580,
      1053836080,
      3434856499,
      2722870694,
      1344288421,
      1131464017,
      2971354706,
      1708204729,
      2545590714,
      2229949006,
      1988219213,
      680717673,
      3673779818,
      3383336350,
      1002577565,
      4010310262,
      493091189,
      238226049,
      4233660802,
      2987750089,
      1082061258,
      1395524158,
      2705686845,
      1972364758,
      2279892693,
      2494862625,
      1725896226,
      952904198,
      3399985413,
      3656866545,
      731699698,
      4283874585,
      222117402,
      510512622,
      3959836397,
      3280807620,
      837199303,
      582374963,
      3504198960,
      68661723,
      4135334616,
      3844915500,
      390545967,
      1230274059,
      3141532936,
      2825850620,
      1510247935,
      2395924756,
      2091215383,
      1878366691,
      2644384480,
      3553878443,
      565732008,
      854102364,
      3229815391,
      340358836,
      3861050807,
      4117890627,
      119113024,
      1493875044,
      2875275879,
      3090270611,
      1247431312,
      2660249211,
      1828433272,
      2141937292,
      2378227087,
      3811616794,
      291187481,
      34330861,
      4032846830,
      615137029,
      3603020806,
      3314634738,
      939183345,
      1776939221,
      2609017814,
      2295496738,
      2058945313,
      2926798794,
      1545135305,
      1330124605,
      3173225534,
      4084100981,
      17165430,
      307568514,
      3762199681,
      888469610,
      3332340585,
      3587147933,
      665062302,
      2042050490,
      2346497209,
      2559330125,
      1793573966,
      3190661285,
      1279665062,
      1595330642,
      2910671697
    ];
    lookupTable = uint32ArrayFrom(a_lookupTable);
  }
});

// node_modules/@aws-crypto/crc32/build/module/aws_crc32.js
var AwsCrc32;
var init_aws_crc32 = __esm({
  "node_modules/@aws-crypto/crc32/build/module/aws_crc32.js"() {
    "use strict";
    init_tslib_es6();
    init_module();
    init_module3();
    AwsCrc32 = /** @class */
    function() {
      function AwsCrc322() {
        this.crc32 = new Crc32();
      }
      AwsCrc322.prototype.update = function(toHash) {
        if (isEmptyData(toHash))
          return;
        this.crc32.update(convertToBuffer(toHash));
      };
      AwsCrc322.prototype.digest = function() {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a2) {
            return [2, numToUint8(this.crc32.digest())];
          });
        });
      };
      AwsCrc322.prototype.reset = function() {
        this.crc32 = new Crc32();
      };
      return AwsCrc322;
    }();
  }
});

// node_modules/@aws-crypto/crc32/build/module/index.js
var Crc32, a_lookUpTable, lookupTable2;
var init_module3 = __esm({
  "node_modules/@aws-crypto/crc32/build/module/index.js"() {
    "use strict";
    init_tslib_es6();
    init_module();
    init_aws_crc32();
    Crc32 = /** @class */
    function() {
      function Crc322() {
        this.checksum = 4294967295;
      }
      Crc322.prototype.update = function(data) {
        var e_1, _a2;
        try {
          for (var data_1 = __values(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
            var byte = data_1_1.value;
            this.checksum = this.checksum >>> 8 ^ lookupTable2[(this.checksum ^ byte) & 255];
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (data_1_1 && !data_1_1.done && (_a2 = data_1.return)) _a2.call(data_1);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        return this;
      };
      Crc322.prototype.digest = function() {
        return (this.checksum ^ 4294967295) >>> 0;
      };
      return Crc322;
    }();
    a_lookUpTable = [
      0,
      1996959894,
      3993919788,
      2567524794,
      124634137,
      1886057615,
      3915621685,
      2657392035,
      249268274,
      2044508324,
      3772115230,
      2547177864,
      162941995,
      2125561021,
      3887607047,
      2428444049,
      498536548,
      1789927666,
      4089016648,
      2227061214,
      450548861,
      1843258603,
      4107580753,
      2211677639,
      325883990,
      1684777152,
      4251122042,
      2321926636,
      335633487,
      1661365465,
      4195302755,
      2366115317,
      997073096,
      1281953886,
      3579855332,
      2724688242,
      1006888145,
      1258607687,
      3524101629,
      2768942443,
      901097722,
      1119000684,
      3686517206,
      2898065728,
      853044451,
      1172266101,
      3705015759,
      2882616665,
      651767980,
      1373503546,
      3369554304,
      3218104598,
      565507253,
      1454621731,
      3485111705,
      3099436303,
      671266974,
      1594198024,
      3322730930,
      2970347812,
      795835527,
      1483230225,
      3244367275,
      3060149565,
      1994146192,
      31158534,
      2563907772,
      4023717930,
      1907459465,
      112637215,
      2680153253,
      3904427059,
      2013776290,
      251722036,
      2517215374,
      3775830040,
      2137656763,
      141376813,
      2439277719,
      3865271297,
      1802195444,
      476864866,
      2238001368,
      4066508878,
      1812370925,
      453092731,
      2181625025,
      4111451223,
      1706088902,
      314042704,
      2344532202,
      4240017532,
      1658658271,
      366619977,
      2362670323,
      4224994405,
      1303535960,
      984961486,
      2747007092,
      3569037538,
      1256170817,
      1037604311,
      2765210733,
      3554079995,
      1131014506,
      879679996,
      2909243462,
      3663771856,
      1141124467,
      855842277,
      2852801631,
      3708648649,
      1342533948,
      654459306,
      3188396048,
      3373015174,
      1466479909,
      544179635,
      3110523913,
      3462522015,
      1591671054,
      702138776,
      2966460450,
      3352799412,
      1504918807,
      783551873,
      3082640443,
      3233442989,
      3988292384,
      2596254646,
      62317068,
      1957810842,
      3939845945,
      2647816111,
      81470997,
      1943803523,
      3814918930,
      2489596804,
      225274430,
      2053790376,
      3826175755,
      2466906013,
      167816743,
      2097651377,
      4027552580,
      2265490386,
      503444072,
      1762050814,
      4150417245,
      2154129355,
      426522225,
      1852507879,
      4275313526,
      2312317920,
      282753626,
      1742555852,
      4189708143,
      2394877945,
      397917763,
      1622183637,
      3604390888,
      2714866558,
      953729732,
      1340076626,
      3518719985,
      2797360999,
      1068828381,
      1219638859,
      3624741850,
      2936675148,
      906185462,
      1090812512,
      3747672003,
      2825379669,
      829329135,
      1181335161,
      3412177804,
      3160834842,
      628085408,
      1382605366,
      3423369109,
      3138078467,
      570562233,
      1426400815,
      3317316542,
      2998733608,
      733239954,
      1555261956,
      3268935591,
      3050360625,
      752459403,
      1541320221,
      2607071920,
      3965973030,
      1969922972,
      40735498,
      2617837225,
      3943577151,
      1913087877,
      83908371,
      2512341634,
      3803740692,
      2075208622,
      213261112,
      2463272603,
      3855990285,
      2094854071,
      198958881,
      2262029012,
      4057260610,
      1759359992,
      534414190,
      2176718541,
      4139329115,
      1873836001,
      414664567,
      2282248934,
      4279200368,
      1711684554,
      285281116,
      2405801727,
      4167216745,
      1634467795,
      376229701,
      2685067896,
      3608007406,
      1308918612,
      956543938,
      2808555105,
      3495958263,
      1231636301,
      1047427035,
      2932959818,
      3654703836,
      1088359270,
      936918e3,
      2847714899,
      3736837829,
      1202900863,
      817233897,
      3183342108,
      3401237130,
      1404277552,
      615818150,
      3134207493,
      3453421203,
      1423857449,
      601450431,
      3009837614,
      3294710456,
      1567103746,
      711928724,
      3020668471,
      3272380065,
      1510334235,
      755167117
    ];
    lookupTable2 = uint32ArrayFrom(a_lookUpTable);
  }
});

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getCrc32ChecksumAlgorithmFunction.browser.js
var getCrc32ChecksumAlgorithmFunction;
var init_getCrc32ChecksumAlgorithmFunction_browser = __esm({
  "node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getCrc32ChecksumAlgorithmFunction.browser.js"() {
    "use strict";
    init_module3();
    getCrc32ChecksumAlgorithmFunction = () => AwsCrc32;
  }
});

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/selectChecksumAlgorithmFunction.js
var selectChecksumAlgorithmFunction;
var init_selectChecksumAlgorithmFunction = __esm({
  "node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/selectChecksumAlgorithmFunction.js"() {
    "use strict";
    init_module2();
    init_constants();
    init_crc64_nvme_crt_container();
    init_getCrc32ChecksumAlgorithmFunction_browser();
    selectChecksumAlgorithmFunction = (checksumAlgorithm, config) => {
      switch (checksumAlgorithm) {
        case ChecksumAlgorithm.MD5:
          return config.md5;
        case ChecksumAlgorithm.CRC32:
          return getCrc32ChecksumAlgorithmFunction();
        case ChecksumAlgorithm.CRC32C:
          return AwsCrc32c;
        case ChecksumAlgorithm.CRC64NVME:
          if (typeof crc64NvmeCrtContainer.CrtCrc64Nvme !== "function") {
            throw new Error(`Please check whether you have installed the "@aws-sdk/crc64-nvme-crt" package explicitly. 
You must also register the package by calling [require("@aws-sdk/crc64-nvme-crt");] or an ESM equivalent such as [import "@aws-sdk/crc64-nvme-crt";]. 
For more information please go to https://github.com/aws/aws-sdk-js-v3#functionality-requiring-aws-common-runtime-crt`);
          }
          return crc64NvmeCrtContainer.CrtCrc64Nvme;
        case ChecksumAlgorithm.SHA1:
          return config.sha1;
        case ChecksumAlgorithm.SHA256:
          return config.sha256;
        default:
          throw new Error(`Unsupported checksum algorithm: ${checksumAlgorithm}`);
      }
    };
  }
});

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/stringHasher.js
var stringHasher;
var init_stringHasher = __esm({
  "node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/stringHasher.js"() {
    "use strict";
    init_dist_es6();
    stringHasher = (checksumAlgorithmFn, body) => {
      const hash = new checksumAlgorithmFn();
      hash.update(toUint8Array(body || ""));
      return hash.digest();
    };
  }
});

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/flexibleChecksumsMiddleware.js
var flexibleChecksumsMiddlewareOptions, flexibleChecksumsMiddleware;
var init_flexibleChecksumsMiddleware = __esm({
  "node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/flexibleChecksumsMiddleware.js"() {
    "use strict";
    init_dist_es22();
    init_dist_es2();
    init_dist_es12();
    init_constants();
    init_getChecksumAlgorithmForRequest();
    init_getChecksumLocationName();
    init_hasHeader();
    init_hasHeaderWithPrefix();
    init_isStreaming();
    init_selectChecksumAlgorithmFunction();
    init_stringHasher();
    flexibleChecksumsMiddlewareOptions = {
      name: "flexibleChecksumsMiddleware",
      step: "build",
      tags: ["BODY_CHECKSUM"],
      override: true
    };
    flexibleChecksumsMiddleware = (config, middlewareConfig) => (next, context) => async (args) => {
      if (!HttpRequest.isInstance(args.request)) {
        return next(args);
      }
      if (hasHeaderWithPrefix("x-amz-checksum-", args.request.headers)) {
        return next(args);
      }
      const { request, input } = args;
      const { body: requestBody, headers } = request;
      const { base64Encoder, streamHasher } = config;
      const { requestChecksumRequired, requestAlgorithmMember } = middlewareConfig;
      const requestChecksumCalculation = await config.requestChecksumCalculation();
      const requestAlgorithmMemberName = requestAlgorithmMember?.name;
      const requestAlgorithmMemberHttpHeader = requestAlgorithmMember?.httpHeader;
      if (requestAlgorithmMemberName && !input[requestAlgorithmMemberName]) {
        if (requestChecksumCalculation === RequestChecksumCalculation.WHEN_SUPPORTED || requestChecksumRequired) {
          input[requestAlgorithmMemberName] = DEFAULT_CHECKSUM_ALGORITHM;
          if (requestAlgorithmMemberHttpHeader) {
            headers[requestAlgorithmMemberHttpHeader] = DEFAULT_CHECKSUM_ALGORITHM;
          }
        }
      }
      const checksumAlgorithm = getChecksumAlgorithmForRequest(input, {
        requestChecksumRequired,
        requestAlgorithmMember: requestAlgorithmMember?.name,
        requestChecksumCalculation
      });
      let updatedBody = requestBody;
      let updatedHeaders = headers;
      if (checksumAlgorithm) {
        switch (checksumAlgorithm) {
          case ChecksumAlgorithm.CRC32:
            setFeature(context, "FLEXIBLE_CHECKSUMS_REQ_CRC32", "U");
            break;
          case ChecksumAlgorithm.CRC32C:
            setFeature(context, "FLEXIBLE_CHECKSUMS_REQ_CRC32C", "V");
            break;
          case ChecksumAlgorithm.CRC64NVME:
            setFeature(context, "FLEXIBLE_CHECKSUMS_REQ_CRC64", "W");
            break;
          case ChecksumAlgorithm.SHA1:
            setFeature(context, "FLEXIBLE_CHECKSUMS_REQ_SHA1", "X");
            break;
          case ChecksumAlgorithm.SHA256:
            setFeature(context, "FLEXIBLE_CHECKSUMS_REQ_SHA256", "Y");
            break;
        }
        const checksumLocationName = getChecksumLocationName(checksumAlgorithm);
        const checksumAlgorithmFn = selectChecksumAlgorithmFunction(checksumAlgorithm, config);
        if (isStreaming(requestBody)) {
          const { getAwsChunkedEncodingStream: getAwsChunkedEncodingStream2, bodyLengthChecker } = config;
          updatedBody = getAwsChunkedEncodingStream2(typeof config.requestStreamBufferSize === "number" && config.requestStreamBufferSize >= 8 * 1024 ? createBufferedReadable(requestBody, config.requestStreamBufferSize, context.logger) : requestBody, {
            base64Encoder,
            bodyLengthChecker,
            checksumLocationName,
            checksumAlgorithmFn,
            streamHasher
          });
          updatedHeaders = {
            ...headers,
            "content-encoding": headers["content-encoding"] ? `${headers["content-encoding"]},aws-chunked` : "aws-chunked",
            "transfer-encoding": "chunked",
            "x-amz-decoded-content-length": headers["content-length"],
            "x-amz-content-sha256": "STREAMING-UNSIGNED-PAYLOAD-TRAILER",
            "x-amz-trailer": checksumLocationName
          };
          delete updatedHeaders["content-length"];
        } else if (!hasHeader2(checksumLocationName, headers)) {
          const rawChecksum = await stringHasher(checksumAlgorithmFn, requestBody);
          updatedHeaders = {
            ...headers,
            [checksumLocationName]: base64Encoder(rawChecksum)
          };
        }
      }
      const result = await next({
        ...args,
        request: {
          ...request,
          headers: updatedHeaders,
          body: updatedBody
        }
      });
      return result;
    };
  }
});

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/flexibleChecksumsInputMiddleware.js
var flexibleChecksumsInputMiddlewareOptions, flexibleChecksumsInputMiddleware;
var init_flexibleChecksumsInputMiddleware = __esm({
  "node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/flexibleChecksumsInputMiddleware.js"() {
    "use strict";
    init_dist_es22();
    init_constants();
    flexibleChecksumsInputMiddlewareOptions = {
      name: "flexibleChecksumsInputMiddleware",
      toMiddleware: "serializerMiddleware",
      relation: "before",
      tags: ["BODY_CHECKSUM"],
      override: true
    };
    flexibleChecksumsInputMiddleware = (config, middlewareConfig) => (next, context) => async (args) => {
      const input = args.input;
      const { requestValidationModeMember } = middlewareConfig;
      const requestChecksumCalculation = await config.requestChecksumCalculation();
      const responseChecksumValidation = await config.responseChecksumValidation();
      switch (requestChecksumCalculation) {
        case RequestChecksumCalculation.WHEN_REQUIRED:
          setFeature(context, "FLEXIBLE_CHECKSUMS_REQ_WHEN_REQUIRED", "a");
          break;
        case RequestChecksumCalculation.WHEN_SUPPORTED:
          setFeature(context, "FLEXIBLE_CHECKSUMS_REQ_WHEN_SUPPORTED", "Z");
          break;
      }
      switch (responseChecksumValidation) {
        case ResponseChecksumValidation.WHEN_REQUIRED:
          setFeature(context, "FLEXIBLE_CHECKSUMS_RES_WHEN_REQUIRED", "c");
          break;
        case ResponseChecksumValidation.WHEN_SUPPORTED:
          setFeature(context, "FLEXIBLE_CHECKSUMS_RES_WHEN_SUPPORTED", "b");
          break;
      }
      if (requestValidationModeMember && !input[requestValidationModeMember]) {
        if (responseChecksumValidation === ResponseChecksumValidation.WHEN_SUPPORTED) {
          input[requestValidationModeMember] = "ENABLED";
        }
      }
      return next(args);
    };
  }
});

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getChecksumAlgorithmListForResponse.js
var getChecksumAlgorithmListForResponse;
var init_getChecksumAlgorithmListForResponse = __esm({
  "node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getChecksumAlgorithmListForResponse.js"() {
    "use strict";
    init_types2();
    getChecksumAlgorithmListForResponse = (responseAlgorithms = []) => {
      const validChecksumAlgorithms = [];
      for (const algorithm of PRIORITY_ORDER_ALGORITHMS) {
        if (!responseAlgorithms.includes(algorithm) || !CLIENT_SUPPORTED_ALGORITHMS.includes(algorithm)) {
          continue;
        }
        validChecksumAlgorithms.push(algorithm);
      }
      return validChecksumAlgorithms;
    };
  }
});

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/isChecksumWithPartNumber.js
var isChecksumWithPartNumber;
var init_isChecksumWithPartNumber = __esm({
  "node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/isChecksumWithPartNumber.js"() {
    "use strict";
    isChecksumWithPartNumber = (checksum) => {
      const lastHyphenIndex = checksum.lastIndexOf("-");
      if (lastHyphenIndex !== -1) {
        const numberPart = checksum.slice(lastHyphenIndex + 1);
        if (!numberPart.startsWith("0")) {
          const number = parseInt(numberPart, 10);
          if (!isNaN(number) && number >= 1 && number <= 1e4) {
            return true;
          }
        }
      }
      return false;
    };
  }
});

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getChecksum.js
var getChecksum;
var init_getChecksum = __esm({
  "node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getChecksum.js"() {
    "use strict";
    init_stringHasher();
    getChecksum = async (body, { checksumAlgorithmFn, base64Encoder }) => base64Encoder(await stringHasher(checksumAlgorithmFn, body));
  }
});

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/validateChecksumFromResponse.js
var validateChecksumFromResponse;
var init_validateChecksumFromResponse = __esm({
  "node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/validateChecksumFromResponse.js"() {
    "use strict";
    init_dist_es12();
    init_constants();
    init_getChecksum();
    init_getChecksumAlgorithmListForResponse();
    init_getChecksumLocationName();
    init_isStreaming();
    init_selectChecksumAlgorithmFunction();
    validateChecksumFromResponse = async (response, { config, responseAlgorithms, logger: logger2 }) => {
      const checksumAlgorithms = getChecksumAlgorithmListForResponse(responseAlgorithms);
      const { body: responseBody, headers: responseHeaders } = response;
      for (const algorithm of checksumAlgorithms) {
        const responseHeader = getChecksumLocationName(algorithm);
        const checksumFromResponse = responseHeaders[responseHeader];
        if (checksumFromResponse) {
          let checksumAlgorithmFn;
          try {
            checksumAlgorithmFn = selectChecksumAlgorithmFunction(algorithm, config);
          } catch (error) {
            if (algorithm === ChecksumAlgorithm.CRC64NVME) {
              logger2?.warn(`Skipping ${ChecksumAlgorithm.CRC64NVME} checksum validation: ${error.message}`);
              continue;
            }
            throw error;
          }
          const { base64Encoder } = config;
          if (isStreaming(responseBody)) {
            response.body = createChecksumStream({
              expectedChecksum: checksumFromResponse,
              checksumSourceLocation: responseHeader,
              checksum: new checksumAlgorithmFn(),
              source: responseBody,
              base64Encoder
            });
            return;
          }
          const checksum = await getChecksum(responseBody, { checksumAlgorithmFn, base64Encoder });
          if (checksum === checksumFromResponse) {
            break;
          }
          throw new Error(`Checksum mismatch: expected "${checksum}" but received "${checksumFromResponse}" in response header "${responseHeader}".`);
        }
      }
    };
  }
});

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/flexibleChecksumsResponseMiddleware.js
var flexibleChecksumsResponseMiddlewareOptions, flexibleChecksumsResponseMiddleware;
var init_flexibleChecksumsResponseMiddleware = __esm({
  "node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/flexibleChecksumsResponseMiddleware.js"() {
    "use strict";
    init_dist_es2();
    init_getChecksumAlgorithmListForResponse();
    init_getChecksumLocationName();
    init_isChecksumWithPartNumber();
    init_validateChecksumFromResponse();
    flexibleChecksumsResponseMiddlewareOptions = {
      name: "flexibleChecksumsResponseMiddleware",
      toMiddleware: "deserializerMiddleware",
      relation: "after",
      tags: ["BODY_CHECKSUM"],
      override: true
    };
    flexibleChecksumsResponseMiddleware = (config, middlewareConfig) => (next, context) => async (args) => {
      if (!HttpRequest.isInstance(args.request)) {
        return next(args);
      }
      const input = args.input;
      const result = await next(args);
      const response = result.response;
      const { requestValidationModeMember, responseAlgorithms } = middlewareConfig;
      if (requestValidationModeMember && input[requestValidationModeMember] === "ENABLED") {
        const { clientName, commandName } = context;
        const isS3WholeObjectMultipartGetResponseChecksum = clientName === "S3Client" && commandName === "GetObjectCommand" && getChecksumAlgorithmListForResponse(responseAlgorithms).every((algorithm) => {
          const responseHeader = getChecksumLocationName(algorithm);
          const checksumFromResponse = response.headers[responseHeader];
          return !checksumFromResponse || isChecksumWithPartNumber(checksumFromResponse);
        });
        if (isS3WholeObjectMultipartGetResponseChecksum) {
          return result;
        }
        await validateChecksumFromResponse(response, {
          config,
          responseAlgorithms,
          logger: context.logger
        });
      }
      return result;
    };
  }
});

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getFlexibleChecksumsPlugin.js
var getFlexibleChecksumsPlugin;
var init_getFlexibleChecksumsPlugin = __esm({
  "node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getFlexibleChecksumsPlugin.js"() {
    "use strict";
    init_flexibleChecksumsInputMiddleware();
    init_flexibleChecksumsMiddleware();
    init_flexibleChecksumsResponseMiddleware();
    getFlexibleChecksumsPlugin = (config, middlewareConfig) => ({
      applyToStack: (clientStack) => {
        clientStack.add(flexibleChecksumsMiddleware(config, middlewareConfig), flexibleChecksumsMiddlewareOptions);
        clientStack.addRelativeTo(flexibleChecksumsInputMiddleware(config, middlewareConfig), flexibleChecksumsInputMiddlewareOptions);
        clientStack.addRelativeTo(flexibleChecksumsResponseMiddleware(config, middlewareConfig), flexibleChecksumsResponseMiddlewareOptions);
      }
    });
  }
});

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/resolveFlexibleChecksumsConfig.js
var resolveFlexibleChecksumsConfig;
var init_resolveFlexibleChecksumsConfig = __esm({
  "node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/resolveFlexibleChecksumsConfig.js"() {
    "use strict";
    init_dist_es4();
    init_constants();
    resolveFlexibleChecksumsConfig = (input) => {
      const { requestChecksumCalculation, responseChecksumValidation, requestStreamBufferSize } = input;
      return Object.assign(input, {
        requestChecksumCalculation: normalizeProvider(requestChecksumCalculation ?? DEFAULT_REQUEST_CHECKSUM_CALCULATION),
        responseChecksumValidation: normalizeProvider(responseChecksumValidation ?? DEFAULT_RESPONSE_CHECKSUM_VALIDATION),
        requestStreamBufferSize: Number(requestStreamBufferSize ?? 0)
      });
    };
  }
});

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/index.js
var init_dist_es24 = __esm({
  "node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/index.js"() {
    "use strict";
    init_NODE_REQUEST_CHECKSUM_CALCULATION_CONFIG_OPTIONS();
    init_NODE_RESPONSE_CHECKSUM_VALIDATION_CONFIG_OPTIONS();
    init_constants();
    init_crc64_nvme_crt_container();
    init_flexibleChecksumsMiddleware();
    init_getFlexibleChecksumsPlugin();
    init_resolveFlexibleChecksumsConfig();
  }
});

// node_modules/@aws-sdk/middleware-host-header/dist-es/index.js
function resolveHostHeaderConfig(input) {
  return input;
}
var hostHeaderMiddleware, hostHeaderMiddlewareOptions, getHostHeaderPlugin;
var init_dist_es25 = __esm({
  "node_modules/@aws-sdk/middleware-host-header/dist-es/index.js"() {
    "use strict";
    init_dist_es2();
    hostHeaderMiddleware = (options) => (next) => async (args) => {
      if (!HttpRequest.isInstance(args.request))
        return next(args);
      const { request } = args;
      const { handlerProtocol = "" } = options.requestHandler.metadata || {};
      if (handlerProtocol.indexOf("h2") >= 0 && !request.headers[":authority"]) {
        delete request.headers["host"];
        request.headers[":authority"] = request.hostname + (request.port ? ":" + request.port : "");
      } else if (!request.headers["host"]) {
        let host = request.hostname;
        if (request.port != null)
          host += `:${request.port}`;
        request.headers["host"] = host;
      }
      return next(args);
    };
    hostHeaderMiddlewareOptions = {
      name: "hostHeaderMiddleware",
      step: "build",
      priority: "low",
      tags: ["HOST"],
      override: true
    };
    getHostHeaderPlugin = (options) => ({
      applyToStack: (clientStack) => {
        clientStack.add(hostHeaderMiddleware(options), hostHeaderMiddlewareOptions);
      }
    });
  }
});

// node_modules/@aws-sdk/middleware-logger/dist-es/loggerMiddleware.js
var loggerMiddleware, loggerMiddlewareOptions, getLoggerPlugin;
var init_loggerMiddleware = __esm({
  "node_modules/@aws-sdk/middleware-logger/dist-es/loggerMiddleware.js"() {
    "use strict";
    loggerMiddleware = () => (next, context) => async (args) => {
      try {
        const response = await next(args);
        const { clientName, commandName, logger: logger2, dynamoDbDocumentClientOptions = {} } = context;
        const { overrideInputFilterSensitiveLog, overrideOutputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
        const inputFilterSensitiveLog = overrideInputFilterSensitiveLog ?? context.inputFilterSensitiveLog;
        const outputFilterSensitiveLog = overrideOutputFilterSensitiveLog ?? context.outputFilterSensitiveLog;
        const { $metadata, ...outputWithoutMetadata } = response.output;
        logger2?.info?.({
          clientName,
          commandName,
          input: inputFilterSensitiveLog(args.input),
          output: outputFilterSensitiveLog(outputWithoutMetadata),
          metadata: $metadata
        });
        return response;
      } catch (error) {
        const { clientName, commandName, logger: logger2, dynamoDbDocumentClientOptions = {} } = context;
        const { overrideInputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
        const inputFilterSensitiveLog = overrideInputFilterSensitiveLog ?? context.inputFilterSensitiveLog;
        logger2?.error?.({
          clientName,
          commandName,
          input: inputFilterSensitiveLog(args.input),
          error,
          metadata: error.$metadata
        });
        throw error;
      }
    };
    loggerMiddlewareOptions = {
      name: "loggerMiddleware",
      tags: ["LOGGER"],
      step: "initialize",
      override: true
    };
    getLoggerPlugin = (options) => ({
      applyToStack: (clientStack) => {
        clientStack.add(loggerMiddleware(), loggerMiddlewareOptions);
      }
    });
  }
});

// node_modules/@aws-sdk/middleware-logger/dist-es/index.js
var init_dist_es26 = __esm({
  "node_modules/@aws-sdk/middleware-logger/dist-es/index.js"() {
    "use strict";
    init_loggerMiddleware();
  }
});

// node_modules/@aws-sdk/middleware-recursion-detection/dist-es/configuration.js
var recursionDetectionMiddlewareOptions;
var init_configuration = __esm({
  "node_modules/@aws-sdk/middleware-recursion-detection/dist-es/configuration.js"() {
    "use strict";
    recursionDetectionMiddlewareOptions = {
      step: "build",
      tags: ["RECURSION_DETECTION"],
      name: "recursionDetectionMiddleware",
      override: true,
      priority: "low"
    };
  }
});

// node_modules/@aws-sdk/middleware-recursion-detection/dist-es/recursionDetectionMiddleware.browser.js
var recursionDetectionMiddleware;
var init_recursionDetectionMiddleware_browser = __esm({
  "node_modules/@aws-sdk/middleware-recursion-detection/dist-es/recursionDetectionMiddleware.browser.js"() {
    "use strict";
    recursionDetectionMiddleware = () => (next) => async (args) => next(args);
  }
});

// node_modules/@aws-sdk/middleware-recursion-detection/dist-es/getRecursionDetectionPlugin.js
var getRecursionDetectionPlugin;
var init_getRecursionDetectionPlugin = __esm({
  "node_modules/@aws-sdk/middleware-recursion-detection/dist-es/getRecursionDetectionPlugin.js"() {
    "use strict";
    init_configuration();
    init_recursionDetectionMiddleware_browser();
    getRecursionDetectionPlugin = (options) => ({
      applyToStack: (clientStack) => {
        clientStack.add(recursionDetectionMiddleware(), recursionDetectionMiddlewareOptions);
      }
    });
  }
});

// node_modules/@aws-sdk/middleware-recursion-detection/dist-es/index.js
var init_dist_es27 = __esm({
  "node_modules/@aws-sdk/middleware-recursion-detection/dist-es/index.js"() {
    "use strict";
    init_getRecursionDetectionPlugin();
    init_recursionDetectionMiddleware_browser();
  }
});

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/check-content-length-header.js
function checkContentLengthHeader() {
  return (next, context) => async (args) => {
    const { request } = args;
    if (HttpRequest.isInstance(request)) {
      if (!(CONTENT_LENGTH_HEADER in request.headers) && !(DECODED_CONTENT_LENGTH_HEADER in request.headers)) {
        const message = `Are you using a Stream of unknown length as the Body of a PutObject request? Consider using Upload instead from @aws-sdk/lib-storage.`;
        if (typeof context?.logger?.warn === "function" && !(context.logger instanceof NoOpLogger)) {
          context.logger.warn(message);
        } else {
          console.warn(message);
        }
      }
    }
    return next({ ...args });
  };
}
var CONTENT_LENGTH_HEADER, DECODED_CONTENT_LENGTH_HEADER, checkContentLengthHeaderMiddlewareOptions, getCheckContentLengthHeaderPlugin;
var init_check_content_length_header = __esm({
  "node_modules/@aws-sdk/middleware-sdk-s3/dist-es/check-content-length-header.js"() {
    "use strict";
    init_dist_es2();
    init_dist_es20();
    CONTENT_LENGTH_HEADER = "content-length";
    DECODED_CONTENT_LENGTH_HEADER = "x-amz-decoded-content-length";
    checkContentLengthHeaderMiddlewareOptions = {
      step: "finalizeRequest",
      tags: ["CHECK_CONTENT_LENGTH_HEADER"],
      name: "getCheckContentLengthHeaderPlugin",
      override: true
    };
    getCheckContentLengthHeaderPlugin = (unused) => ({
      applyToStack: (clientStack) => {
        clientStack.add(checkContentLengthHeader(), checkContentLengthHeaderMiddlewareOptions);
      }
    });
  }
});

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/region-redirect-endpoint-middleware.js
var regionRedirectEndpointMiddleware, regionRedirectEndpointMiddlewareOptions;
var init_region_redirect_endpoint_middleware = __esm({
  "node_modules/@aws-sdk/middleware-sdk-s3/dist-es/region-redirect-endpoint-middleware.js"() {
    "use strict";
    regionRedirectEndpointMiddleware = (config) => {
      return (next, context) => async (args) => {
        const originalRegion = await config.region();
        const regionProviderRef = config.region;
        let unlock = () => {
        };
        if (context.__s3RegionRedirect) {
          Object.defineProperty(config, "region", {
            writable: false,
            value: async () => {
              return context.__s3RegionRedirect;
            }
          });
          unlock = () => Object.defineProperty(config, "region", {
            writable: true,
            value: regionProviderRef
          });
        }
        try {
          const result = await next(args);
          if (context.__s3RegionRedirect) {
            unlock();
            const region = await config.region();
            if (originalRegion !== region) {
              throw new Error("Region was not restored following S3 region redirect.");
            }
          }
          return result;
        } catch (e2) {
          unlock();
          throw e2;
        }
      };
    };
    regionRedirectEndpointMiddlewareOptions = {
      tags: ["REGION_REDIRECT", "S3"],
      name: "regionRedirectEndpointMiddleware",
      override: true,
      relation: "before",
      toMiddleware: "endpointV2Middleware"
    };
  }
});

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/region-redirect-middleware.js
function regionRedirectMiddleware(clientConfig) {
  return (next, context) => async (args) => {
    try {
      return await next(args);
    } catch (err) {
      if (clientConfig.followRegionRedirects) {
        const statusCode = err?.$metadata?.httpStatusCode;
        const isHeadBucket = context.commandName === "HeadBucketCommand";
        const bucketRegionHeader = err?.$response?.headers?.["x-amz-bucket-region"];
        if (bucketRegionHeader) {
          if (statusCode === 301 || statusCode === 400 && (err?.name === "IllegalLocationConstraintException" || isHeadBucket)) {
            try {
              const actualRegion = bucketRegionHeader;
              context.logger?.debug(`Redirecting from ${await clientConfig.region()} to ${actualRegion}`);
              context.__s3RegionRedirect = actualRegion;
            } catch (e2) {
              throw new Error("Region redirect failed: " + e2);
            }
            return next(args);
          }
        }
      }
      throw err;
    }
  };
}
var regionRedirectMiddlewareOptions, getRegionRedirectMiddlewarePlugin;
var init_region_redirect_middleware = __esm({
  "node_modules/@aws-sdk/middleware-sdk-s3/dist-es/region-redirect-middleware.js"() {
    "use strict";
    init_region_redirect_endpoint_middleware();
    regionRedirectMiddlewareOptions = {
      step: "initialize",
      tags: ["REGION_REDIRECT", "S3"],
      name: "regionRedirectMiddleware",
      override: true
    };
    getRegionRedirectMiddlewarePlugin = (clientConfig) => ({
      applyToStack: (clientStack) => {
        clientStack.add(regionRedirectMiddleware(clientConfig), regionRedirectMiddlewareOptions);
        clientStack.addRelativeTo(regionRedirectEndpointMiddleware(clientConfig), regionRedirectEndpointMiddlewareOptions);
      }
    });
  }
});

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-expires-middleware.js
var s3ExpiresMiddleware, s3ExpiresMiddlewareOptions, getS3ExpiresMiddlewarePlugin;
var init_s3_expires_middleware = __esm({
  "node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-expires-middleware.js"() {
    "use strict";
    init_dist_es2();
    init_dist_es20();
    s3ExpiresMiddleware = (config) => {
      return (next, context) => async (args) => {
        const result = await next(args);
        const { response } = result;
        if (HttpResponse.isInstance(response)) {
          if (response.headers.expires) {
            response.headers.expiresstring = response.headers.expires;
            try {
              parseRfc7231DateTime(response.headers.expires);
            } catch (e2) {
              context.logger?.warn(`AWS SDK Warning for ${context.clientName}::${context.commandName} response parsing (${response.headers.expires}): ${e2}`);
              delete response.headers.expires;
            }
          }
        }
        return result;
      };
    };
    s3ExpiresMiddlewareOptions = {
      tags: ["S3"],
      name: "s3ExpiresMiddleware",
      override: true,
      relation: "after",
      toMiddleware: "deserializerMiddleware"
    };
    getS3ExpiresMiddlewarePlugin = (clientConfig) => ({
      applyToStack: (clientStack) => {
        clientStack.addRelativeTo(s3ExpiresMiddleware(clientConfig), s3ExpiresMiddlewareOptions);
      }
    });
  }
});

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/classes/S3ExpressIdentityCache.js
var S3ExpressIdentityCache;
var init_S3ExpressIdentityCache = __esm({
  "node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/classes/S3ExpressIdentityCache.js"() {
    "use strict";
    S3ExpressIdentityCache = class _S3ExpressIdentityCache {
      data;
      lastPurgeTime = Date.now();
      static EXPIRED_CREDENTIAL_PURGE_INTERVAL_MS = 3e4;
      constructor(data = {}) {
        this.data = data;
      }
      get(key) {
        const entry = this.data[key];
        if (!entry) {
          return;
        }
        return entry;
      }
      set(key, entry) {
        this.data[key] = entry;
        return entry;
      }
      delete(key) {
        delete this.data[key];
      }
      async purgeExpired() {
        const now = Date.now();
        if (this.lastPurgeTime + _S3ExpressIdentityCache.EXPIRED_CREDENTIAL_PURGE_INTERVAL_MS > now) {
          return;
        }
        for (const key in this.data) {
          const entry = this.data[key];
          if (!entry.isRefreshing) {
            const credential = await entry.identity;
            if (credential.expiration) {
              if (credential.expiration.getTime() < now) {
                delete this.data[key];
              }
            }
          }
        }
      }
    };
  }
});

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/classes/S3ExpressIdentityCacheEntry.js
var S3ExpressIdentityCacheEntry;
var init_S3ExpressIdentityCacheEntry = __esm({
  "node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/classes/S3ExpressIdentityCacheEntry.js"() {
    "use strict";
    S3ExpressIdentityCacheEntry = class {
      _identity;
      isRefreshing;
      accessed;
      constructor(_identity, isRefreshing = false, accessed = Date.now()) {
        this._identity = _identity;
        this.isRefreshing = isRefreshing;
        this.accessed = accessed;
      }
      get identity() {
        this.accessed = Date.now();
        return this._identity;
      }
    };
  }
});

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/classes/S3ExpressIdentityProviderImpl.js
var S3ExpressIdentityProviderImpl;
var init_S3ExpressIdentityProviderImpl = __esm({
  "node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/classes/S3ExpressIdentityProviderImpl.js"() {
    "use strict";
    init_S3ExpressIdentityCache();
    init_S3ExpressIdentityCacheEntry();
    S3ExpressIdentityProviderImpl = class _S3ExpressIdentityProviderImpl {
      createSessionFn;
      cache;
      static REFRESH_WINDOW_MS = 6e4;
      constructor(createSessionFn, cache2 = new S3ExpressIdentityCache()) {
        this.createSessionFn = createSessionFn;
        this.cache = cache2;
      }
      async getS3ExpressIdentity(awsIdentity, identityProperties) {
        const key = identityProperties.Bucket;
        const { cache: cache2 } = this;
        const entry = cache2.get(key);
        if (entry) {
          return entry.identity.then((identity) => {
            const isExpired = (identity.expiration?.getTime() ?? 0) < Date.now();
            if (isExpired) {
              return cache2.set(key, new S3ExpressIdentityCacheEntry(this.getIdentity(key))).identity;
            }
            const isExpiringSoon = (identity.expiration?.getTime() ?? 0) < Date.now() + _S3ExpressIdentityProviderImpl.REFRESH_WINDOW_MS;
            if (isExpiringSoon && !entry.isRefreshing) {
              entry.isRefreshing = true;
              this.getIdentity(key).then((id) => {
                cache2.set(key, new S3ExpressIdentityCacheEntry(Promise.resolve(id)));
              });
            }
            return identity;
          });
        }
        return cache2.set(key, new S3ExpressIdentityCacheEntry(this.getIdentity(key))).identity;
      }
      async getIdentity(key) {
        await this.cache.purgeExpired().catch((error) => {
          console.warn("Error while clearing expired entries in S3ExpressIdentityCache: \n" + error);
        });
        const session = await this.createSessionFn(key);
        if (!session.Credentials?.AccessKeyId || !session.Credentials?.SecretAccessKey) {
          throw new Error("s3#createSession response credential missing AccessKeyId or SecretAccessKey.");
        }
        const identity = {
          accessKeyId: session.Credentials.AccessKeyId,
          secretAccessKey: session.Credentials.SecretAccessKey,
          sessionToken: session.Credentials.SessionToken,
          expiration: session.Credentials.Expiration ? new Date(session.Credentials.Expiration) : void 0
        };
        return identity;
      }
    };
  }
});

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/constants.js
var S3_EXPRESS_BUCKET_TYPE, S3_EXPRESS_BACKEND, S3_EXPRESS_AUTH_SCHEME, SESSION_TOKEN_QUERY_PARAM, SESSION_TOKEN_HEADER;
var init_constants4 = __esm({
  "node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/constants.js"() {
    "use strict";
    S3_EXPRESS_BUCKET_TYPE = "Directory";
    S3_EXPRESS_BACKEND = "S3Express";
    S3_EXPRESS_AUTH_SCHEME = "sigv4-s3express";
    SESSION_TOKEN_QUERY_PARAM = "X-Amz-S3session-Token";
    SESSION_TOKEN_HEADER = SESSION_TOKEN_QUERY_PARAM.toLowerCase();
  }
});

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/classes/SignatureV4S3Express.js
function getCredentialsWithoutSessionToken(credentials) {
  const credentialsWithoutSessionToken = {
    accessKeyId: credentials.accessKeyId,
    secretAccessKey: credentials.secretAccessKey,
    expiration: credentials.expiration
  };
  return credentialsWithoutSessionToken;
}
function setSingleOverride(privateAccess, credentialsWithoutSessionToken) {
  const id = setTimeout(() => {
    throw new Error("SignatureV4S3Express credential override was created but not called.");
  }, 10);
  const currentCredentialProvider = privateAccess.credentialProvider;
  const overrideCredentialsProviderOnce = () => {
    clearTimeout(id);
    privateAccess.credentialProvider = currentCredentialProvider;
    return Promise.resolve(credentialsWithoutSessionToken);
  };
  privateAccess.credentialProvider = overrideCredentialsProviderOnce;
}
var SignatureV4S3Express;
var init_SignatureV4S3Express = __esm({
  "node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/classes/SignatureV4S3Express.js"() {
    "use strict";
    init_dist_es17();
    init_constants4();
    SignatureV4S3Express = class extends SignatureV4 {
      async signWithCredentials(requestToSign, credentials, options) {
        const credentialsWithoutSessionToken = getCredentialsWithoutSessionToken(credentials);
        requestToSign.headers[SESSION_TOKEN_HEADER] = credentials.sessionToken;
        const privateAccess = this;
        setSingleOverride(privateAccess, credentialsWithoutSessionToken);
        return privateAccess.signRequest(requestToSign, options ?? {});
      }
      async presignWithCredentials(requestToSign, credentials, options) {
        const credentialsWithoutSessionToken = getCredentialsWithoutSessionToken(credentials);
        delete requestToSign.headers[SESSION_TOKEN_HEADER];
        requestToSign.headers[SESSION_TOKEN_QUERY_PARAM] = credentials.sessionToken;
        requestToSign.query = requestToSign.query ?? {};
        requestToSign.query[SESSION_TOKEN_QUERY_PARAM] = credentials.sessionToken;
        const privateAccess = this;
        setSingleOverride(privateAccess, credentialsWithoutSessionToken);
        return this.presign(requestToSign, options);
      }
    };
  }
});

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/functions/s3ExpressMiddleware.js
var s3ExpressMiddleware, s3ExpressMiddlewareOptions, getS3ExpressPlugin;
var init_s3ExpressMiddleware = __esm({
  "node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/functions/s3ExpressMiddleware.js"() {
    "use strict";
    init_dist_es22();
    init_dist_es2();
    init_constants4();
    s3ExpressMiddleware = (options) => {
      return (next, context) => async (args) => {
        if (context.endpointV2) {
          const endpoint = context.endpointV2;
          const isS3ExpressAuth = endpoint.properties?.authSchemes?.[0]?.name === S3_EXPRESS_AUTH_SCHEME;
          const isS3ExpressBucket = endpoint.properties?.backend === S3_EXPRESS_BACKEND || endpoint.properties?.bucketType === S3_EXPRESS_BUCKET_TYPE;
          if (isS3ExpressBucket) {
            setFeature(context, "S3_EXPRESS_BUCKET", "J");
            context.isS3ExpressBucket = true;
          }
          if (isS3ExpressAuth) {
            const requestBucket = args.input.Bucket;
            if (requestBucket) {
              const s3ExpressIdentity = await options.s3ExpressIdentityProvider.getS3ExpressIdentity(await options.credentials(), {
                Bucket: requestBucket
              });
              context.s3ExpressIdentity = s3ExpressIdentity;
              if (HttpRequest.isInstance(args.request) && s3ExpressIdentity.sessionToken) {
                args.request.headers[SESSION_TOKEN_HEADER] = s3ExpressIdentity.sessionToken;
              }
            }
          }
        }
        return next(args);
      };
    };
    s3ExpressMiddlewareOptions = {
      name: "s3ExpressMiddleware",
      step: "build",
      tags: ["S3", "S3_EXPRESS"],
      override: true
    };
    getS3ExpressPlugin = (options) => ({
      applyToStack: (clientStack) => {
        clientStack.add(s3ExpressMiddleware(options), s3ExpressMiddlewareOptions);
      }
    });
  }
});

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/functions/signS3Express.js
var signS3Express;
var init_signS3Express = __esm({
  "node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/functions/signS3Express.js"() {
    "use strict";
    signS3Express = async (s3ExpressIdentity, signingOptions, request, sigV4MultiRegionSigner) => {
      const signedRequest = await sigV4MultiRegionSigner.signWithCredentials(request, s3ExpressIdentity, {});
      if (signedRequest.headers["X-Amz-Security-Token"] || signedRequest.headers["x-amz-security-token"]) {
        throw new Error("X-Amz-Security-Token must not be set for s3-express requests.");
      }
      return signedRequest;
    };
  }
});

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/functions/s3ExpressHttpSigningMiddleware.js
var defaultErrorHandler2, defaultSuccessHandler2, s3ExpressHttpSigningMiddleware, getS3ExpressHttpSigningPlugin;
var init_s3ExpressHttpSigningMiddleware = __esm({
  "node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/functions/s3ExpressHttpSigningMiddleware.js"() {
    "use strict";
    init_dist_es14();
    init_dist_es2();
    init_dist_es4();
    init_signS3Express();
    defaultErrorHandler2 = (signingProperties) => (error) => {
      throw error;
    };
    defaultSuccessHandler2 = (httpResponse, signingProperties) => {
    };
    s3ExpressHttpSigningMiddleware = (config) => (next, context) => async (args) => {
      if (!HttpRequest.isInstance(args.request)) {
        return next(args);
      }
      const smithyContext = getSmithyContext(context);
      const scheme = smithyContext.selectedHttpAuthScheme;
      if (!scheme) {
        throw new Error(`No HttpAuthScheme was selected: unable to sign request`);
      }
      const { httpAuthOption: { signingProperties = {} }, identity, signer } = scheme;
      let request;
      if (context.s3ExpressIdentity) {
        request = await signS3Express(context.s3ExpressIdentity, signingProperties, args.request, await config.signer());
      } else {
        request = await signer.sign(args.request, identity, signingProperties);
      }
      const output = await next({
        ...args,
        request
      }).catch((signer.errorHandler || defaultErrorHandler2)(signingProperties));
      (signer.successHandler || defaultSuccessHandler2)(output.response, signingProperties);
      return output;
    };
    getS3ExpressHttpSigningPlugin = (config) => ({
      applyToStack: (clientStack) => {
        clientStack.addRelativeTo(s3ExpressHttpSigningMiddleware(config), httpSigningMiddlewareOptions);
      }
    });
  }
});

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/index.js
var init_s3_express = __esm({
  "node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/index.js"() {
    "use strict";
    init_S3ExpressIdentityProviderImpl();
    init_SignatureV4S3Express();
    init_s3ExpressMiddleware();
    init_s3ExpressHttpSigningMiddleware();
  }
});

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3Configuration.js
var resolveS3Config;
var init_s3Configuration = __esm({
  "node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3Configuration.js"() {
    "use strict";
    init_s3_express();
    resolveS3Config = (input, { session }) => {
      const [s3ClientProvider, CreateSessionCommandCtor] = session;
      const { forcePathStyle, useAccelerateEndpoint, disableMultiregionAccessPoints, followRegionRedirects, s3ExpressIdentityProvider, bucketEndpoint, expectContinueHeader } = input;
      return Object.assign(input, {
        forcePathStyle: forcePathStyle ?? false,
        useAccelerateEndpoint: useAccelerateEndpoint ?? false,
        disableMultiregionAccessPoints: disableMultiregionAccessPoints ?? false,
        followRegionRedirects: followRegionRedirects ?? false,
        s3ExpressIdentityProvider: s3ExpressIdentityProvider ?? new S3ExpressIdentityProviderImpl(async (key) => s3ClientProvider().send(new CreateSessionCommandCtor({
          Bucket: key
        }))),
        bucketEndpoint: bucketEndpoint ?? false,
        expectContinueHeader: expectContinueHeader ?? 2097152
      });
    };
  }
});

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/throw-200-exceptions.js
var THROW_IF_EMPTY_BODY, MAX_BYTES_TO_INSPECT, throw200ExceptionsMiddleware, collectBody2, throw200ExceptionsMiddlewareOptions, getThrow200ExceptionsPlugin;
var init_throw_200_exceptions = __esm({
  "node_modules/@aws-sdk/middleware-sdk-s3/dist-es/throw-200-exceptions.js"() {
    "use strict";
    init_dist_es2();
    init_dist_es12();
    THROW_IF_EMPTY_BODY = {
      CopyObjectCommand: true,
      UploadPartCopyCommand: true,
      CompleteMultipartUploadCommand: true
    };
    MAX_BYTES_TO_INSPECT = 3e3;
    throw200ExceptionsMiddleware = (config) => (next, context) => async (args) => {
      const result = await next(args);
      const { response } = result;
      if (!HttpResponse.isInstance(response)) {
        return result;
      }
      const { statusCode, body: sourceBody } = response;
      if (statusCode < 200 || statusCode >= 300) {
        return result;
      }
      const isSplittableStream = typeof sourceBody?.stream === "function" || typeof sourceBody?.pipe === "function" || typeof sourceBody?.tee === "function";
      if (!isSplittableStream) {
        return result;
      }
      let bodyCopy = sourceBody;
      let body = sourceBody;
      if (sourceBody && typeof sourceBody === "object" && !(sourceBody instanceof Uint8Array)) {
        [bodyCopy, body] = await splitStream(sourceBody);
      }
      response.body = body;
      const bodyBytes = await collectBody2(bodyCopy, {
        streamCollector: async (stream) => {
          return headStream(stream, MAX_BYTES_TO_INSPECT);
        }
      });
      if (typeof bodyCopy?.destroy === "function") {
        bodyCopy.destroy();
      }
      const bodyStringTail = config.utf8Encoder(bodyBytes.subarray(bodyBytes.length - 16));
      if (bodyBytes.length === 0 && THROW_IF_EMPTY_BODY[context.commandName]) {
        const err = new Error("S3 aborted request");
        err.name = "InternalError";
        throw err;
      }
      if (bodyStringTail && bodyStringTail.endsWith("</Error>")) {
        response.statusCode = 400;
      }
      return result;
    };
    collectBody2 = (streamBody = new Uint8Array(), context) => {
      if (streamBody instanceof Uint8Array) {
        return Promise.resolve(streamBody);
      }
      return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
    };
    throw200ExceptionsMiddlewareOptions = {
      relation: "after",
      toMiddleware: "deserializerMiddleware",
      tags: ["THROW_200_EXCEPTIONS", "S3"],
      name: "throw200ExceptionsMiddleware",
      override: true
    };
    getThrow200ExceptionsPlugin = (config) => ({
      applyToStack: (clientStack) => {
        clientStack.addRelativeTo(throw200ExceptionsMiddleware(config), throw200ExceptionsMiddlewareOptions);
      }
    });
  }
});

// node_modules/@aws-sdk/util-arn-parser/dist-es/index.js
var validate;
var init_dist_es28 = __esm({
  "node_modules/@aws-sdk/util-arn-parser/dist-es/index.js"() {
    "use strict";
    validate = (str) => typeof str === "string" && str.indexOf("arn:") === 0 && str.split(":").length >= 6;
  }
});

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/bucket-endpoint-middleware.js
function bucketEndpointMiddleware(options) {
  return (next, context) => async (args) => {
    if (options.bucketEndpoint) {
      const endpoint = context.endpointV2;
      if (endpoint) {
        const bucket = args.input.Bucket;
        if (typeof bucket === "string") {
          try {
            const bucketEndpointUrl = new URL(bucket);
            context.endpointV2 = {
              ...endpoint,
              url: bucketEndpointUrl
            };
          } catch (e2) {
            const warning = `@aws-sdk/middleware-sdk-s3: bucketEndpoint=true was set but Bucket=${bucket} could not be parsed as URL.`;
            if (context.logger?.constructor?.name === "NoOpLogger") {
              console.warn(warning);
            } else {
              context.logger?.warn?.(warning);
            }
            throw e2;
          }
        }
      }
    }
    return next(args);
  };
}
var bucketEndpointMiddlewareOptions;
var init_bucket_endpoint_middleware = __esm({
  "node_modules/@aws-sdk/middleware-sdk-s3/dist-es/bucket-endpoint-middleware.js"() {
    "use strict";
    bucketEndpointMiddlewareOptions = {
      name: "bucketEndpointMiddleware",
      override: true,
      relation: "after",
      toMiddleware: "endpointV2Middleware"
    };
  }
});

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/validate-bucket-name.js
function validateBucketNameMiddleware({ bucketEndpoint }) {
  return (next) => async (args) => {
    const { input: { Bucket } } = args;
    if (!bucketEndpoint && typeof Bucket === "string" && !validate(Bucket) && Bucket.indexOf("/") >= 0) {
      const err = new Error(`Bucket name shouldn't contain '/', received '${Bucket}'`);
      err.name = "InvalidBucketName";
      throw err;
    }
    return next({ ...args });
  };
}
var validateBucketNameMiddlewareOptions, getValidateBucketNamePlugin;
var init_validate_bucket_name = __esm({
  "node_modules/@aws-sdk/middleware-sdk-s3/dist-es/validate-bucket-name.js"() {
    "use strict";
    init_dist_es28();
    init_bucket_endpoint_middleware();
    validateBucketNameMiddlewareOptions = {
      step: "initialize",
      tags: ["VALIDATE_BUCKET_NAME"],
      name: "validateBucketNameMiddleware",
      override: true
    };
    getValidateBucketNamePlugin = (options) => ({
      applyToStack: (clientStack) => {
        clientStack.add(validateBucketNameMiddleware(options), validateBucketNameMiddlewareOptions);
        clientStack.addRelativeTo(bucketEndpointMiddleware(options), bucketEndpointMiddlewareOptions);
      }
    });
  }
});

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/index.js
var init_dist_es29 = __esm({
  "node_modules/@aws-sdk/middleware-sdk-s3/dist-es/index.js"() {
    "use strict";
    init_check_content_length_header();
    init_region_redirect_endpoint_middleware();
    init_region_redirect_middleware();
    init_s3_expires_middleware();
    init_s3_express();
    init_s3Configuration();
    init_throw_200_exceptions();
    init_validate_bucket_name();
  }
});

// node_modules/@aws-sdk/middleware-user-agent/dist-es/configurations.js
function isValidUserAgentAppId(appId) {
  if (appId === void 0) {
    return true;
  }
  return typeof appId === "string" && appId.length <= 50;
}
function resolveUserAgentConfig(input) {
  const normalizedAppIdProvider = normalizeProvider2(input.userAgentAppId ?? DEFAULT_UA_APP_ID);
  const { customUserAgent } = input;
  return Object.assign(input, {
    customUserAgent: typeof customUserAgent === "string" ? [[customUserAgent]] : customUserAgent,
    userAgentAppId: async () => {
      const appId = await normalizedAppIdProvider();
      if (!isValidUserAgentAppId(appId)) {
        const logger2 = input.logger?.constructor?.name === "NoOpLogger" || !input.logger ? console : input.logger;
        if (typeof appId !== "string") {
          logger2?.warn("userAgentAppId must be a string or undefined.");
        } else if (appId.length > 50) {
          logger2?.warn("The provided userAgentAppId exceeds the maximum length of 50 characters.");
        }
      }
      return appId;
    }
  });
}
var DEFAULT_UA_APP_ID;
var init_configurations = __esm({
  "node_modules/@aws-sdk/middleware-user-agent/dist-es/configurations.js"() {
    "use strict";
    init_dist_es14();
    DEFAULT_UA_APP_ID = void 0;
  }
});

// node_modules/@smithy/util-endpoints/dist-es/cache/EndpointCache.js
var EndpointCache;
var init_EndpointCache = __esm({
  "node_modules/@smithy/util-endpoints/dist-es/cache/EndpointCache.js"() {
    "use strict";
    EndpointCache = class {
      capacity;
      data = /* @__PURE__ */ new Map();
      parameters = [];
      constructor({ size, params }) {
        this.capacity = size ?? 50;
        if (params) {
          this.parameters = params;
        }
      }
      get(endpointParams, resolver) {
        const key = this.hash(endpointParams);
        if (key === false) {
          return resolver();
        }
        if (!this.data.has(key)) {
          if (this.data.size > this.capacity + 10) {
            const keys = this.data.keys();
            let i2 = 0;
            while (true) {
              const { value, done } = keys.next();
              this.data.delete(value);
              if (done || ++i2 > 10) {
                break;
              }
            }
          }
          this.data.set(key, resolver());
        }
        return this.data.get(key);
      }
      size() {
        return this.data.size;
      }
      hash(endpointParams) {
        let buffer = "";
        const { parameters } = this;
        if (parameters.length === 0) {
          return false;
        }
        for (const param of parameters) {
          const val = String(endpointParams[param] ?? "");
          if (val.includes("|;")) {
            return false;
          }
          buffer += val + "|;";
        }
        return buffer;
      }
    };
  }
});

// node_modules/@smithy/util-endpoints/dist-es/lib/isIpAddress.js
var IP_V4_REGEX, isIpAddress;
var init_isIpAddress = __esm({
  "node_modules/@smithy/util-endpoints/dist-es/lib/isIpAddress.js"() {
    "use strict";
    IP_V4_REGEX = new RegExp(`^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$`);
    isIpAddress = (value) => IP_V4_REGEX.test(value) || value.startsWith("[") && value.endsWith("]");
  }
});

// node_modules/@smithy/util-endpoints/dist-es/lib/isValidHostLabel.js
var VALID_HOST_LABEL_REGEX, isValidHostLabel;
var init_isValidHostLabel = __esm({
  "node_modules/@smithy/util-endpoints/dist-es/lib/isValidHostLabel.js"() {
    "use strict";
    VALID_HOST_LABEL_REGEX = new RegExp(`^(?!.*-$)(?!-)[a-zA-Z0-9-]{1,63}$`);
    isValidHostLabel = (value, allowSubDomains = false) => {
      if (!allowSubDomains) {
        return VALID_HOST_LABEL_REGEX.test(value);
      }
      const labels = value.split(".");
      for (const label of labels) {
        if (!isValidHostLabel(label)) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/@smithy/util-endpoints/dist-es/utils/customEndpointFunctions.js
var customEndpointFunctions;
var init_customEndpointFunctions = __esm({
  "node_modules/@smithy/util-endpoints/dist-es/utils/customEndpointFunctions.js"() {
    "use strict";
    customEndpointFunctions = {};
  }
});

// node_modules/@smithy/util-endpoints/dist-es/debug/debugId.js
var debugId;
var init_debugId = __esm({
  "node_modules/@smithy/util-endpoints/dist-es/debug/debugId.js"() {
    "use strict";
    debugId = "endpoints";
  }
});

// node_modules/@smithy/util-endpoints/dist-es/debug/toDebugString.js
function toDebugString(input) {
  if (typeof input !== "object" || input == null) {
    return input;
  }
  if ("ref" in input) {
    return `$${toDebugString(input.ref)}`;
  }
  if ("fn" in input) {
    return `${input.fn}(${(input.argv || []).map(toDebugString).join(", ")})`;
  }
  return JSON.stringify(input, null, 2);
}
var init_toDebugString = __esm({
  "node_modules/@smithy/util-endpoints/dist-es/debug/toDebugString.js"() {
    "use strict";
  }
});

// node_modules/@smithy/util-endpoints/dist-es/debug/index.js
var init_debug = __esm({
  "node_modules/@smithy/util-endpoints/dist-es/debug/index.js"() {
    "use strict";
    init_debugId();
    init_toDebugString();
  }
});

// node_modules/@smithy/util-endpoints/dist-es/types/EndpointError.js
var EndpointError;
var init_EndpointError = __esm({
  "node_modules/@smithy/util-endpoints/dist-es/types/EndpointError.js"() {
    "use strict";
    EndpointError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "EndpointError";
      }
    };
  }
});

// node_modules/@smithy/util-endpoints/dist-es/types/EndpointFunctions.js
var init_EndpointFunctions = __esm({
  "node_modules/@smithy/util-endpoints/dist-es/types/EndpointFunctions.js"() {
    "use strict";
  }
});

// node_modules/@smithy/util-endpoints/dist-es/types/EndpointRuleObject.js
var init_EndpointRuleObject2 = __esm({
  "node_modules/@smithy/util-endpoints/dist-es/types/EndpointRuleObject.js"() {
    "use strict";
  }
});

// node_modules/@smithy/util-endpoints/dist-es/types/ErrorRuleObject.js
var init_ErrorRuleObject2 = __esm({
  "node_modules/@smithy/util-endpoints/dist-es/types/ErrorRuleObject.js"() {
    "use strict";
  }
});

// node_modules/@smithy/util-endpoints/dist-es/types/RuleSetObject.js
var init_RuleSetObject2 = __esm({
  "node_modules/@smithy/util-endpoints/dist-es/types/RuleSetObject.js"() {
    "use strict";
  }
});

// node_modules/@smithy/util-endpoints/dist-es/types/TreeRuleObject.js
var init_TreeRuleObject2 = __esm({
  "node_modules/@smithy/util-endpoints/dist-es/types/TreeRuleObject.js"() {
    "use strict";
  }
});

// node_modules/@smithy/util-endpoints/dist-es/types/shared.js
var init_shared2 = __esm({
  "node_modules/@smithy/util-endpoints/dist-es/types/shared.js"() {
    "use strict";
  }
});

// node_modules/@smithy/util-endpoints/dist-es/types/index.js
var init_types3 = __esm({
  "node_modules/@smithy/util-endpoints/dist-es/types/index.js"() {
    "use strict";
    init_EndpointError();
    init_EndpointFunctions();
    init_EndpointRuleObject2();
    init_ErrorRuleObject2();
    init_RuleSetObject2();
    init_TreeRuleObject2();
    init_shared2();
  }
});

// node_modules/@smithy/util-endpoints/dist-es/lib/booleanEquals.js
var booleanEquals;
var init_booleanEquals = __esm({
  "node_modules/@smithy/util-endpoints/dist-es/lib/booleanEquals.js"() {
    "use strict";
    booleanEquals = (value1, value2) => value1 === value2;
  }
});

// node_modules/@smithy/util-endpoints/dist-es/lib/getAttrPathList.js
var getAttrPathList;
var init_getAttrPathList = __esm({
  "node_modules/@smithy/util-endpoints/dist-es/lib/getAttrPathList.js"() {
    "use strict";
    init_types3();
    getAttrPathList = (path) => {
      const parts = path.split(".");
      const pathList = [];
      for (const part of parts) {
        const squareBracketIndex = part.indexOf("[");
        if (squareBracketIndex !== -1) {
          if (part.indexOf("]") !== part.length - 1) {
            throw new EndpointError(`Path: '${path}' does not end with ']'`);
          }
          const arrayIndex = part.slice(squareBracketIndex + 1, -1);
          if (Number.isNaN(parseInt(arrayIndex))) {
            throw new EndpointError(`Invalid array index: '${arrayIndex}' in path: '${path}'`);
          }
          if (squareBracketIndex !== 0) {
            pathList.push(part.slice(0, squareBracketIndex));
          }
          pathList.push(arrayIndex);
        } else {
          pathList.push(part);
        }
      }
      return pathList;
    };
  }
});

// node_modules/@smithy/util-endpoints/dist-es/lib/getAttr.js
var getAttr;
var init_getAttr = __esm({
  "node_modules/@smithy/util-endpoints/dist-es/lib/getAttr.js"() {
    "use strict";
    init_types3();
    init_getAttrPathList();
    getAttr = (value, path) => getAttrPathList(path).reduce((acc, index) => {
      if (typeof acc !== "object") {
        throw new EndpointError(`Index '${index}' in '${path}' not found in '${JSON.stringify(value)}'`);
      } else if (Array.isArray(acc)) {
        return acc[parseInt(index)];
      }
      return acc[index];
    }, value);
  }
});

// node_modules/@smithy/util-endpoints/dist-es/lib/isSet.js
var isSet;
var init_isSet = __esm({
  "node_modules/@smithy/util-endpoints/dist-es/lib/isSet.js"() {
    "use strict";
    isSet = (value) => value != null;
  }
});

// node_modules/@smithy/util-endpoints/dist-es/lib/not.js
var not;
var init_not = __esm({
  "node_modules/@smithy/util-endpoints/dist-es/lib/not.js"() {
    "use strict";
    not = (value) => !value;
  }
});

// node_modules/@smithy/util-endpoints/dist-es/lib/parseURL.js
var DEFAULT_PORTS, parseURL;
var init_parseURL = __esm({
  "node_modules/@smithy/util-endpoints/dist-es/lib/parseURL.js"() {
    "use strict";
    init_dist_es();
    init_isIpAddress();
    DEFAULT_PORTS = {
      [EndpointURLScheme.HTTP]: 80,
      [EndpointURLScheme.HTTPS]: 443
    };
    parseURL = (value) => {
      const whatwgURL = (() => {
        try {
          if (value instanceof URL) {
            return value;
          }
          if (typeof value === "object" && "hostname" in value) {
            const { hostname: hostname2, port, protocol: protocol2 = "", path = "", query = {} } = value;
            const url = new URL(`${protocol2}//${hostname2}${port ? `:${port}` : ""}${path}`);
            url.search = Object.entries(query).map(([k2, v2]) => `${k2}=${v2}`).join("&");
            return url;
          }
          return new URL(value);
        } catch (error) {
          return null;
        }
      })();
      if (!whatwgURL) {
        console.error(`Unable to parse ${JSON.stringify(value)} as a whatwg URL.`);
        return null;
      }
      const urlString = whatwgURL.href;
      const { host, hostname, pathname, protocol, search } = whatwgURL;
      if (search) {
        return null;
      }
      const scheme = protocol.slice(0, -1);
      if (!Object.values(EndpointURLScheme).includes(scheme)) {
        return null;
      }
      const isIp = isIpAddress(hostname);
      const inputContainsDefaultPort = urlString.includes(`${host}:${DEFAULT_PORTS[scheme]}`) || typeof value === "string" && value.includes(`${host}:${DEFAULT_PORTS[scheme]}`);
      const authority = `${host}${inputContainsDefaultPort ? `:${DEFAULT_PORTS[scheme]}` : ``}`;
      return {
        scheme,
        authority,
        path: pathname,
        normalizedPath: pathname.endsWith("/") ? pathname : `${pathname}/`,
        isIp
      };
    };
  }
});

// node_modules/@smithy/util-endpoints/dist-es/lib/stringEquals.js
var stringEquals;
var init_stringEquals = __esm({
  "node_modules/@smithy/util-endpoints/dist-es/lib/stringEquals.js"() {
    "use strict";
    stringEquals = (value1, value2) => value1 === value2;
  }
});

// node_modules/@smithy/util-endpoints/dist-es/lib/substring.js
var substring;
var init_substring = __esm({
  "node_modules/@smithy/util-endpoints/dist-es/lib/substring.js"() {
    "use strict";
    substring = (input, start, stop, reverse) => {
      if (start >= stop || input.length < stop) {
        return null;
      }
      if (!reverse) {
        return input.substring(start, stop);
      }
      return input.substring(input.length - stop, input.length - start);
    };
  }
});

// node_modules/@smithy/util-endpoints/dist-es/lib/uriEncode.js
var uriEncode;
var init_uriEncode = __esm({
  "node_modules/@smithy/util-endpoints/dist-es/lib/uriEncode.js"() {
    "use strict";
    uriEncode = (value) => encodeURIComponent(value).replace(/[!*'()]/g, (c2) => `%${c2.charCodeAt(0).toString(16).toUpperCase()}`);
  }
});

// node_modules/@smithy/util-endpoints/dist-es/lib/index.js
var init_lib = __esm({
  "node_modules/@smithy/util-endpoints/dist-es/lib/index.js"() {
    "use strict";
    init_booleanEquals();
    init_getAttr();
    init_isSet();
    init_isValidHostLabel();
    init_not();
    init_parseURL();
    init_stringEquals();
    init_substring();
    init_uriEncode();
  }
});

// node_modules/@smithy/util-endpoints/dist-es/utils/endpointFunctions.js
var endpointFunctions;
var init_endpointFunctions = __esm({
  "node_modules/@smithy/util-endpoints/dist-es/utils/endpointFunctions.js"() {
    "use strict";
    init_lib();
    endpointFunctions = {
      booleanEquals,
      getAttr,
      isSet,
      isValidHostLabel,
      not,
      parseURL,
      stringEquals,
      substring,
      uriEncode
    };
  }
});

// node_modules/@smithy/util-endpoints/dist-es/utils/evaluateTemplate.js
var evaluateTemplate;
var init_evaluateTemplate = __esm({
  "node_modules/@smithy/util-endpoints/dist-es/utils/evaluateTemplate.js"() {
    "use strict";
    init_lib();
    evaluateTemplate = (template, options) => {
      const evaluatedTemplateArr = [];
      const templateContext = {
        ...options.endpointParams,
        ...options.referenceRecord
      };
      let currentIndex = 0;
      while (currentIndex < template.length) {
        const openingBraceIndex = template.indexOf("{", currentIndex);
        if (openingBraceIndex === -1) {
          evaluatedTemplateArr.push(template.slice(currentIndex));
          break;
        }
        evaluatedTemplateArr.push(template.slice(currentIndex, openingBraceIndex));
        const closingBraceIndex = template.indexOf("}", openingBraceIndex);
        if (closingBraceIndex === -1) {
          evaluatedTemplateArr.push(template.slice(openingBraceIndex));
          break;
        }
        if (template[openingBraceIndex + 1] === "{" && template[closingBraceIndex + 1] === "}") {
          evaluatedTemplateArr.push(template.slice(openingBraceIndex + 1, closingBraceIndex));
          currentIndex = closingBraceIndex + 2;
        }
        const parameterName = template.substring(openingBraceIndex + 1, closingBraceIndex);
        if (parameterName.includes("#")) {
          const [refName, attrName] = parameterName.split("#");
          evaluatedTemplateArr.push(getAttr(templateContext[refName], attrName));
        } else {
          evaluatedTemplateArr.push(templateContext[parameterName]);
        }
        currentIndex = closingBraceIndex + 1;
      }
      return evaluatedTemplateArr.join("");
    };
  }
});

// node_modules/@smithy/util-endpoints/dist-es/utils/getReferenceValue.js
var getReferenceValue;
var init_getReferenceValue = __esm({
  "node_modules/@smithy/util-endpoints/dist-es/utils/getReferenceValue.js"() {
    "use strict";
    getReferenceValue = ({ ref }, options) => {
      const referenceRecord = {
        ...options.endpointParams,
        ...options.referenceRecord
      };
      return referenceRecord[ref];
    };
  }
});

// node_modules/@smithy/util-endpoints/dist-es/utils/evaluateExpression.js
var evaluateExpression, callFunction, group;
var init_evaluateExpression = __esm({
  "node_modules/@smithy/util-endpoints/dist-es/utils/evaluateExpression.js"() {
    "use strict";
    init_types3();
    init_customEndpointFunctions();
    init_endpointFunctions();
    init_evaluateTemplate();
    init_getReferenceValue();
    evaluateExpression = (obj, keyName, options) => {
      if (typeof obj === "string") {
        return evaluateTemplate(obj, options);
      } else if (obj["fn"]) {
        return group.callFunction(obj, options);
      } else if (obj["ref"]) {
        return getReferenceValue(obj, options);
      }
      throw new EndpointError(`'${keyName}': ${String(obj)} is not a string, function or reference.`);
    };
    callFunction = ({ fn, argv }, options) => {
      const evaluatedArgs = argv.map((arg) => ["boolean", "number"].includes(typeof arg) ? arg : group.evaluateExpression(arg, "arg", options));
      const fnSegments = fn.split(".");
      if (fnSegments[0] in customEndpointFunctions && fnSegments[1] != null) {
        return customEndpointFunctions[fnSegments[0]][fnSegments[1]](...evaluatedArgs);
      }
      return endpointFunctions[fn](...evaluatedArgs);
    };
    group = {
      evaluateExpression,
      callFunction
    };
  }
});

// node_modules/@smithy/util-endpoints/dist-es/utils/callFunction.js
var init_callFunction = __esm({
  "node_modules/@smithy/util-endpoints/dist-es/utils/callFunction.js"() {
    "use strict";
    init_evaluateExpression();
  }
});

// node_modules/@smithy/util-endpoints/dist-es/utils/evaluateCondition.js
var evaluateCondition;
var init_evaluateCondition = __esm({
  "node_modules/@smithy/util-endpoints/dist-es/utils/evaluateCondition.js"() {
    "use strict";
    init_debug();
    init_types3();
    init_callFunction();
    evaluateCondition = ({ assign, ...fnArgs }, options) => {
      if (assign && assign in options.referenceRecord) {
        throw new EndpointError(`'${assign}' is already defined in Reference Record.`);
      }
      const value = callFunction(fnArgs, options);
      options.logger?.debug?.(`${debugId} evaluateCondition: ${toDebugString(fnArgs)} = ${toDebugString(value)}`);
      return {
        result: value === "" ? true : !!value,
        ...assign != null && { toAssign: { name: assign, value } }
      };
    };
  }
});

// node_modules/@smithy/util-endpoints/dist-es/utils/evaluateConditions.js
var evaluateConditions;
var init_evaluateConditions = __esm({
  "node_modules/@smithy/util-endpoints/dist-es/utils/evaluateConditions.js"() {
    "use strict";
    init_debug();
    init_evaluateCondition();
    evaluateConditions = (conditions = [], options) => {
      const conditionsReferenceRecord = {};
      for (const condition of conditions) {
        const { result, toAssign } = evaluateCondition(condition, {
          ...options,
          referenceRecord: {
            ...options.referenceRecord,
            ...conditionsReferenceRecord
          }
        });
        if (!result) {
          return { result };
        }
        if (toAssign) {
          conditionsReferenceRecord[toAssign.name] = toAssign.value;
          options.logger?.debug?.(`${debugId} assign: ${toAssign.name} := ${toDebugString(toAssign.value)}`);
        }
      }
      return { result: true, referenceRecord: conditionsReferenceRecord };
    };
  }
});

// node_modules/@smithy/util-endpoints/dist-es/utils/getEndpointHeaders.js
var getEndpointHeaders;
var init_getEndpointHeaders = __esm({
  "node_modules/@smithy/util-endpoints/dist-es/utils/getEndpointHeaders.js"() {
    "use strict";
    init_types3();
    init_evaluateExpression();
    getEndpointHeaders = (headers, options) => Object.entries(headers).reduce((acc, [headerKey, headerVal]) => ({
      ...acc,
      [headerKey]: headerVal.map((headerValEntry) => {
        const processedExpr = evaluateExpression(headerValEntry, "Header value entry", options);
        if (typeof processedExpr !== "string") {
          throw new EndpointError(`Header '${headerKey}' value '${processedExpr}' is not a string`);
        }
        return processedExpr;
      })
    }), {});
  }
});

// node_modules/@smithy/util-endpoints/dist-es/utils/getEndpointProperties.js
var getEndpointProperties, getEndpointProperty, group2;
var init_getEndpointProperties = __esm({
  "node_modules/@smithy/util-endpoints/dist-es/utils/getEndpointProperties.js"() {
    "use strict";
    init_types3();
    init_evaluateTemplate();
    getEndpointProperties = (properties, options) => Object.entries(properties).reduce((acc, [propertyKey, propertyVal]) => ({
      ...acc,
      [propertyKey]: group2.getEndpointProperty(propertyVal, options)
    }), {});
    getEndpointProperty = (property, options) => {
      if (Array.isArray(property)) {
        return property.map((propertyEntry) => getEndpointProperty(propertyEntry, options));
      }
      switch (typeof property) {
        case "string":
          return evaluateTemplate(property, options);
        case "object":
          if (property === null) {
            throw new EndpointError(`Unexpected endpoint property: ${property}`);
          }
          return group2.getEndpointProperties(property, options);
        case "boolean":
          return property;
        default:
          throw new EndpointError(`Unexpected endpoint property type: ${typeof property}`);
      }
    };
    group2 = {
      getEndpointProperty,
      getEndpointProperties
    };
  }
});

// node_modules/@smithy/util-endpoints/dist-es/utils/getEndpointUrl.js
var getEndpointUrl;
var init_getEndpointUrl = __esm({
  "node_modules/@smithy/util-endpoints/dist-es/utils/getEndpointUrl.js"() {
    "use strict";
    init_types3();
    init_evaluateExpression();
    getEndpointUrl = (endpointUrl, options) => {
      const expression = evaluateExpression(endpointUrl, "Endpoint URL", options);
      if (typeof expression === "string") {
        try {
          return new URL(expression);
        } catch (error) {
          console.error(`Failed to construct URL with ${expression}`, error);
          throw error;
        }
      }
      throw new EndpointError(`Endpoint URL must be a string, got ${typeof expression}`);
    };
  }
});

// node_modules/@smithy/util-endpoints/dist-es/utils/evaluateEndpointRule.js
var evaluateEndpointRule;
var init_evaluateEndpointRule = __esm({
  "node_modules/@smithy/util-endpoints/dist-es/utils/evaluateEndpointRule.js"() {
    "use strict";
    init_debug();
    init_evaluateConditions();
    init_getEndpointHeaders();
    init_getEndpointProperties();
    init_getEndpointUrl();
    evaluateEndpointRule = (endpointRule, options) => {
      const { conditions, endpoint } = endpointRule;
      const { result, referenceRecord } = evaluateConditions(conditions, options);
      if (!result) {
        return;
      }
      const endpointRuleOptions = {
        ...options,
        referenceRecord: { ...options.referenceRecord, ...referenceRecord }
      };
      const { url, properties, headers } = endpoint;
      options.logger?.debug?.(`${debugId} Resolving endpoint from template: ${toDebugString(endpoint)}`);
      return {
        ...headers != void 0 && {
          headers: getEndpointHeaders(headers, endpointRuleOptions)
        },
        ...properties != void 0 && {
          properties: getEndpointProperties(properties, endpointRuleOptions)
        },
        url: getEndpointUrl(url, endpointRuleOptions)
      };
    };
  }
});

// node_modules/@smithy/util-endpoints/dist-es/utils/evaluateErrorRule.js
var evaluateErrorRule;
var init_evaluateErrorRule = __esm({
  "node_modules/@smithy/util-endpoints/dist-es/utils/evaluateErrorRule.js"() {
    "use strict";
    init_types3();
    init_evaluateConditions();
    init_evaluateExpression();
    evaluateErrorRule = (errorRule, options) => {
      const { conditions, error } = errorRule;
      const { result, referenceRecord } = evaluateConditions(conditions, options);
      if (!result) {
        return;
      }
      throw new EndpointError(evaluateExpression(error, "Error", {
        ...options,
        referenceRecord: { ...options.referenceRecord, ...referenceRecord }
      }));
    };
  }
});

// node_modules/@smithy/util-endpoints/dist-es/utils/evaluateRules.js
var evaluateRules, evaluateTreeRule, group3;
var init_evaluateRules = __esm({
  "node_modules/@smithy/util-endpoints/dist-es/utils/evaluateRules.js"() {
    "use strict";
    init_types3();
    init_evaluateConditions();
    init_evaluateEndpointRule();
    init_evaluateErrorRule();
    evaluateRules = (rules, options) => {
      for (const rule of rules) {
        if (rule.type === "endpoint") {
          const endpointOrUndefined = evaluateEndpointRule(rule, options);
          if (endpointOrUndefined) {
            return endpointOrUndefined;
          }
        } else if (rule.type === "error") {
          evaluateErrorRule(rule, options);
        } else if (rule.type === "tree") {
          const endpointOrUndefined = group3.evaluateTreeRule(rule, options);
          if (endpointOrUndefined) {
            return endpointOrUndefined;
          }
        } else {
          throw new EndpointError(`Unknown endpoint rule: ${rule}`);
        }
      }
      throw new EndpointError(`Rules evaluation failed`);
    };
    evaluateTreeRule = (treeRule, options) => {
      const { conditions, rules } = treeRule;
      const { result, referenceRecord } = evaluateConditions(conditions, options);
      if (!result) {
        return;
      }
      return group3.evaluateRules(rules, {
        ...options,
        referenceRecord: { ...options.referenceRecord, ...referenceRecord }
      });
    };
    group3 = {
      evaluateRules,
      evaluateTreeRule
    };
  }
});

// node_modules/@smithy/util-endpoints/dist-es/utils/index.js
var init_utils2 = __esm({
  "node_modules/@smithy/util-endpoints/dist-es/utils/index.js"() {
    "use strict";
    init_customEndpointFunctions();
    init_evaluateRules();
  }
});

// node_modules/@smithy/util-endpoints/dist-es/resolveEndpoint.js
var resolveEndpoint;
var init_resolveEndpoint = __esm({
  "node_modules/@smithy/util-endpoints/dist-es/resolveEndpoint.js"() {
    "use strict";
    init_debug();
    init_types3();
    init_utils2();
    resolveEndpoint = (ruleSetObject, options) => {
      const { endpointParams, logger: logger2 } = options;
      const { parameters, rules } = ruleSetObject;
      options.logger?.debug?.(`${debugId} Initial EndpointParams: ${toDebugString(endpointParams)}`);
      const paramsWithDefault = Object.entries(parameters).filter(([, v2]) => v2.default != null).map(([k2, v2]) => [k2, v2.default]);
      if (paramsWithDefault.length > 0) {
        for (const [paramKey, paramDefaultValue] of paramsWithDefault) {
          endpointParams[paramKey] = endpointParams[paramKey] ?? paramDefaultValue;
        }
      }
      const requiredParams = Object.entries(parameters).filter(([, v2]) => v2.required).map(([k2]) => k2);
      for (const requiredParam of requiredParams) {
        if (endpointParams[requiredParam] == null) {
          throw new EndpointError(`Missing required parameter: '${requiredParam}'`);
        }
      }
      const endpoint = evaluateRules(rules, { endpointParams, logger: logger2, referenceRecord: {} });
      options.logger?.debug?.(`${debugId} Resolved endpoint: ${toDebugString(endpoint)}`);
      return endpoint;
    };
  }
});

// node_modules/@smithy/util-endpoints/dist-es/index.js
var init_dist_es30 = __esm({
  "node_modules/@smithy/util-endpoints/dist-es/index.js"() {
    "use strict";
    init_EndpointCache();
    init_isIpAddress();
    init_isValidHostLabel();
    init_customEndpointFunctions();
    init_resolveEndpoint();
    init_types3();
  }
});

// node_modules/@aws-sdk/util-endpoints/dist-es/lib/isIpAddress.js
var init_isIpAddress2 = __esm({
  "node_modules/@aws-sdk/util-endpoints/dist-es/lib/isIpAddress.js"() {
    "use strict";
    init_dist_es30();
  }
});

// node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/isVirtualHostableS3Bucket.js
var isVirtualHostableS3Bucket;
var init_isVirtualHostableS3Bucket = __esm({
  "node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/isVirtualHostableS3Bucket.js"() {
    "use strict";
    init_dist_es30();
    init_isIpAddress2();
    isVirtualHostableS3Bucket = (value, allowSubDomains = false) => {
      if (allowSubDomains) {
        for (const label of value.split(".")) {
          if (!isVirtualHostableS3Bucket(label)) {
            return false;
          }
        }
        return true;
      }
      if (!isValidHostLabel(value)) {
        return false;
      }
      if (value.length < 3 || value.length > 63) {
        return false;
      }
      if (value !== value.toLowerCase()) {
        return false;
      }
      if (isIpAddress(value)) {
        return false;
      }
      return true;
    };
  }
});

// node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/parseArn.js
var ARN_DELIMITER, RESOURCE_DELIMITER, parseArn;
var init_parseArn = __esm({
  "node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/parseArn.js"() {
    "use strict";
    ARN_DELIMITER = ":";
    RESOURCE_DELIMITER = "/";
    parseArn = (value) => {
      const segments = value.split(ARN_DELIMITER);
      if (segments.length < 6)
        return null;
      const [arn, partition2, service, region, accountId, ...resourcePath] = segments;
      if (arn !== "arn" || partition2 === "" || service === "" || resourcePath.join(ARN_DELIMITER) === "")
        return null;
      const resourceId = resourcePath.map((resource) => resource.split(RESOURCE_DELIMITER)).flat();
      return {
        partition: partition2,
        service,
        region,
        accountId,
        resourceId
      };
    };
  }
});

// node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/partitions.json
var partitions_default;
var init_partitions = __esm({
  "node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/partitions.json"() {
    partitions_default = {
      partitions: [{
        id: "aws",
        outputs: {
          dnsSuffix: "amazonaws.com",
          dualStackDnsSuffix: "api.aws",
          implicitGlobalRegion: "us-east-1",
          name: "aws",
          supportsDualStack: true,
          supportsFIPS: true
        },
        regionRegex: "^(us|eu|ap|sa|ca|me|af|il|mx)\\-\\w+\\-\\d+$",
        regions: {
          "af-south-1": {
            description: "Africa (Cape Town)"
          },
          "ap-east-1": {
            description: "Asia Pacific (Hong Kong)"
          },
          "ap-east-2": {
            description: "Asia Pacific (Taipei)"
          },
          "ap-northeast-1": {
            description: "Asia Pacific (Tokyo)"
          },
          "ap-northeast-2": {
            description: "Asia Pacific (Seoul)"
          },
          "ap-northeast-3": {
            description: "Asia Pacific (Osaka)"
          },
          "ap-south-1": {
            description: "Asia Pacific (Mumbai)"
          },
          "ap-south-2": {
            description: "Asia Pacific (Hyderabad)"
          },
          "ap-southeast-1": {
            description: "Asia Pacific (Singapore)"
          },
          "ap-southeast-2": {
            description: "Asia Pacific (Sydney)"
          },
          "ap-southeast-3": {
            description: "Asia Pacific (Jakarta)"
          },
          "ap-southeast-4": {
            description: "Asia Pacific (Melbourne)"
          },
          "ap-southeast-5": {
            description: "Asia Pacific (Malaysia)"
          },
          "ap-southeast-6": {
            description: "Asia Pacific (New Zealand)"
          },
          "ap-southeast-7": {
            description: "Asia Pacific (Thailand)"
          },
          "aws-global": {
            description: "aws global region"
          },
          "ca-central-1": {
            description: "Canada (Central)"
          },
          "ca-west-1": {
            description: "Canada West (Calgary)"
          },
          "eu-central-1": {
            description: "Europe (Frankfurt)"
          },
          "eu-central-2": {
            description: "Europe (Zurich)"
          },
          "eu-north-1": {
            description: "Europe (Stockholm)"
          },
          "eu-south-1": {
            description: "Europe (Milan)"
          },
          "eu-south-2": {
            description: "Europe (Spain)"
          },
          "eu-west-1": {
            description: "Europe (Ireland)"
          },
          "eu-west-2": {
            description: "Europe (London)"
          },
          "eu-west-3": {
            description: "Europe (Paris)"
          },
          "il-central-1": {
            description: "Israel (Tel Aviv)"
          },
          "me-central-1": {
            description: "Middle East (UAE)"
          },
          "me-south-1": {
            description: "Middle East (Bahrain)"
          },
          "mx-central-1": {
            description: "Mexico (Central)"
          },
          "sa-east-1": {
            description: "South America (Sao Paulo)"
          },
          "us-east-1": {
            description: "US East (N. Virginia)"
          },
          "us-east-2": {
            description: "US East (Ohio)"
          },
          "us-west-1": {
            description: "US West (N. California)"
          },
          "us-west-2": {
            description: "US West (Oregon)"
          }
        }
      }, {
        id: "aws-cn",
        outputs: {
          dnsSuffix: "amazonaws.com.cn",
          dualStackDnsSuffix: "api.amazonwebservices.com.cn",
          implicitGlobalRegion: "cn-northwest-1",
          name: "aws-cn",
          supportsDualStack: true,
          supportsFIPS: true
        },
        regionRegex: "^cn\\-\\w+\\-\\d+$",
        regions: {
          "aws-cn-global": {
            description: "aws-cn global region"
          },
          "cn-north-1": {
            description: "China (Beijing)"
          },
          "cn-northwest-1": {
            description: "China (Ningxia)"
          }
        }
      }, {
        id: "aws-eusc",
        outputs: {
          dnsSuffix: "amazonaws.eu",
          dualStackDnsSuffix: "api.amazonwebservices.eu",
          implicitGlobalRegion: "eusc-de-east-1",
          name: "aws-eusc",
          supportsDualStack: true,
          supportsFIPS: true
        },
        regionRegex: "^eusc\\-(de)\\-\\w+\\-\\d+$",
        regions: {
          "eusc-de-east-1": {
            description: "EU (Germany)"
          }
        }
      }, {
        id: "aws-iso",
        outputs: {
          dnsSuffix: "c2s.ic.gov",
          dualStackDnsSuffix: "api.aws.ic.gov",
          implicitGlobalRegion: "us-iso-east-1",
          name: "aws-iso",
          supportsDualStack: true,
          supportsFIPS: true
        },
        regionRegex: "^us\\-iso\\-\\w+\\-\\d+$",
        regions: {
          "aws-iso-global": {
            description: "aws-iso global region"
          },
          "us-iso-east-1": {
            description: "US ISO East"
          },
          "us-iso-west-1": {
            description: "US ISO WEST"
          }
        }
      }, {
        id: "aws-iso-b",
        outputs: {
          dnsSuffix: "sc2s.sgov.gov",
          dualStackDnsSuffix: "api.aws.scloud",
          implicitGlobalRegion: "us-isob-east-1",
          name: "aws-iso-b",
          supportsDualStack: true,
          supportsFIPS: true
        },
        regionRegex: "^us\\-isob\\-\\w+\\-\\d+$",
        regions: {
          "aws-iso-b-global": {
            description: "aws-iso-b global region"
          },
          "us-isob-east-1": {
            description: "US ISOB East (Ohio)"
          },
          "us-isob-west-1": {
            description: "US ISOB West"
          }
        }
      }, {
        id: "aws-iso-e",
        outputs: {
          dnsSuffix: "cloud.adc-e.uk",
          dualStackDnsSuffix: "api.cloud-aws.adc-e.uk",
          implicitGlobalRegion: "eu-isoe-west-1",
          name: "aws-iso-e",
          supportsDualStack: true,
          supportsFIPS: true
        },
        regionRegex: "^eu\\-isoe\\-\\w+\\-\\d+$",
        regions: {
          "aws-iso-e-global": {
            description: "aws-iso-e global region"
          },
          "eu-isoe-west-1": {
            description: "EU ISOE West"
          }
        }
      }, {
        id: "aws-iso-f",
        outputs: {
          dnsSuffix: "csp.hci.ic.gov",
          dualStackDnsSuffix: "api.aws.hci.ic.gov",
          implicitGlobalRegion: "us-isof-south-1",
          name: "aws-iso-f",
          supportsDualStack: true,
          supportsFIPS: true
        },
        regionRegex: "^us\\-isof\\-\\w+\\-\\d+$",
        regions: {
          "aws-iso-f-global": {
            description: "aws-iso-f global region"
          },
          "us-isof-east-1": {
            description: "US ISOF EAST"
          },
          "us-isof-south-1": {
            description: "US ISOF SOUTH"
          }
        }
      }, {
        id: "aws-us-gov",
        outputs: {
          dnsSuffix: "amazonaws.com",
          dualStackDnsSuffix: "api.aws",
          implicitGlobalRegion: "us-gov-west-1",
          name: "aws-us-gov",
          supportsDualStack: true,
          supportsFIPS: true
        },
        regionRegex: "^us\\-gov\\-\\w+\\-\\d+$",
        regions: {
          "aws-us-gov-global": {
            description: "aws-us-gov global region"
          },
          "us-gov-east-1": {
            description: "AWS GovCloud (US-East)"
          },
          "us-gov-west-1": {
            description: "AWS GovCloud (US-West)"
          }
        }
      }],
      version: "1.1"
    };
  }
});

// node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/partition.js
var selectedPartitionsInfo, selectedUserAgentPrefix, partition, getUserAgentPrefix;
var init_partition = __esm({
  "node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/partition.js"() {
    "use strict";
    init_partitions();
    selectedPartitionsInfo = partitions_default;
    selectedUserAgentPrefix = "";
    partition = (value) => {
      const { partitions } = selectedPartitionsInfo;
      for (const partition2 of partitions) {
        const { regions, outputs } = partition2;
        for (const [region, regionData] of Object.entries(regions)) {
          if (region === value) {
            return {
              ...outputs,
              ...regionData
            };
          }
        }
      }
      for (const partition2 of partitions) {
        const { regionRegex, outputs } = partition2;
        if (new RegExp(regionRegex).test(value)) {
          return {
            ...outputs
          };
        }
      }
      const DEFAULT_PARTITION = partitions.find((partition2) => partition2.id === "aws");
      if (!DEFAULT_PARTITION) {
        throw new Error("Provided region was not found in the partition array or regex, and default partition with id 'aws' doesn't exist.");
      }
      return {
        ...DEFAULT_PARTITION.outputs
      };
    };
    getUserAgentPrefix = () => selectedUserAgentPrefix;
  }
});

// node_modules/@aws-sdk/util-endpoints/dist-es/aws.js
var awsEndpointFunctions;
var init_aws = __esm({
  "node_modules/@aws-sdk/util-endpoints/dist-es/aws.js"() {
    "use strict";
    init_dist_es30();
    init_isVirtualHostableS3Bucket();
    init_parseArn();
    init_partition();
    awsEndpointFunctions = {
      isVirtualHostableS3Bucket,
      parseArn,
      partition
    };
    customEndpointFunctions.aws = awsEndpointFunctions;
  }
});

// node_modules/@smithy/querystring-parser/dist-es/index.js
function parseQueryString(querystring) {
  const query = {};
  querystring = querystring.replace(/^\?/, "");
  if (querystring) {
    for (const pair of querystring.split("&")) {
      let [key, value = null] = pair.split("=");
      key = decodeURIComponent(key);
      if (value) {
        value = decodeURIComponent(value);
      }
      if (!(key in query)) {
        query[key] = value;
      } else if (Array.isArray(query[key])) {
        query[key].push(value);
      } else {
        query[key] = [query[key], value];
      }
    }
  }
  return query;
}
var init_dist_es31 = __esm({
  "node_modules/@smithy/querystring-parser/dist-es/index.js"() {
    "use strict";
  }
});

// node_modules/@smithy/url-parser/dist-es/index.js
var parseUrl;
var init_dist_es32 = __esm({
  "node_modules/@smithy/url-parser/dist-es/index.js"() {
    "use strict";
    init_dist_es31();
    parseUrl = (url) => {
      if (typeof url === "string") {
        return parseUrl(new URL(url));
      }
      const { hostname, pathname, port, protocol, search } = url;
      let query;
      if (search) {
        query = parseQueryString(search);
      }
      return {
        hostname,
        port: port ? parseInt(port) : void 0,
        protocol,
        path: pathname,
        query
      };
    };
  }
});

// node_modules/@aws-sdk/util-endpoints/dist-es/resolveDefaultAwsRegionalEndpointsConfig.js
var init_resolveDefaultAwsRegionalEndpointsConfig = __esm({
  "node_modules/@aws-sdk/util-endpoints/dist-es/resolveDefaultAwsRegionalEndpointsConfig.js"() {
    "use strict";
  }
});

// node_modules/@aws-sdk/util-endpoints/dist-es/resolveEndpoint.js
var init_resolveEndpoint2 = __esm({
  "node_modules/@aws-sdk/util-endpoints/dist-es/resolveEndpoint.js"() {
    "use strict";
  }
});

// node_modules/@aws-sdk/util-endpoints/dist-es/types/EndpointError.js
var init_EndpointError2 = __esm({
  "node_modules/@aws-sdk/util-endpoints/dist-es/types/EndpointError.js"() {
    "use strict";
  }
});

// node_modules/@aws-sdk/util-endpoints/dist-es/types/EndpointRuleObject.js
var init_EndpointRuleObject3 = __esm({
  "node_modules/@aws-sdk/util-endpoints/dist-es/types/EndpointRuleObject.js"() {
    "use strict";
  }
});

// node_modules/@aws-sdk/util-endpoints/dist-es/types/ErrorRuleObject.js
var init_ErrorRuleObject3 = __esm({
  "node_modules/@aws-sdk/util-endpoints/dist-es/types/ErrorRuleObject.js"() {
    "use strict";
  }
});

// node_modules/@aws-sdk/util-endpoints/dist-es/types/RuleSetObject.js
var init_RuleSetObject3 = __esm({
  "node_modules/@aws-sdk/util-endpoints/dist-es/types/RuleSetObject.js"() {
    "use strict";
  }
});

// node_modules/@aws-sdk/util-endpoints/dist-es/types/TreeRuleObject.js
var init_TreeRuleObject3 = __esm({
  "node_modules/@aws-sdk/util-endpoints/dist-es/types/TreeRuleObject.js"() {
    "use strict";
  }
});

// node_modules/@aws-sdk/util-endpoints/dist-es/types/shared.js
var init_shared3 = __esm({
  "node_modules/@aws-sdk/util-endpoints/dist-es/types/shared.js"() {
    "use strict";
  }
});

// node_modules/@aws-sdk/util-endpoints/dist-es/types/index.js
var init_types4 = __esm({
  "node_modules/@aws-sdk/util-endpoints/dist-es/types/index.js"() {
    "use strict";
    init_EndpointError2();
    init_EndpointRuleObject3();
    init_ErrorRuleObject3();
    init_RuleSetObject3();
    init_TreeRuleObject3();
    init_shared3();
  }
});

// node_modules/@aws-sdk/util-endpoints/dist-es/index.js
var init_dist_es33 = __esm({
  "node_modules/@aws-sdk/util-endpoints/dist-es/index.js"() {
    "use strict";
    init_aws();
    init_partition();
    init_isIpAddress2();
    init_resolveDefaultAwsRegionalEndpointsConfig();
    init_resolveEndpoint2();
    init_types4();
  }
});

// node_modules/@aws-sdk/middleware-user-agent/dist-es/check-features.js
async function checkFeatures(context, config, args) {
  const request = args.request;
  if (request?.headers?.["smithy-protocol"] === "rpc-v2-cbor") {
    setFeature(context, "PROTOCOL_RPC_V2_CBOR", "M");
  }
  if (typeof config.retryStrategy === "function") {
    const retryStrategy = await config.retryStrategy();
    if (typeof retryStrategy.acquireInitialRetryToken === "function") {
      if (retryStrategy.constructor?.name?.includes("Adaptive")) {
        setFeature(context, "RETRY_MODE_ADAPTIVE", "F");
      } else {
        setFeature(context, "RETRY_MODE_STANDARD", "E");
      }
    } else {
      setFeature(context, "RETRY_MODE_LEGACY", "D");
    }
  }
  if (typeof config.accountIdEndpointMode === "function") {
    const endpointV2 = context.endpointV2;
    if (String(endpointV2?.url?.hostname).match(ACCOUNT_ID_ENDPOINT_REGEX)) {
      setFeature(context, "ACCOUNT_ID_ENDPOINT", "O");
    }
    switch (await config.accountIdEndpointMode?.()) {
      case "disabled":
        setFeature(context, "ACCOUNT_ID_MODE_DISABLED", "Q");
        break;
      case "preferred":
        setFeature(context, "ACCOUNT_ID_MODE_PREFERRED", "P");
        break;
      case "required":
        setFeature(context, "ACCOUNT_ID_MODE_REQUIRED", "R");
        break;
    }
  }
  const identity = context.__smithy_context?.selectedHttpAuthScheme?.identity;
  if (identity?.$source) {
    const credentials = identity;
    if (credentials.accountId) {
      setFeature(context, "RESOLVED_ACCOUNT_ID", "T");
    }
    for (const [key, value] of Object.entries(credentials.$source ?? {})) {
      setFeature(context, key, value);
    }
  }
}
var ACCOUNT_ID_ENDPOINT_REGEX;
var init_check_features = __esm({
  "node_modules/@aws-sdk/middleware-user-agent/dist-es/check-features.js"() {
    "use strict";
    init_dist_es22();
    ACCOUNT_ID_ENDPOINT_REGEX = /\d{12}\.ddb/;
  }
});

// node_modules/@aws-sdk/middleware-user-agent/dist-es/constants.js
var USER_AGENT, X_AMZ_USER_AGENT, SPACE, UA_NAME_SEPARATOR, UA_NAME_ESCAPE_REGEX, UA_VALUE_ESCAPE_REGEX, UA_ESCAPE_CHAR;
var init_constants5 = __esm({
  "node_modules/@aws-sdk/middleware-user-agent/dist-es/constants.js"() {
    "use strict";
    USER_AGENT = "user-agent";
    X_AMZ_USER_AGENT = "x-amz-user-agent";
    SPACE = " ";
    UA_NAME_SEPARATOR = "/";
    UA_NAME_ESCAPE_REGEX = /[^!$%&'*+\-.^_`|~\w]/g;
    UA_VALUE_ESCAPE_REGEX = /[^!$%&'*+\-.^_`|~\w#]/g;
    UA_ESCAPE_CHAR = "-";
  }
});

// node_modules/@aws-sdk/middleware-user-agent/dist-es/encode-features.js
function encodeFeatures(features) {
  let buffer = "";
  for (const key in features) {
    const val = features[key];
    if (buffer.length + val.length + 1 <= BYTE_LIMIT) {
      if (buffer.length) {
        buffer += "," + val;
      } else {
        buffer += val;
      }
      continue;
    }
    break;
  }
  return buffer;
}
var BYTE_LIMIT;
var init_encode_features = __esm({
  "node_modules/@aws-sdk/middleware-user-agent/dist-es/encode-features.js"() {
    "use strict";
    BYTE_LIMIT = 1024;
  }
});

// node_modules/@aws-sdk/middleware-user-agent/dist-es/user-agent-middleware.js
var userAgentMiddleware, escapeUserAgent, getUserAgentMiddlewareOptions, getUserAgentPlugin;
var init_user_agent_middleware = __esm({
  "node_modules/@aws-sdk/middleware-user-agent/dist-es/user-agent-middleware.js"() {
    "use strict";
    init_dist_es33();
    init_dist_es2();
    init_check_features();
    init_constants5();
    init_encode_features();
    userAgentMiddleware = (options) => (next, context) => async (args) => {
      const { request } = args;
      if (!HttpRequest.isInstance(request)) {
        return next(args);
      }
      const { headers } = request;
      const userAgent = context?.userAgent?.map(escapeUserAgent) || [];
      const defaultUserAgent = (await options.defaultUserAgentProvider()).map(escapeUserAgent);
      await checkFeatures(context, options, args);
      const awsContext = context;
      defaultUserAgent.push(`m/${encodeFeatures(Object.assign({}, context.__smithy_context?.features, awsContext.__aws_sdk_context?.features))}`);
      const customUserAgent = options?.customUserAgent?.map(escapeUserAgent) || [];
      const appId = await options.userAgentAppId();
      if (appId) {
        defaultUserAgent.push(escapeUserAgent([`app`, `${appId}`]));
      }
      const prefix = getUserAgentPrefix();
      const sdkUserAgentValue = (prefix ? [prefix] : []).concat([...defaultUserAgent, ...userAgent, ...customUserAgent]).join(SPACE);
      const normalUAValue = [
        ...defaultUserAgent.filter((section) => section.startsWith("aws-sdk-")),
        ...customUserAgent
      ].join(SPACE);
      if (options.runtime !== "browser") {
        if (normalUAValue) {
          headers[X_AMZ_USER_AGENT] = headers[X_AMZ_USER_AGENT] ? `${headers[USER_AGENT]} ${normalUAValue}` : normalUAValue;
        }
        headers[USER_AGENT] = sdkUserAgentValue;
      } else {
        headers[X_AMZ_USER_AGENT] = sdkUserAgentValue;
      }
      return next({
        ...args,
        request
      });
    };
    escapeUserAgent = (userAgentPair) => {
      const name = userAgentPair[0].split(UA_NAME_SEPARATOR).map((part) => part.replace(UA_NAME_ESCAPE_REGEX, UA_ESCAPE_CHAR)).join(UA_NAME_SEPARATOR);
      const version = userAgentPair[1]?.replace(UA_VALUE_ESCAPE_REGEX, UA_ESCAPE_CHAR);
      const prefixSeparatorIndex = name.indexOf(UA_NAME_SEPARATOR);
      const prefix = name.substring(0, prefixSeparatorIndex);
      let uaName = name.substring(prefixSeparatorIndex + 1);
      if (prefix === "api") {
        uaName = uaName.toLowerCase();
      }
      return [prefix, uaName, version].filter((item) => item && item.length > 0).reduce((acc, item, index) => {
        switch (index) {
          case 0:
            return item;
          case 1:
            return `${acc}/${item}`;
          default:
            return `${acc}#${item}`;
        }
      }, "");
    };
    getUserAgentMiddlewareOptions = {
      name: "getUserAgentMiddleware",
      step: "build",
      priority: "low",
      tags: ["SET_USER_AGENT", "USER_AGENT"],
      override: true
    };
    getUserAgentPlugin = (config) => ({
      applyToStack: (clientStack) => {
        clientStack.add(userAgentMiddleware(config), getUserAgentMiddlewareOptions);
      }
    });
  }
});

// node_modules/@aws-sdk/middleware-user-agent/dist-es/index.js
var init_dist_es34 = __esm({
  "node_modules/@aws-sdk/middleware-user-agent/dist-es/index.js"() {
    "use strict";
    init_configurations();
    init_user_agent_middleware();
  }
});

// node_modules/@smithy/config-resolver/dist-es/endpointsConfig/NodeUseDualstackEndpointConfigOptions.js
var DEFAULT_USE_DUALSTACK_ENDPOINT;
var init_NodeUseDualstackEndpointConfigOptions = __esm({
  "node_modules/@smithy/config-resolver/dist-es/endpointsConfig/NodeUseDualstackEndpointConfigOptions.js"() {
    "use strict";
    DEFAULT_USE_DUALSTACK_ENDPOINT = false;
  }
});

// node_modules/@smithy/config-resolver/dist-es/endpointsConfig/NodeUseFipsEndpointConfigOptions.js
var DEFAULT_USE_FIPS_ENDPOINT;
var init_NodeUseFipsEndpointConfigOptions = __esm({
  "node_modules/@smithy/config-resolver/dist-es/endpointsConfig/NodeUseFipsEndpointConfigOptions.js"() {
    "use strict";
    DEFAULT_USE_FIPS_ENDPOINT = false;
  }
});

// node_modules/@smithy/config-resolver/dist-es/endpointsConfig/resolveCustomEndpointsConfig.js
var init_resolveCustomEndpointsConfig = __esm({
  "node_modules/@smithy/config-resolver/dist-es/endpointsConfig/resolveCustomEndpointsConfig.js"() {
    "use strict";
  }
});

// node_modules/@smithy/config-resolver/dist-es/endpointsConfig/resolveEndpointsConfig.js
var init_resolveEndpointsConfig = __esm({
  "node_modules/@smithy/config-resolver/dist-es/endpointsConfig/resolveEndpointsConfig.js"() {
    "use strict";
  }
});

// node_modules/@smithy/config-resolver/dist-es/endpointsConfig/index.js
var init_endpointsConfig = __esm({
  "node_modules/@smithy/config-resolver/dist-es/endpointsConfig/index.js"() {
    "use strict";
    init_NodeUseDualstackEndpointConfigOptions();
    init_NodeUseFipsEndpointConfigOptions();
    init_resolveCustomEndpointsConfig();
    init_resolveEndpointsConfig();
  }
});

// node_modules/@smithy/config-resolver/dist-es/regionConfig/config.js
var init_config2 = __esm({
  "node_modules/@smithy/config-resolver/dist-es/regionConfig/config.js"() {
    "use strict";
  }
});

// node_modules/@smithy/config-resolver/dist-es/regionConfig/checkRegion.js
var validRegions, checkRegion;
var init_checkRegion = __esm({
  "node_modules/@smithy/config-resolver/dist-es/regionConfig/checkRegion.js"() {
    "use strict";
    init_dist_es30();
    validRegions = /* @__PURE__ */ new Set();
    checkRegion = (region, check = isValidHostLabel) => {
      if (!validRegions.has(region) && !check(region)) {
        if (region === "*") {
          console.warn(`@smithy/config-resolver WARN - Please use the caller region instead of "*". See "sigv4a" in https://github.com/aws/aws-sdk-js-v3/blob/main/supplemental-docs/CLIENTS.md.`);
        } else {
          throw new Error(`Region not accepted: region="${region}" is not a valid hostname component.`);
        }
      } else {
        validRegions.add(region);
      }
    };
  }
});

// node_modules/@smithy/config-resolver/dist-es/regionConfig/isFipsRegion.js
var isFipsRegion;
var init_isFipsRegion = __esm({
  "node_modules/@smithy/config-resolver/dist-es/regionConfig/isFipsRegion.js"() {
    "use strict";
    isFipsRegion = (region) => typeof region === "string" && (region.startsWith("fips-") || region.endsWith("-fips"));
  }
});

// node_modules/@smithy/config-resolver/dist-es/regionConfig/getRealRegion.js
var getRealRegion;
var init_getRealRegion = __esm({
  "node_modules/@smithy/config-resolver/dist-es/regionConfig/getRealRegion.js"() {
    "use strict";
    init_isFipsRegion();
    getRealRegion = (region) => isFipsRegion(region) ? ["fips-aws-global", "aws-fips"].includes(region) ? "us-east-1" : region.replace(/fips-(dkr-|prod-)?|-fips/, "") : region;
  }
});

// node_modules/@smithy/config-resolver/dist-es/regionConfig/resolveRegionConfig.js
var resolveRegionConfig;
var init_resolveRegionConfig = __esm({
  "node_modules/@smithy/config-resolver/dist-es/regionConfig/resolveRegionConfig.js"() {
    "use strict";
    init_checkRegion();
    init_getRealRegion();
    init_isFipsRegion();
    resolveRegionConfig = (input) => {
      const { region, useFipsEndpoint } = input;
      if (!region) {
        throw new Error("Region is missing");
      }
      return Object.assign(input, {
        region: async () => {
          const providedRegion = typeof region === "function" ? await region() : region;
          const realRegion = getRealRegion(providedRegion);
          checkRegion(realRegion);
          return realRegion;
        },
        useFipsEndpoint: async () => {
          const providedRegion = typeof region === "string" ? region : await region();
          if (isFipsRegion(providedRegion)) {
            return true;
          }
          return typeof useFipsEndpoint !== "function" ? Promise.resolve(!!useFipsEndpoint) : useFipsEndpoint();
        }
      });
    };
  }
});

// node_modules/@smithy/config-resolver/dist-es/regionConfig/index.js
var init_regionConfig = __esm({
  "node_modules/@smithy/config-resolver/dist-es/regionConfig/index.js"() {
    "use strict";
    init_config2();
    init_resolveRegionConfig();
  }
});

// node_modules/@smithy/config-resolver/dist-es/regionInfo/PartitionHash.js
var init_PartitionHash = __esm({
  "node_modules/@smithy/config-resolver/dist-es/regionInfo/PartitionHash.js"() {
    "use strict";
  }
});

// node_modules/@smithy/config-resolver/dist-es/regionInfo/RegionHash.js
var init_RegionHash = __esm({
  "node_modules/@smithy/config-resolver/dist-es/regionInfo/RegionHash.js"() {
    "use strict";
  }
});

// node_modules/@smithy/config-resolver/dist-es/regionInfo/getRegionInfo.js
var init_getRegionInfo = __esm({
  "node_modules/@smithy/config-resolver/dist-es/regionInfo/getRegionInfo.js"() {
    "use strict";
  }
});

// node_modules/@smithy/config-resolver/dist-es/regionInfo/index.js
var init_regionInfo = __esm({
  "node_modules/@smithy/config-resolver/dist-es/regionInfo/index.js"() {
    "use strict";
    init_PartitionHash();
    init_RegionHash();
    init_getRegionInfo();
  }
});

// node_modules/@smithy/config-resolver/dist-es/index.js
var init_dist_es35 = __esm({
  "node_modules/@smithy/config-resolver/dist-es/index.js"() {
    "use strict";
    init_endpointsConfig();
    init_regionConfig();
    init_regionInfo();
  }
});

// node_modules/@smithy/eventstream-serde-config-resolver/dist-es/EventStreamSerdeConfig.js
var resolveEventStreamSerdeConfig;
var init_EventStreamSerdeConfig = __esm({
  "node_modules/@smithy/eventstream-serde-config-resolver/dist-es/EventStreamSerdeConfig.js"() {
    "use strict";
    resolveEventStreamSerdeConfig = (input) => Object.assign(input, {
      eventStreamMarshaller: input.eventStreamSerdeProvider(input)
    });
  }
});

// node_modules/@smithy/eventstream-serde-config-resolver/dist-es/index.js
var init_dist_es36 = __esm({
  "node_modules/@smithy/eventstream-serde-config-resolver/dist-es/index.js"() {
    "use strict";
    init_EventStreamSerdeConfig();
  }
});

// node_modules/@smithy/middleware-content-length/dist-es/index.js
function contentLengthMiddleware(bodyLengthChecker) {
  return (next) => async (args) => {
    const request = args.request;
    if (HttpRequest.isInstance(request)) {
      const { body, headers } = request;
      if (body && Object.keys(headers).map((str) => str.toLowerCase()).indexOf(CONTENT_LENGTH_HEADER2) === -1) {
        try {
          const length = bodyLengthChecker(body);
          request.headers = {
            ...request.headers,
            [CONTENT_LENGTH_HEADER2]: String(length)
          };
        } catch (error) {
        }
      }
    }
    return next({
      ...args,
      request
    });
  };
}
var CONTENT_LENGTH_HEADER2, contentLengthMiddlewareOptions, getContentLengthPlugin;
var init_dist_es37 = __esm({
  "node_modules/@smithy/middleware-content-length/dist-es/index.js"() {
    "use strict";
    init_dist_es2();
    CONTENT_LENGTH_HEADER2 = "content-length";
    contentLengthMiddlewareOptions = {
      step: "build",
      tags: ["SET_CONTENT_LENGTH", "CONTENT_LENGTH"],
      name: "contentLengthMiddleware",
      override: true
    };
    getContentLengthPlugin = (options) => ({
      applyToStack: (clientStack) => {
        clientStack.add(contentLengthMiddleware(options.bodyLengthChecker), contentLengthMiddlewareOptions);
      }
    });
  }
});

// node_modules/@smithy/middleware-endpoint/dist-es/service-customizations/s3.js
var resolveParamsForS3, DOMAIN_PATTERN, IP_ADDRESS_PATTERN, DOTS_PATTERN, isDnsCompatibleBucketName, isArnBucketName;
var init_s3 = __esm({
  "node_modules/@smithy/middleware-endpoint/dist-es/service-customizations/s3.js"() {
    "use strict";
    resolveParamsForS3 = async (endpointParams) => {
      const bucket = endpointParams?.Bucket || "";
      if (typeof endpointParams.Bucket === "string") {
        endpointParams.Bucket = bucket.replace(/#/g, encodeURIComponent("#")).replace(/\?/g, encodeURIComponent("?"));
      }
      if (isArnBucketName(bucket)) {
        if (endpointParams.ForcePathStyle === true) {
          throw new Error("Path-style addressing cannot be used with ARN buckets");
        }
      } else if (!isDnsCompatibleBucketName(bucket) || bucket.indexOf(".") !== -1 && !String(endpointParams.Endpoint).startsWith("http:") || bucket.toLowerCase() !== bucket || bucket.length < 3) {
        endpointParams.ForcePathStyle = true;
      }
      if (endpointParams.DisableMultiRegionAccessPoints) {
        endpointParams.disableMultiRegionAccessPoints = true;
        endpointParams.DisableMRAP = true;
      }
      return endpointParams;
    };
    DOMAIN_PATTERN = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/;
    IP_ADDRESS_PATTERN = /(\d+\.){3}\d+/;
    DOTS_PATTERN = /\.\./;
    isDnsCompatibleBucketName = (bucketName) => DOMAIN_PATTERN.test(bucketName) && !IP_ADDRESS_PATTERN.test(bucketName) && !DOTS_PATTERN.test(bucketName);
    isArnBucketName = (bucketName) => {
      const [arn, partition2, service, , , bucket] = bucketName.split(":");
      const isArn = arn === "arn" && bucketName.split(":").length >= 6;
      const isValidArn = Boolean(isArn && partition2 && service && bucket);
      if (isArn && !isValidArn) {
        throw new Error(`Invalid ARN: ${bucketName} was an invalid ARN.`);
      }
      return isValidArn;
    };
  }
});

// node_modules/@smithy/middleware-endpoint/dist-es/service-customizations/index.js
var init_service_customizations = __esm({
  "node_modules/@smithy/middleware-endpoint/dist-es/service-customizations/index.js"() {
    "use strict";
    init_s3();
  }
});

// node_modules/@smithy/middleware-endpoint/dist-es/adaptors/createConfigValueProvider.js
var createConfigValueProvider;
var init_createConfigValueProvider = __esm({
  "node_modules/@smithy/middleware-endpoint/dist-es/adaptors/createConfigValueProvider.js"() {
    "use strict";
    createConfigValueProvider = (configKey, canonicalEndpointParamKey, config) => {
      const configProvider = async () => {
        const configValue = config[configKey] ?? config[canonicalEndpointParamKey];
        if (typeof configValue === "function") {
          return configValue();
        }
        return configValue;
      };
      if (configKey === "credentialScope" || canonicalEndpointParamKey === "CredentialScope") {
        return async () => {
          const credentials = typeof config.credentials === "function" ? await config.credentials() : config.credentials;
          const configValue = credentials?.credentialScope ?? credentials?.CredentialScope;
          return configValue;
        };
      }
      if (configKey === "accountId" || canonicalEndpointParamKey === "AccountId") {
        return async () => {
          const credentials = typeof config.credentials === "function" ? await config.credentials() : config.credentials;
          const configValue = credentials?.accountId ?? credentials?.AccountId;
          return configValue;
        };
      }
      if (configKey === "endpoint" || canonicalEndpointParamKey === "endpoint") {
        return async () => {
          if (config.isCustomEndpoint === false) {
            return void 0;
          }
          const endpoint = await configProvider();
          if (endpoint && typeof endpoint === "object") {
            if ("url" in endpoint) {
              return endpoint.url.href;
            }
            if ("hostname" in endpoint) {
              const { protocol, hostname, port, path } = endpoint;
              return `${protocol}//${hostname}${port ? ":" + port : ""}${path}`;
            }
          }
          return endpoint;
        };
      }
      return configProvider;
    };
  }
});

// node_modules/@smithy/middleware-endpoint/dist-es/adaptors/getEndpointFromConfig.browser.js
var getEndpointFromConfig;
var init_getEndpointFromConfig_browser = __esm({
  "node_modules/@smithy/middleware-endpoint/dist-es/adaptors/getEndpointFromConfig.browser.js"() {
    "use strict";
    getEndpointFromConfig = async (serviceId) => void 0;
  }
});

// node_modules/@smithy/middleware-endpoint/dist-es/adaptors/toEndpointV1.js
var toEndpointV1;
var init_toEndpointV1 = __esm({
  "node_modules/@smithy/middleware-endpoint/dist-es/adaptors/toEndpointV1.js"() {
    "use strict";
    init_dist_es32();
    toEndpointV1 = (endpoint) => {
      if (typeof endpoint === "object") {
        if ("url" in endpoint) {
          return parseUrl(endpoint.url);
        }
        return endpoint;
      }
      return parseUrl(endpoint);
    };
  }
});

// node_modules/@smithy/middleware-endpoint/dist-es/adaptors/getEndpointFromInstructions.js
var getEndpointFromInstructions, resolveParams;
var init_getEndpointFromInstructions = __esm({
  "node_modules/@smithy/middleware-endpoint/dist-es/adaptors/getEndpointFromInstructions.js"() {
    "use strict";
    init_service_customizations();
    init_createConfigValueProvider();
    init_getEndpointFromConfig_browser();
    init_toEndpointV1();
    getEndpointFromInstructions = async (commandInput, instructionsSupplier, clientConfig, context) => {
      if (!clientConfig.isCustomEndpoint) {
        let endpointFromConfig;
        if (clientConfig.serviceConfiguredEndpoint) {
          endpointFromConfig = await clientConfig.serviceConfiguredEndpoint();
        } else {
          endpointFromConfig = await getEndpointFromConfig(clientConfig.serviceId);
        }
        if (endpointFromConfig) {
          clientConfig.endpoint = () => Promise.resolve(toEndpointV1(endpointFromConfig));
          clientConfig.isCustomEndpoint = true;
        }
      }
      const endpointParams = await resolveParams(commandInput, instructionsSupplier, clientConfig);
      if (typeof clientConfig.endpointProvider !== "function") {
        throw new Error("config.endpointProvider is not set.");
      }
      const endpoint = clientConfig.endpointProvider(endpointParams, context);
      return endpoint;
    };
    resolveParams = async (commandInput, instructionsSupplier, clientConfig) => {
      const endpointParams = {};
      const instructions = instructionsSupplier?.getEndpointParameterInstructions?.() || {};
      for (const [name, instruction] of Object.entries(instructions)) {
        switch (instruction.type) {
          case "staticContextParams":
            endpointParams[name] = instruction.value;
            break;
          case "contextParams":
            endpointParams[name] = commandInput[instruction.name];
            break;
          case "clientContextParams":
          case "builtInParams":
            endpointParams[name] = await createConfigValueProvider(instruction.name, name, clientConfig)();
            break;
          case "operationContextParams":
            endpointParams[name] = instruction.get(commandInput);
            break;
          default:
            throw new Error("Unrecognized endpoint parameter instruction: " + JSON.stringify(instruction));
        }
      }
      if (Object.keys(instructions).length === 0) {
        Object.assign(endpointParams, clientConfig);
      }
      if (String(clientConfig.serviceId).toLowerCase() === "s3") {
        await resolveParamsForS3(endpointParams);
      }
      return endpointParams;
    };
  }
});

// node_modules/@smithy/middleware-endpoint/dist-es/adaptors/index.js
var init_adaptors = __esm({
  "node_modules/@smithy/middleware-endpoint/dist-es/adaptors/index.js"() {
    "use strict";
    init_getEndpointFromInstructions();
    init_toEndpointV1();
  }
});

// node_modules/@smithy/middleware-endpoint/dist-es/endpointMiddleware.js
var endpointMiddleware;
var init_endpointMiddleware = __esm({
  "node_modules/@smithy/middleware-endpoint/dist-es/endpointMiddleware.js"() {
    "use strict";
    init_dist_es14();
    init_dist_es4();
    init_getEndpointFromInstructions();
    endpointMiddleware = ({ config, instructions }) => {
      return (next, context) => async (args) => {
        if (config.isCustomEndpoint) {
          setFeature2(context, "ENDPOINT_OVERRIDE", "N");
        }
        const endpoint = await getEndpointFromInstructions(args.input, {
          getEndpointParameterInstructions() {
            return instructions;
          }
        }, { ...config }, context);
        context.endpointV2 = endpoint;
        context.authSchemes = endpoint.properties?.authSchemes;
        const authScheme = context.authSchemes?.[0];
        if (authScheme) {
          context["signing_region"] = authScheme.signingRegion;
          context["signing_service"] = authScheme.signingName;
          const smithyContext = getSmithyContext(context);
          const httpAuthOption = smithyContext?.selectedHttpAuthScheme?.httpAuthOption;
          if (httpAuthOption) {
            httpAuthOption.signingProperties = Object.assign(httpAuthOption.signingProperties || {}, {
              signing_region: authScheme.signingRegion,
              signingRegion: authScheme.signingRegion,
              signing_service: authScheme.signingName,
              signingName: authScheme.signingName,
              signingRegionSet: authScheme.signingRegionSet
            }, authScheme.properties);
          }
        }
        return next({
          ...args
        });
      };
    };
  }
});

// node_modules/@smithy/middleware-endpoint/dist-es/getEndpointPlugin.js
var endpointMiddlewareOptions, getEndpointPlugin;
var init_getEndpointPlugin = __esm({
  "node_modules/@smithy/middleware-endpoint/dist-es/getEndpointPlugin.js"() {
    "use strict";
    init_dist_es5();
    init_endpointMiddleware();
    endpointMiddlewareOptions = {
      step: "serialize",
      tags: ["ENDPOINT_PARAMETERS", "ENDPOINT_V2", "ENDPOINT"],
      name: "endpointV2Middleware",
      override: true,
      relation: "before",
      toMiddleware: serializerMiddlewareOption.name
    };
    getEndpointPlugin = (config, instructions) => ({
      applyToStack: (clientStack) => {
        clientStack.addRelativeTo(endpointMiddleware({
          config,
          instructions
        }), endpointMiddlewareOptions);
      }
    });
  }
});

// node_modules/@smithy/middleware-endpoint/dist-es/resolveEndpointConfig.js
var resolveEndpointConfig;
var init_resolveEndpointConfig = __esm({
  "node_modules/@smithy/middleware-endpoint/dist-es/resolveEndpointConfig.js"() {
    "use strict";
    init_dist_es4();
    init_getEndpointFromConfig_browser();
    init_toEndpointV1();
    resolveEndpointConfig = (input) => {
      const tls = input.tls ?? true;
      const { endpoint, useDualstackEndpoint, useFipsEndpoint } = input;
      const customEndpointProvider = endpoint != null ? async () => toEndpointV1(await normalizeProvider(endpoint)()) : void 0;
      const isCustomEndpoint = !!endpoint;
      const resolvedConfig = Object.assign(input, {
        endpoint: customEndpointProvider,
        tls,
        isCustomEndpoint,
        useDualstackEndpoint: normalizeProvider(useDualstackEndpoint ?? false),
        useFipsEndpoint: normalizeProvider(useFipsEndpoint ?? false)
      });
      let configuredEndpointPromise = void 0;
      resolvedConfig.serviceConfiguredEndpoint = async () => {
        if (input.serviceId && !configuredEndpointPromise) {
          configuredEndpointPromise = getEndpointFromConfig(input.serviceId);
        }
        return configuredEndpointPromise;
      };
      return resolvedConfig;
    };
  }
});

// node_modules/@smithy/middleware-endpoint/dist-es/resolveEndpointRequiredConfig.js
var init_resolveEndpointRequiredConfig = __esm({
  "node_modules/@smithy/middleware-endpoint/dist-es/resolveEndpointRequiredConfig.js"() {
    "use strict";
  }
});

// node_modules/@smithy/middleware-endpoint/dist-es/types.js
var init_types5 = __esm({
  "node_modules/@smithy/middleware-endpoint/dist-es/types.js"() {
    "use strict";
  }
});

// node_modules/@smithy/middleware-endpoint/dist-es/index.js
var init_dist_es38 = __esm({
  "node_modules/@smithy/middleware-endpoint/dist-es/index.js"() {
    "use strict";
    init_adaptors();
    init_endpointMiddleware();
    init_getEndpointPlugin();
    init_resolveEndpointConfig();
    init_resolveEndpointRequiredConfig();
    init_types5();
  }
});

// node_modules/@smithy/util-retry/dist-es/config.js
var RETRY_MODES, DEFAULT_MAX_ATTEMPTS, DEFAULT_RETRY_MODE;
var init_config3 = __esm({
  "node_modules/@smithy/util-retry/dist-es/config.js"() {
    "use strict";
    (function(RETRY_MODES2) {
      RETRY_MODES2["STANDARD"] = "standard";
      RETRY_MODES2["ADAPTIVE"] = "adaptive";
    })(RETRY_MODES || (RETRY_MODES = {}));
    DEFAULT_MAX_ATTEMPTS = 3;
    DEFAULT_RETRY_MODE = RETRY_MODES.STANDARD;
  }
});

// node_modules/@smithy/service-error-classification/dist-es/constants.js
var THROTTLING_ERROR_CODES, TRANSIENT_ERROR_CODES, TRANSIENT_ERROR_STATUS_CODES, NODEJS_TIMEOUT_ERROR_CODES, NODEJS_NETWORK_ERROR_CODES;
var init_constants6 = __esm({
  "node_modules/@smithy/service-error-classification/dist-es/constants.js"() {
    "use strict";
    THROTTLING_ERROR_CODES = [
      "BandwidthLimitExceeded",
      "EC2ThrottledException",
      "LimitExceededException",
      "PriorRequestNotComplete",
      "ProvisionedThroughputExceededException",
      "RequestLimitExceeded",
      "RequestThrottled",
      "RequestThrottledException",
      "SlowDown",
      "ThrottledException",
      "Throttling",
      "ThrottlingException",
      "TooManyRequestsException",
      "TransactionInProgressException"
    ];
    TRANSIENT_ERROR_CODES = ["TimeoutError", "RequestTimeout", "RequestTimeoutException"];
    TRANSIENT_ERROR_STATUS_CODES = [500, 502, 503, 504];
    NODEJS_TIMEOUT_ERROR_CODES = ["ECONNRESET", "ECONNREFUSED", "EPIPE", "ETIMEDOUT"];
    NODEJS_NETWORK_ERROR_CODES = ["EHOSTUNREACH", "ENETUNREACH", "ENOTFOUND"];
  }
});

// node_modules/@smithy/service-error-classification/dist-es/index.js
var isRetryableByTrait, isClockSkewCorrectedError, isBrowserNetworkError, isThrottlingError, isTransientError, isServerError;
var init_dist_es39 = __esm({
  "node_modules/@smithy/service-error-classification/dist-es/index.js"() {
    "use strict";
    init_constants6();
    isRetryableByTrait = (error) => error?.$retryable !== void 0;
    isClockSkewCorrectedError = (error) => error.$metadata?.clockSkewCorrected;
    isBrowserNetworkError = (error) => {
      const errorMessages = /* @__PURE__ */ new Set([
        "Failed to fetch",
        "NetworkError when attempting to fetch resource",
        "The Internet connection appears to be offline",
        "Load failed",
        "Network request failed"
      ]);
      const isValid = error && error instanceof TypeError;
      if (!isValid) {
        return false;
      }
      return errorMessages.has(error.message);
    };
    isThrottlingError = (error) => error.$metadata?.httpStatusCode === 429 || THROTTLING_ERROR_CODES.includes(error.name) || error.$retryable?.throttling == true;
    isTransientError = (error, depth = 0) => isRetryableByTrait(error) || isClockSkewCorrectedError(error) || TRANSIENT_ERROR_CODES.includes(error.name) || NODEJS_TIMEOUT_ERROR_CODES.includes(error?.code || "") || NODEJS_NETWORK_ERROR_CODES.includes(error?.code || "") || TRANSIENT_ERROR_STATUS_CODES.includes(error.$metadata?.httpStatusCode || 0) || isBrowserNetworkError(error) || error.cause !== void 0 && depth <= 10 && isTransientError(error.cause, depth + 1);
    isServerError = (error) => {
      if (error.$metadata?.httpStatusCode !== void 0) {
        const statusCode = error.$metadata.httpStatusCode;
        if (500 <= statusCode && statusCode <= 599 && !isTransientError(error)) {
          return true;
        }
        return false;
      }
      return false;
    };
  }
});

// node_modules/@smithy/util-retry/dist-es/DefaultRateLimiter.js
var DefaultRateLimiter;
var init_DefaultRateLimiter = __esm({
  "node_modules/@smithy/util-retry/dist-es/DefaultRateLimiter.js"() {
    "use strict";
    init_dist_es39();
    DefaultRateLimiter = class _DefaultRateLimiter {
      static setTimeoutFn = setTimeout;
      beta;
      minCapacity;
      minFillRate;
      scaleConstant;
      smooth;
      currentCapacity = 0;
      enabled = false;
      lastMaxRate = 0;
      measuredTxRate = 0;
      requestCount = 0;
      fillRate;
      lastThrottleTime;
      lastTimestamp = 0;
      lastTxRateBucket;
      maxCapacity;
      timeWindow = 0;
      constructor(options) {
        this.beta = options?.beta ?? 0.7;
        this.minCapacity = options?.minCapacity ?? 1;
        this.minFillRate = options?.minFillRate ?? 0.5;
        this.scaleConstant = options?.scaleConstant ?? 0.4;
        this.smooth = options?.smooth ?? 0.8;
        const currentTimeInSeconds = this.getCurrentTimeInSeconds();
        this.lastThrottleTime = currentTimeInSeconds;
        this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds());
        this.fillRate = this.minFillRate;
        this.maxCapacity = this.minCapacity;
      }
      getCurrentTimeInSeconds() {
        return Date.now() / 1e3;
      }
      async getSendToken() {
        return this.acquireTokenBucket(1);
      }
      async acquireTokenBucket(amount) {
        if (!this.enabled) {
          return;
        }
        this.refillTokenBucket();
        if (amount > this.currentCapacity) {
          const delay = (amount - this.currentCapacity) / this.fillRate * 1e3;
          await new Promise((resolve) => _DefaultRateLimiter.setTimeoutFn(resolve, delay));
        }
        this.currentCapacity = this.currentCapacity - amount;
      }
      refillTokenBucket() {
        const timestamp = this.getCurrentTimeInSeconds();
        if (!this.lastTimestamp) {
          this.lastTimestamp = timestamp;
          return;
        }
        const fillAmount = (timestamp - this.lastTimestamp) * this.fillRate;
        this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + fillAmount);
        this.lastTimestamp = timestamp;
      }
      updateClientSendingRate(response) {
        let calculatedRate;
        this.updateMeasuredRate();
        if (isThrottlingError(response)) {
          const rateToUse = !this.enabled ? this.measuredTxRate : Math.min(this.measuredTxRate, this.fillRate);
          this.lastMaxRate = rateToUse;
          this.calculateTimeWindow();
          this.lastThrottleTime = this.getCurrentTimeInSeconds();
          calculatedRate = this.cubicThrottle(rateToUse);
          this.enableTokenBucket();
        } else {
          this.calculateTimeWindow();
          calculatedRate = this.cubicSuccess(this.getCurrentTimeInSeconds());
        }
        const newRate = Math.min(calculatedRate, 2 * this.measuredTxRate);
        this.updateTokenBucketRate(newRate);
      }
      calculateTimeWindow() {
        this.timeWindow = this.getPrecise(Math.pow(this.lastMaxRate * (1 - this.beta) / this.scaleConstant, 1 / 3));
      }
      cubicThrottle(rateToUse) {
        return this.getPrecise(rateToUse * this.beta);
      }
      cubicSuccess(timestamp) {
        return this.getPrecise(this.scaleConstant * Math.pow(timestamp - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate);
      }
      enableTokenBucket() {
        this.enabled = true;
      }
      updateTokenBucketRate(newRate) {
        this.refillTokenBucket();
        this.fillRate = Math.max(newRate, this.minFillRate);
        this.maxCapacity = Math.max(newRate, this.minCapacity);
        this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity);
      }
      updateMeasuredRate() {
        const t2 = this.getCurrentTimeInSeconds();
        const timeBucket = Math.floor(t2 * 2) / 2;
        this.requestCount++;
        if (timeBucket > this.lastTxRateBucket) {
          const currentRate = this.requestCount / (timeBucket - this.lastTxRateBucket);
          this.measuredTxRate = this.getPrecise(currentRate * this.smooth + this.measuredTxRate * (1 - this.smooth));
          this.requestCount = 0;
          this.lastTxRateBucket = timeBucket;
        }
      }
      getPrecise(num) {
        return parseFloat(num.toFixed(8));
      }
    };
  }
});

// node_modules/@smithy/util-retry/dist-es/constants.js
var DEFAULT_RETRY_DELAY_BASE, MAXIMUM_RETRY_DELAY, THROTTLING_RETRY_DELAY_BASE, INITIAL_RETRY_TOKENS, RETRY_COST, TIMEOUT_RETRY_COST, NO_RETRY_INCREMENT, INVOCATION_ID_HEADER, REQUEST_HEADER;
var init_constants7 = __esm({
  "node_modules/@smithy/util-retry/dist-es/constants.js"() {
    "use strict";
    DEFAULT_RETRY_DELAY_BASE = 100;
    MAXIMUM_RETRY_DELAY = 20 * 1e3;
    THROTTLING_RETRY_DELAY_BASE = 500;
    INITIAL_RETRY_TOKENS = 500;
    RETRY_COST = 5;
    TIMEOUT_RETRY_COST = 10;
    NO_RETRY_INCREMENT = 1;
    INVOCATION_ID_HEADER = "amz-sdk-invocation-id";
    REQUEST_HEADER = "amz-sdk-request";
  }
});

// node_modules/@smithy/util-retry/dist-es/defaultRetryBackoffStrategy.js
var getDefaultRetryBackoffStrategy;
var init_defaultRetryBackoffStrategy = __esm({
  "node_modules/@smithy/util-retry/dist-es/defaultRetryBackoffStrategy.js"() {
    "use strict";
    init_constants7();
    getDefaultRetryBackoffStrategy = () => {
      let delayBase = DEFAULT_RETRY_DELAY_BASE;
      const computeNextBackoffDelay = (attempts) => {
        return Math.floor(Math.min(MAXIMUM_RETRY_DELAY, Math.random() * 2 ** attempts * delayBase));
      };
      const setDelayBase = (delay) => {
        delayBase = delay;
      };
      return {
        computeNextBackoffDelay,
        setDelayBase
      };
    };
  }
});

// node_modules/@smithy/util-retry/dist-es/defaultRetryToken.js
var createDefaultRetryToken;
var init_defaultRetryToken = __esm({
  "node_modules/@smithy/util-retry/dist-es/defaultRetryToken.js"() {
    "use strict";
    init_constants7();
    createDefaultRetryToken = ({ retryDelay, retryCount, retryCost }) => {
      const getRetryCount = () => retryCount;
      const getRetryDelay = () => Math.min(MAXIMUM_RETRY_DELAY, retryDelay);
      const getRetryCost = () => retryCost;
      return {
        getRetryCount,
        getRetryDelay,
        getRetryCost
      };
    };
  }
});

// node_modules/@smithy/util-retry/dist-es/StandardRetryStrategy.js
var StandardRetryStrategy;
var init_StandardRetryStrategy = __esm({
  "node_modules/@smithy/util-retry/dist-es/StandardRetryStrategy.js"() {
    "use strict";
    init_config3();
    init_constants7();
    init_defaultRetryBackoffStrategy();
    init_defaultRetryToken();
    StandardRetryStrategy = class {
      maxAttempts;
      mode = RETRY_MODES.STANDARD;
      capacity = INITIAL_RETRY_TOKENS;
      retryBackoffStrategy = getDefaultRetryBackoffStrategy();
      maxAttemptsProvider;
      constructor(maxAttempts) {
        this.maxAttempts = maxAttempts;
        this.maxAttemptsProvider = typeof maxAttempts === "function" ? maxAttempts : async () => maxAttempts;
      }
      async acquireInitialRetryToken(retryTokenScope) {
        return createDefaultRetryToken({
          retryDelay: DEFAULT_RETRY_DELAY_BASE,
          retryCount: 0
        });
      }
      async refreshRetryTokenForRetry(token, errorInfo) {
        const maxAttempts = await this.getMaxAttempts();
        if (this.shouldRetry(token, errorInfo, maxAttempts)) {
          const errorType = errorInfo.errorType;
          this.retryBackoffStrategy.setDelayBase(errorType === "THROTTLING" ? THROTTLING_RETRY_DELAY_BASE : DEFAULT_RETRY_DELAY_BASE);
          const delayFromErrorType = this.retryBackoffStrategy.computeNextBackoffDelay(token.getRetryCount());
          const retryDelay = errorInfo.retryAfterHint ? Math.max(errorInfo.retryAfterHint.getTime() - Date.now() || 0, delayFromErrorType) : delayFromErrorType;
          const capacityCost = this.getCapacityCost(errorType);
          this.capacity -= capacityCost;
          return createDefaultRetryToken({
            retryDelay,
            retryCount: token.getRetryCount() + 1,
            retryCost: capacityCost
          });
        }
        throw new Error("No retry token available");
      }
      recordSuccess(token) {
        this.capacity = Math.max(INITIAL_RETRY_TOKENS, this.capacity + (token.getRetryCost() ?? NO_RETRY_INCREMENT));
      }
      getCapacity() {
        return this.capacity;
      }
      async getMaxAttempts() {
        try {
          return await this.maxAttemptsProvider();
        } catch (error) {
          console.warn(`Max attempts provider could not resolve. Using default of ${DEFAULT_MAX_ATTEMPTS}`);
          return DEFAULT_MAX_ATTEMPTS;
        }
      }
      shouldRetry(tokenToRenew, errorInfo, maxAttempts) {
        const attempts = tokenToRenew.getRetryCount() + 1;
        return attempts < maxAttempts && this.capacity >= this.getCapacityCost(errorInfo.errorType) && this.isRetryableError(errorInfo.errorType);
      }
      getCapacityCost(errorType) {
        return errorType === "TRANSIENT" ? TIMEOUT_RETRY_COST : RETRY_COST;
      }
      isRetryableError(errorType) {
        return errorType === "THROTTLING" || errorType === "TRANSIENT";
      }
    };
  }
});

// node_modules/@smithy/util-retry/dist-es/AdaptiveRetryStrategy.js
var AdaptiveRetryStrategy;
var init_AdaptiveRetryStrategy = __esm({
  "node_modules/@smithy/util-retry/dist-es/AdaptiveRetryStrategy.js"() {
    "use strict";
    init_config3();
    init_DefaultRateLimiter();
    init_StandardRetryStrategy();
    AdaptiveRetryStrategy = class {
      maxAttemptsProvider;
      rateLimiter;
      standardRetryStrategy;
      mode = RETRY_MODES.ADAPTIVE;
      constructor(maxAttemptsProvider, options) {
        this.maxAttemptsProvider = maxAttemptsProvider;
        const { rateLimiter } = options ?? {};
        this.rateLimiter = rateLimiter ?? new DefaultRateLimiter();
        this.standardRetryStrategy = new StandardRetryStrategy(maxAttemptsProvider);
      }
      async acquireInitialRetryToken(retryTokenScope) {
        await this.rateLimiter.getSendToken();
        return this.standardRetryStrategy.acquireInitialRetryToken(retryTokenScope);
      }
      async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {
        this.rateLimiter.updateClientSendingRate(errorInfo);
        return this.standardRetryStrategy.refreshRetryTokenForRetry(tokenToRenew, errorInfo);
      }
      recordSuccess(token) {
        this.rateLimiter.updateClientSendingRate({});
        this.standardRetryStrategy.recordSuccess(token);
      }
    };
  }
});

// node_modules/@smithy/util-retry/dist-es/ConfiguredRetryStrategy.js
var init_ConfiguredRetryStrategy = __esm({
  "node_modules/@smithy/util-retry/dist-es/ConfiguredRetryStrategy.js"() {
    "use strict";
  }
});

// node_modules/@smithy/util-retry/dist-es/types.js
var init_types6 = __esm({
  "node_modules/@smithy/util-retry/dist-es/types.js"() {
    "use strict";
  }
});

// node_modules/@smithy/util-retry/dist-es/index.js
var init_dist_es40 = __esm({
  "node_modules/@smithy/util-retry/dist-es/index.js"() {
    "use strict";
    init_AdaptiveRetryStrategy();
    init_ConfiguredRetryStrategy();
    init_DefaultRateLimiter();
    init_StandardRetryStrategy();
    init_config3();
    init_constants7();
    init_types6();
  }
});

// node_modules/@smithy/middleware-retry/dist-es/delayDecider.js
var init_delayDecider = __esm({
  "node_modules/@smithy/middleware-retry/dist-es/delayDecider.js"() {
    "use strict";
  }
});

// node_modules/@smithy/middleware-retry/dist-es/retryDecider.js
var init_retryDecider = __esm({
  "node_modules/@smithy/middleware-retry/dist-es/retryDecider.js"() {
    "use strict";
  }
});

// node_modules/@smithy/middleware-retry/dist-es/util.js
var asSdkError;
var init_util2 = __esm({
  "node_modules/@smithy/middleware-retry/dist-es/util.js"() {
    "use strict";
    asSdkError = (error) => {
      if (error instanceof Error)
        return error;
      if (error instanceof Object)
        return Object.assign(new Error(), error);
      if (typeof error === "string")
        return new Error(error);
      return new Error(`AWS SDK error wrapper for ${error}`);
    };
  }
});

// node_modules/@smithy/middleware-retry/dist-es/StandardRetryStrategy.js
var init_StandardRetryStrategy2 = __esm({
  "node_modules/@smithy/middleware-retry/dist-es/StandardRetryStrategy.js"() {
    "use strict";
  }
});

// node_modules/@smithy/middleware-retry/dist-es/AdaptiveRetryStrategy.js
var init_AdaptiveRetryStrategy2 = __esm({
  "node_modules/@smithy/middleware-retry/dist-es/AdaptiveRetryStrategy.js"() {
    "use strict";
  }
});

// node_modules/@smithy/middleware-retry/dist-es/configurations.js
var resolveRetryConfig;
var init_configurations2 = __esm({
  "node_modules/@smithy/middleware-retry/dist-es/configurations.js"() {
    "use strict";
    init_dist_es4();
    init_dist_es40();
    resolveRetryConfig = (input) => {
      const { retryStrategy, retryMode: _retryMode, maxAttempts: _maxAttempts } = input;
      const maxAttempts = normalizeProvider(_maxAttempts ?? DEFAULT_MAX_ATTEMPTS);
      return Object.assign(input, {
        maxAttempts,
        retryStrategy: async () => {
          if (retryStrategy) {
            return retryStrategy;
          }
          const retryMode = await normalizeProvider(_retryMode)();
          if (retryMode === RETRY_MODES.ADAPTIVE) {
            return new AdaptiveRetryStrategy(maxAttempts);
          }
          return new StandardRetryStrategy(maxAttempts);
        }
      });
    };
  }
});

// node_modules/@smithy/middleware-retry/dist-es/omitRetryHeadersMiddleware.js
var init_omitRetryHeadersMiddleware = __esm({
  "node_modules/@smithy/middleware-retry/dist-es/omitRetryHeadersMiddleware.js"() {
    "use strict";
  }
});

// node_modules/@smithy/middleware-retry/dist-es/isStreamingPayload/isStreamingPayload.browser.js
var isStreamingPayload;
var init_isStreamingPayload_browser = __esm({
  "node_modules/@smithy/middleware-retry/dist-es/isStreamingPayload/isStreamingPayload.browser.js"() {
    "use strict";
    isStreamingPayload = (request) => request?.body instanceof ReadableStream;
  }
});

// node_modules/@smithy/middleware-retry/dist-es/retryMiddleware.js
var retryMiddleware, isRetryStrategyV2, getRetryErrorInfo, getRetryErrorType, retryMiddlewareOptions, getRetryPlugin, getRetryAfterHint;
var init_retryMiddleware = __esm({
  "node_modules/@smithy/middleware-retry/dist-es/retryMiddleware.js"() {
    "use strict";
    init_dist_es2();
    init_dist_es39();
    init_dist_es20();
    init_dist_es40();
    init_dist_es13();
    init_isStreamingPayload_browser();
    init_util2();
    retryMiddleware = (options) => (next, context) => async (args) => {
      let retryStrategy = await options.retryStrategy();
      const maxAttempts = await options.maxAttempts();
      if (isRetryStrategyV2(retryStrategy)) {
        retryStrategy = retryStrategy;
        let retryToken = await retryStrategy.acquireInitialRetryToken(context["partition_id"]);
        let lastError = new Error();
        let attempts = 0;
        let totalRetryDelay = 0;
        const { request } = args;
        const isRequest = HttpRequest.isInstance(request);
        if (isRequest) {
          request.headers[INVOCATION_ID_HEADER] = v4();
        }
        while (true) {
          try {
            if (isRequest) {
              request.headers[REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;
            }
            const { response, output } = await next(args);
            retryStrategy.recordSuccess(retryToken);
            output.$metadata.attempts = attempts + 1;
            output.$metadata.totalRetryDelay = totalRetryDelay;
            return { response, output };
          } catch (e2) {
            const retryErrorInfo = getRetryErrorInfo(e2);
            lastError = asSdkError(e2);
            if (isRequest && isStreamingPayload(request)) {
              (context.logger instanceof NoOpLogger ? console : context.logger)?.warn("An error was encountered in a non-retryable streaming request.");
              throw lastError;
            }
            try {
              retryToken = await retryStrategy.refreshRetryTokenForRetry(retryToken, retryErrorInfo);
            } catch (refreshError) {
              if (!lastError.$metadata) {
                lastError.$metadata = {};
              }
              lastError.$metadata.attempts = attempts + 1;
              lastError.$metadata.totalRetryDelay = totalRetryDelay;
              throw lastError;
            }
            attempts = retryToken.getRetryCount();
            const delay = retryToken.getRetryDelay();
            totalRetryDelay += delay;
            await new Promise((resolve) => setTimeout(resolve, delay));
          }
        }
      } else {
        retryStrategy = retryStrategy;
        if (retryStrategy?.mode)
          context.userAgent = [...context.userAgent || [], ["cfg/retry-mode", retryStrategy.mode]];
        return retryStrategy.retry(next, args);
      }
    };
    isRetryStrategyV2 = (retryStrategy) => typeof retryStrategy.acquireInitialRetryToken !== "undefined" && typeof retryStrategy.refreshRetryTokenForRetry !== "undefined" && typeof retryStrategy.recordSuccess !== "undefined";
    getRetryErrorInfo = (error) => {
      const errorInfo = {
        error,
        errorType: getRetryErrorType(error)
      };
      const retryAfterHint = getRetryAfterHint(error.$response);
      if (retryAfterHint) {
        errorInfo.retryAfterHint = retryAfterHint;
      }
      return errorInfo;
    };
    getRetryErrorType = (error) => {
      if (isThrottlingError(error))
        return "THROTTLING";
      if (isTransientError(error))
        return "TRANSIENT";
      if (isServerError(error))
        return "SERVER_ERROR";
      return "CLIENT_ERROR";
    };
    retryMiddlewareOptions = {
      name: "retryMiddleware",
      tags: ["RETRY"],
      step: "finalizeRequest",
      priority: "high",
      override: true
    };
    getRetryPlugin = (options) => ({
      applyToStack: (clientStack) => {
        clientStack.add(retryMiddleware(options), retryMiddlewareOptions);
      }
    });
    getRetryAfterHint = (response) => {
      if (!HttpResponse.isInstance(response))
        return;
      const retryAfterHeaderName = Object.keys(response.headers).find((key) => key.toLowerCase() === "retry-after");
      if (!retryAfterHeaderName)
        return;
      const retryAfter = response.headers[retryAfterHeaderName];
      const retryAfterSeconds = Number(retryAfter);
      if (!Number.isNaN(retryAfterSeconds))
        return new Date(retryAfterSeconds * 1e3);
      const retryAfterDate = new Date(retryAfter);
      return retryAfterDate;
    };
  }
});

// node_modules/@smithy/middleware-retry/dist-es/index.js
var init_dist_es41 = __esm({
  "node_modules/@smithy/middleware-retry/dist-es/index.js"() {
    "use strict";
    init_AdaptiveRetryStrategy2();
    init_StandardRetryStrategy2();
    init_configurations2();
    init_delayDecider();
    init_omitRetryHeadersMiddleware();
    init_retryDecider();
    init_retryMiddleware();
  }
});

// node_modules/@aws-sdk/signature-v4-multi-region/dist-es/signature-v4-crt-container.js
var signatureV4CrtContainer;
var init_signature_v4_crt_container = __esm({
  "node_modules/@aws-sdk/signature-v4-multi-region/dist-es/signature-v4-crt-container.js"() {
    "use strict";
    signatureV4CrtContainer = {
      CrtSignerV4: null
    };
  }
});

// node_modules/@aws-sdk/signature-v4-multi-region/dist-es/SignatureV4MultiRegion.js
var SignatureV4MultiRegion;
var init_SignatureV4MultiRegion = __esm({
  "node_modules/@aws-sdk/signature-v4-multi-region/dist-es/SignatureV4MultiRegion.js"() {
    "use strict";
    init_dist_es29();
    init_dist_es17();
    init_signature_v4_crt_container();
    SignatureV4MultiRegion = class {
      sigv4aSigner;
      sigv4Signer;
      signerOptions;
      static sigv4aDependency() {
        if (typeof signatureV4CrtContainer.CrtSignerV4 === "function") {
          return "crt";
        } else if (typeof signatureV4aContainer.SignatureV4a === "function") {
          return "js";
        }
        return "none";
      }
      constructor(options) {
        this.sigv4Signer = new SignatureV4S3Express(options);
        this.signerOptions = options;
      }
      async sign(requestToSign, options = {}) {
        if (options.signingRegion === "*") {
          return this.getSigv4aSigner().sign(requestToSign, options);
        }
        return this.sigv4Signer.sign(requestToSign, options);
      }
      async signWithCredentials(requestToSign, credentials, options = {}) {
        if (options.signingRegion === "*") {
          const signer = this.getSigv4aSigner();
          const CrtSignerV4 = signatureV4CrtContainer.CrtSignerV4;
          if (CrtSignerV4 && signer instanceof CrtSignerV4) {
            return signer.signWithCredentials(requestToSign, credentials, options);
          } else {
            throw new Error(`signWithCredentials with signingRegion '*' is only supported when using the CRT dependency @aws-sdk/signature-v4-crt. Please check whether you have installed the "@aws-sdk/signature-v4-crt" package explicitly. You must also register the package by calling [require("@aws-sdk/signature-v4-crt");] or an ESM equivalent such as [import "@aws-sdk/signature-v4-crt";]. For more information please go to https://github.com/aws/aws-sdk-js-v3#functionality-requiring-aws-common-runtime-crt`);
          }
        }
        return this.sigv4Signer.signWithCredentials(requestToSign, credentials, options);
      }
      async presign(originalRequest, options = {}) {
        if (options.signingRegion === "*") {
          const signer = this.getSigv4aSigner();
          const CrtSignerV4 = signatureV4CrtContainer.CrtSignerV4;
          if (CrtSignerV4 && signer instanceof CrtSignerV4) {
            return signer.presign(originalRequest, options);
          } else {
            throw new Error(`presign with signingRegion '*' is only supported when using the CRT dependency @aws-sdk/signature-v4-crt. Please check whether you have installed the "@aws-sdk/signature-v4-crt" package explicitly. You must also register the package by calling [require("@aws-sdk/signature-v4-crt");] or an ESM equivalent such as [import "@aws-sdk/signature-v4-crt";]. For more information please go to https://github.com/aws/aws-sdk-js-v3#functionality-requiring-aws-common-runtime-crt`);
          }
        }
        return this.sigv4Signer.presign(originalRequest, options);
      }
      async presignWithCredentials(originalRequest, credentials, options = {}) {
        if (options.signingRegion === "*") {
          throw new Error("Method presignWithCredentials is not supported for [signingRegion=*].");
        }
        return this.sigv4Signer.presignWithCredentials(originalRequest, credentials, options);
      }
      getSigv4aSigner() {
        if (!this.sigv4aSigner) {
          const CrtSignerV4 = signatureV4CrtContainer.CrtSignerV4;
          const JsSigV4aSigner = signatureV4aContainer.SignatureV4a;
          if (this.signerOptions.runtime === "node") {
            if (!CrtSignerV4 && !JsSigV4aSigner) {
              throw new Error("Neither CRT nor JS SigV4a implementation is available. Please load either @aws-sdk/signature-v4-crt or @aws-sdk/signature-v4a. For more information please go to https://github.com/aws/aws-sdk-js-v3#functionality-requiring-aws-common-runtime-crt");
            }
            if (CrtSignerV4 && typeof CrtSignerV4 === "function") {
              this.sigv4aSigner = new CrtSignerV4({
                ...this.signerOptions,
                signingAlgorithm: 1
              });
            } else if (JsSigV4aSigner && typeof JsSigV4aSigner === "function") {
              this.sigv4aSigner = new JsSigV4aSigner({
                ...this.signerOptions
              });
            } else {
              throw new Error("Available SigV4a implementation is not a valid constructor. Please ensure you've properly imported @aws-sdk/signature-v4-crt or @aws-sdk/signature-v4a.For more information please go to https://github.com/aws/aws-sdk-js-v3#functionality-requiring-aws-common-runtime-crt");
            }
          } else {
            if (!JsSigV4aSigner || typeof JsSigV4aSigner !== "function") {
              throw new Error("JS SigV4a implementation is not available or not a valid constructor. Please check whether you have installed the @aws-sdk/signature-v4a package explicitly. The CRT implementation is not available for browsers. You must also register the package by calling [require('@aws-sdk/signature-v4a');] or an ESM equivalent such as [import '@aws-sdk/signature-v4a';]. For more information please go to https://github.com/aws/aws-sdk-js-v3#using-javascript-non-crt-implementation-of-sigv4a");
            }
            this.sigv4aSigner = new JsSigV4aSigner({
              ...this.signerOptions
            });
          }
        }
        return this.sigv4aSigner;
      }
    };
  }
});

// node_modules/@aws-sdk/signature-v4-multi-region/dist-es/index.js
var init_dist_es42 = __esm({
  "node_modules/@aws-sdk/signature-v4-multi-region/dist-es/index.js"() {
    "use strict";
    init_SignatureV4MultiRegion();
    init_signature_v4_crt_container();
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/endpoint/ruleset.js
var cs, ct, cu, cv, cw, cx, cy, cz, cA, cB, cC, cD, cE, cF, cG, cH, cI, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z, aa, ab, ac, ad, ae, af, ag, ah, ai, aj, ak, al, am, an, ao, ap, aq, ar, as, at, au, av, aw, ax, ay, az, aA, aB, aC, aD, aE, aF, aG, aH, aI, aJ, aK, aL, aM, aN, aO, aP, aQ, aR, aS, aT, aU, aV, aW, aX, aY, aZ, ba, bb, bc, bd, be, bf, bg, bh, bi, bj, bk, bl, bm, bn, bo, bp, bq, br, bs, bt, bu, bv, bw, bx, by, bz, bA, bB, bC, bD, bE, bF, bG, bH, bI, bJ, bK, bL, bM, bN, bO, bP, bQ, bR, bS, bT, bU, bV, bW, bX, bY, bZ, ca, cb, cc, cd, ce, cf, cg, ch, ci, cj, ck, cl, cm, cn, co, cp, cq, cr, _data, ruleSet;
var init_ruleset = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/endpoint/ruleset.js"() {
    "use strict";
    cs = "required";
    ct = "type";
    cu = "rules";
    cv = "conditions";
    cw = "fn";
    cx = "argv";
    cy = "ref";
    cz = "assign";
    cA = "url";
    cB = "properties";
    cC = "backend";
    cD = "authSchemes";
    cE = "disableDoubleEncoding";
    cF = "signingName";
    cG = "signingRegion";
    cH = "headers";
    cI = "signingRegionSet";
    a = 6;
    b = false;
    c = true;
    d = "isSet";
    e = "booleanEquals";
    f = "error";
    g = "aws.partition";
    h = "stringEquals";
    i = "getAttr";
    j = "name";
    k = "substring";
    l = "bucketSuffix";
    m = "parseURL";
    n = "endpoint";
    o = "tree";
    p = "aws.isVirtualHostableS3Bucket";
    q = "{url#scheme}://{Bucket}.{url#authority}{url#path}";
    r = "not";
    s = "accessPointSuffix";
    t = "{url#scheme}://{url#authority}{url#path}";
    u = "hardwareType";
    v = "regionPrefix";
    w = "bucketAliasSuffix";
    x = "outpostId";
    y = "isValidHostLabel";
    z = "sigv4a";
    A = "s3-outposts";
    B = "s3";
    C = "{url#scheme}://{url#authority}{url#normalizedPath}{Bucket}";
    D = "https://{Bucket}.s3-accelerate.{partitionResult#dnsSuffix}";
    E = "https://{Bucket}.s3.{partitionResult#dnsSuffix}";
    F = "aws.parseArn";
    G = "bucketArn";
    H = "arnType";
    I = "";
    J = "s3-object-lambda";
    K = "accesspoint";
    L = "accessPointName";
    M = "{url#scheme}://{accessPointName}-{bucketArn#accountId}.{url#authority}{url#path}";
    N = "mrapPartition";
    O = "outpostType";
    P = "arnPrefix";
    Q = "{url#scheme}://{url#authority}{url#normalizedPath}{uri_encoded_bucket}";
    R = "https://s3.{partitionResult#dnsSuffix}/{uri_encoded_bucket}";
    S = "https://s3.{partitionResult#dnsSuffix}";
    T = { [cs]: false, [ct]: "string" };
    U = { [cs]: true, "default": false, [ct]: "boolean" };
    V = { [cs]: false, [ct]: "boolean" };
    W = { [cw]: e, [cx]: [{ [cy]: "Accelerate" }, true] };
    X = { [cw]: e, [cx]: [{ [cy]: "UseFIPS" }, true] };
    Y = { [cw]: e, [cx]: [{ [cy]: "UseDualStack" }, true] };
    Z = { [cw]: d, [cx]: [{ [cy]: "Endpoint" }] };
    aa = { [cw]: g, [cx]: [{ [cy]: "Region" }], [cz]: "partitionResult" };
    ab = { [cw]: h, [cx]: [{ [cw]: i, [cx]: [{ [cy]: "partitionResult" }, j] }, "aws-cn"] };
    ac = { [cw]: d, [cx]: [{ [cy]: "Bucket" }] };
    ad = { [cy]: "Bucket" };
    ae = { [cv]: [W], [f]: "S3Express does not support S3 Accelerate.", [ct]: f };
    af = { [cv]: [Z, { [cw]: m, [cx]: [{ [cy]: "Endpoint" }], [cz]: "url" }], [cu]: [{ [cv]: [{ [cw]: d, [cx]: [{ [cy]: "DisableS3ExpressSessionAuth" }] }, { [cw]: e, [cx]: [{ [cy]: "DisableS3ExpressSessionAuth" }, true] }], [cu]: [{ [cv]: [{ [cw]: e, [cx]: [{ [cw]: i, [cx]: [{ [cy]: "url" }, "isIp"] }, true] }], [cu]: [{ [cv]: [{ [cw]: "uriEncode", [cx]: [ad], [cz]: "uri_encoded_bucket" }], [cu]: [{ [n]: { [cA]: "{url#scheme}://{url#authority}/{uri_encoded_bucket}{url#path}", [cB]: { [cC]: "S3Express", [cD]: [{ [cE]: true, [j]: "sigv4", [cF]: "s3express", [cG]: "{Region}" }] }, [cH]: {} }, [ct]: n }], [ct]: o }], [ct]: o }, { [cv]: [{ [cw]: p, [cx]: [ad, false] }], [cu]: [{ [n]: { [cA]: q, [cB]: { [cC]: "S3Express", [cD]: [{ [cE]: true, [j]: "sigv4", [cF]: "s3express", [cG]: "{Region}" }] }, [cH]: {} }, [ct]: n }], [ct]: o }, { [f]: "S3Express bucket name is not a valid virtual hostable name.", [ct]: f }], [ct]: o }, { [cv]: [{ [cw]: e, [cx]: [{ [cw]: i, [cx]: [{ [cy]: "url" }, "isIp"] }, true] }], [cu]: [{ [cv]: [{ [cw]: "uriEncode", [cx]: [ad], [cz]: "uri_encoded_bucket" }], [cu]: [{ [n]: { [cA]: "{url#scheme}://{url#authority}/{uri_encoded_bucket}{url#path}", [cB]: { [cC]: "S3Express", [cD]: [{ [cE]: true, [j]: "sigv4-s3express", [cF]: "s3express", [cG]: "{Region}" }] }, [cH]: {} }, [ct]: n }], [ct]: o }], [ct]: o }, { [cv]: [{ [cw]: p, [cx]: [ad, false] }], [cu]: [{ [n]: { [cA]: q, [cB]: { [cC]: "S3Express", [cD]: [{ [cE]: true, [j]: "sigv4-s3express", [cF]: "s3express", [cG]: "{Region}" }] }, [cH]: {} }, [ct]: n }], [ct]: o }, { [f]: "S3Express bucket name is not a valid virtual hostable name.", [ct]: f }], [ct]: o };
    ag = { [cw]: m, [cx]: [{ [cy]: "Endpoint" }], [cz]: "url" };
    ah = { [cw]: e, [cx]: [{ [cw]: i, [cx]: [{ [cy]: "url" }, "isIp"] }, true] };
    ai = { [cy]: "url" };
    aj = { [cw]: "uriEncode", [cx]: [ad], [cz]: "uri_encoded_bucket" };
    ak = { [cC]: "S3Express", [cD]: [{ [cE]: true, [j]: "sigv4", [cF]: "s3express", [cG]: "{Region}" }] };
    al = {};
    am = { [cw]: p, [cx]: [ad, false] };
    an = { [f]: "S3Express bucket name is not a valid virtual hostable name.", [ct]: f };
    ao = { [cw]: d, [cx]: [{ [cy]: "UseS3ExpressControlEndpoint" }] };
    ap = { [cw]: e, [cx]: [{ [cy]: "UseS3ExpressControlEndpoint" }, true] };
    aq = { [cw]: r, [cx]: [Z] };
    ar = { [cw]: e, [cx]: [{ [cy]: "UseDualStack" }, false] };
    as = { [cw]: e, [cx]: [{ [cy]: "UseFIPS" }, false] };
    at = { [f]: "Unrecognized S3Express bucket name format.", [ct]: f };
    au = { [cw]: r, [cx]: [ac] };
    av = { [cy]: u };
    aw = { [cv]: [aq], [f]: "Expected a endpoint to be specified but no endpoint was found", [ct]: f };
    ax = { [cD]: [{ [cE]: true, [j]: z, [cF]: A, [cI]: ["*"] }, { [cE]: true, [j]: "sigv4", [cF]: A, [cG]: "{Region}" }] };
    ay = { [cw]: e, [cx]: [{ [cy]: "ForcePathStyle" }, false] };
    az = { [cy]: "ForcePathStyle" };
    aA = { [cw]: e, [cx]: [{ [cy]: "Accelerate" }, false] };
    aB = { [cw]: h, [cx]: [{ [cy]: "Region" }, "aws-global"] };
    aC = { [cD]: [{ [cE]: true, [j]: "sigv4", [cF]: B, [cG]: "us-east-1" }] };
    aD = { [cw]: r, [cx]: [aB] };
    aE = { [cw]: e, [cx]: [{ [cy]: "UseGlobalEndpoint" }, true] };
    aF = { [cA]: "https://{Bucket}.s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}", [cB]: { [cD]: [{ [cE]: true, [j]: "sigv4", [cF]: B, [cG]: "{Region}" }] }, [cH]: {} };
    aG = { [cD]: [{ [cE]: true, [j]: "sigv4", [cF]: B, [cG]: "{Region}" }] };
    aH = { [cw]: e, [cx]: [{ [cy]: "UseGlobalEndpoint" }, false] };
    aI = { [cA]: "https://{Bucket}.s3-fips.{Region}.{partitionResult#dnsSuffix}", [cB]: aG, [cH]: {} };
    aJ = { [cA]: "https://{Bucket}.s3-accelerate.dualstack.{partitionResult#dnsSuffix}", [cB]: aG, [cH]: {} };
    aK = { [cA]: "https://{Bucket}.s3.dualstack.{Region}.{partitionResult#dnsSuffix}", [cB]: aG, [cH]: {} };
    aL = { [cw]: e, [cx]: [{ [cw]: i, [cx]: [ai, "isIp"] }, false] };
    aM = { [cA]: C, [cB]: aG, [cH]: {} };
    aN = { [cA]: q, [cB]: aG, [cH]: {} };
    aO = { [n]: aN, [ct]: n };
    aP = { [cA]: D, [cB]: aG, [cH]: {} };
    aQ = { [cA]: "https://{Bucket}.s3.{Region}.{partitionResult#dnsSuffix}", [cB]: aG, [cH]: {} };
    aR = { [f]: "Invalid region: region was not a valid DNS name.", [ct]: f };
    aS = { [cy]: G };
    aT = { [cy]: H };
    aU = { [cw]: i, [cx]: [aS, "service"] };
    aV = { [cy]: L };
    aW = { [cv]: [Y], [f]: "S3 Object Lambda does not support Dual-stack", [ct]: f };
    aX = { [cv]: [W], [f]: "S3 Object Lambda does not support S3 Accelerate", [ct]: f };
    aY = { [cv]: [{ [cw]: d, [cx]: [{ [cy]: "DisableAccessPoints" }] }, { [cw]: e, [cx]: [{ [cy]: "DisableAccessPoints" }, true] }], [f]: "Access points are not supported for this operation", [ct]: f };
    aZ = { [cv]: [{ [cw]: d, [cx]: [{ [cy]: "UseArnRegion" }] }, { [cw]: e, [cx]: [{ [cy]: "UseArnRegion" }, false] }, { [cw]: r, [cx]: [{ [cw]: h, [cx]: [{ [cw]: i, [cx]: [aS, "region"] }, "{Region}"] }] }], [f]: "Invalid configuration: region from ARN `{bucketArn#region}` does not match client region `{Region}` and UseArnRegion is `false`", [ct]: f };
    ba = { [cw]: i, [cx]: [{ [cy]: "bucketPartition" }, j] };
    bb = { [cw]: i, [cx]: [aS, "accountId"] };
    bc = { [cD]: [{ [cE]: true, [j]: "sigv4", [cF]: J, [cG]: "{bucketArn#region}" }] };
    bd = { [f]: "Invalid ARN: The access point name may only contain a-z, A-Z, 0-9 and `-`. Found: `{accessPointName}`", [ct]: f };
    be = { [f]: "Invalid ARN: The account id may only contain a-z, A-Z, 0-9 and `-`. Found: `{bucketArn#accountId}`", [ct]: f };
    bf = { [f]: "Invalid region in ARN: `{bucketArn#region}` (invalid DNS name)", [ct]: f };
    bg = { [f]: "Client was configured for partition `{partitionResult#name}` but ARN (`{Bucket}`) has `{bucketPartition#name}`", [ct]: f };
    bh = { [f]: "Invalid ARN: The ARN may only contain a single resource component after `accesspoint`.", [ct]: f };
    bi = { [f]: "Invalid ARN: Expected a resource of the format `accesspoint:<accesspoint name>` but no name was provided", [ct]: f };
    bj = { [cD]: [{ [cE]: true, [j]: "sigv4", [cF]: B, [cG]: "{bucketArn#region}" }] };
    bk = { [cD]: [{ [cE]: true, [j]: z, [cF]: A, [cI]: ["*"] }, { [cE]: true, [j]: "sigv4", [cF]: A, [cG]: "{bucketArn#region}" }] };
    bl = { [cw]: F, [cx]: [ad] };
    bm = { [cA]: "https://s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cB]: aG, [cH]: {} };
    bn = { [cA]: "https://s3-fips.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cB]: aG, [cH]: {} };
    bo = { [cA]: "https://s3.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cB]: aG, [cH]: {} };
    bp = { [cA]: Q, [cB]: aG, [cH]: {} };
    bq = { [cA]: "https://s3.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cB]: aG, [cH]: {} };
    br = { [cy]: "UseObjectLambdaEndpoint" };
    bs = { [cD]: [{ [cE]: true, [j]: "sigv4", [cF]: J, [cG]: "{Region}" }] };
    bt = { [cA]: "https://s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}", [cB]: aG, [cH]: {} };
    bu = { [cA]: "https://s3-fips.{Region}.{partitionResult#dnsSuffix}", [cB]: aG, [cH]: {} };
    bv = { [cA]: "https://s3.dualstack.{Region}.{partitionResult#dnsSuffix}", [cB]: aG, [cH]: {} };
    bw = { [cA]: t, [cB]: aG, [cH]: {} };
    bx = { [cA]: "https://s3.{Region}.{partitionResult#dnsSuffix}", [cB]: aG, [cH]: {} };
    by = [{ [cy]: "Region" }];
    bz = [{ [cy]: "Endpoint" }];
    bA = [ad];
    bB = [W];
    bC = [Z, ag];
    bD = [{ [cw]: d, [cx]: [{ [cy]: "DisableS3ExpressSessionAuth" }] }, { [cw]: e, [cx]: [{ [cy]: "DisableS3ExpressSessionAuth" }, true] }];
    bE = [aj];
    bF = [am];
    bG = [aa];
    bH = [X, Y];
    bI = [X, ar];
    bJ = [as, Y];
    bK = [as, ar];
    bL = [{ [cw]: k, [cx]: [ad, 6, 14, true], [cz]: "s3expressAvailabilityZoneId" }, { [cw]: k, [cx]: [ad, 14, 16, true], [cz]: "s3expressAvailabilityZoneDelim" }, { [cw]: h, [cx]: [{ [cy]: "s3expressAvailabilityZoneDelim" }, "--"] }];
    bM = [{ [cv]: [X, Y], [n]: { [cA]: "https://{Bucket}.s3express-fips-{s3expressAvailabilityZoneId}.dualstack.{Region}.{partitionResult#dnsSuffix}", [cB]: ak, [cH]: {} }, [ct]: n }, { [cv]: bI, [n]: { [cA]: "https://{Bucket}.s3express-fips-{s3expressAvailabilityZoneId}.{Region}.{partitionResult#dnsSuffix}", [cB]: ak, [cH]: {} }, [ct]: n }, { [cv]: bJ, [n]: { [cA]: "https://{Bucket}.s3express-{s3expressAvailabilityZoneId}.dualstack.{Region}.{partitionResult#dnsSuffix}", [cB]: ak, [cH]: {} }, [ct]: n }, { [cv]: bK, [n]: { [cA]: "https://{Bucket}.s3express-{s3expressAvailabilityZoneId}.{Region}.{partitionResult#dnsSuffix}", [cB]: ak, [cH]: {} }, [ct]: n }];
    bN = [{ [cw]: k, [cx]: [ad, 6, 15, true], [cz]: "s3expressAvailabilityZoneId" }, { [cw]: k, [cx]: [ad, 15, 17, true], [cz]: "s3expressAvailabilityZoneDelim" }, { [cw]: h, [cx]: [{ [cy]: "s3expressAvailabilityZoneDelim" }, "--"] }];
    bO = [{ [cw]: k, [cx]: [ad, 6, 19, true], [cz]: "s3expressAvailabilityZoneId" }, { [cw]: k, [cx]: [ad, 19, 21, true], [cz]: "s3expressAvailabilityZoneDelim" }, { [cw]: h, [cx]: [{ [cy]: "s3expressAvailabilityZoneDelim" }, "--"] }];
    bP = [{ [cw]: k, [cx]: [ad, 6, 20, true], [cz]: "s3expressAvailabilityZoneId" }, { [cw]: k, [cx]: [ad, 20, 22, true], [cz]: "s3expressAvailabilityZoneDelim" }, { [cw]: h, [cx]: [{ [cy]: "s3expressAvailabilityZoneDelim" }, "--"] }];
    bQ = [{ [cw]: k, [cx]: [ad, 6, 26, true], [cz]: "s3expressAvailabilityZoneId" }, { [cw]: k, [cx]: [ad, 26, 28, true], [cz]: "s3expressAvailabilityZoneDelim" }, { [cw]: h, [cx]: [{ [cy]: "s3expressAvailabilityZoneDelim" }, "--"] }];
    bR = [{ [cv]: [X, Y], [n]: { [cA]: "https://{Bucket}.s3express-fips-{s3expressAvailabilityZoneId}.dualstack.{Region}.{partitionResult#dnsSuffix}", [cB]: { [cC]: "S3Express", [cD]: [{ [cE]: true, [j]: "sigv4-s3express", [cF]: "s3express", [cG]: "{Region}" }] }, [cH]: {} }, [ct]: n }, { [cv]: bI, [n]: { [cA]: "https://{Bucket}.s3express-fips-{s3expressAvailabilityZoneId}.{Region}.{partitionResult#dnsSuffix}", [cB]: { [cC]: "S3Express", [cD]: [{ [cE]: true, [j]: "sigv4-s3express", [cF]: "s3express", [cG]: "{Region}" }] }, [cH]: {} }, [ct]: n }, { [cv]: bJ, [n]: { [cA]: "https://{Bucket}.s3express-{s3expressAvailabilityZoneId}.dualstack.{Region}.{partitionResult#dnsSuffix}", [cB]: { [cC]: "S3Express", [cD]: [{ [cE]: true, [j]: "sigv4-s3express", [cF]: "s3express", [cG]: "{Region}" }] }, [cH]: {} }, [ct]: n }, { [cv]: bK, [n]: { [cA]: "https://{Bucket}.s3express-{s3expressAvailabilityZoneId}.{Region}.{partitionResult#dnsSuffix}", [cB]: { [cC]: "S3Express", [cD]: [{ [cE]: true, [j]: "sigv4-s3express", [cF]: "s3express", [cG]: "{Region}" }] }, [cH]: {} }, [ct]: n }];
    bS = [ad, 0, 7, true];
    bT = [{ [cw]: k, [cx]: [ad, 7, 15, true], [cz]: "s3expressAvailabilityZoneId" }, { [cw]: k, [cx]: [ad, 15, 17, true], [cz]: "s3expressAvailabilityZoneDelim" }, { [cw]: h, [cx]: [{ [cy]: "s3expressAvailabilityZoneDelim" }, "--"] }];
    bU = [{ [cw]: k, [cx]: [ad, 7, 16, true], [cz]: "s3expressAvailabilityZoneId" }, { [cw]: k, [cx]: [ad, 16, 18, true], [cz]: "s3expressAvailabilityZoneDelim" }, { [cw]: h, [cx]: [{ [cy]: "s3expressAvailabilityZoneDelim" }, "--"] }];
    bV = [{ [cw]: k, [cx]: [ad, 7, 20, true], [cz]: "s3expressAvailabilityZoneId" }, { [cw]: k, [cx]: [ad, 20, 22, true], [cz]: "s3expressAvailabilityZoneDelim" }, { [cw]: h, [cx]: [{ [cy]: "s3expressAvailabilityZoneDelim" }, "--"] }];
    bW = [{ [cw]: k, [cx]: [ad, 7, 21, true], [cz]: "s3expressAvailabilityZoneId" }, { [cw]: k, [cx]: [ad, 21, 23, true], [cz]: "s3expressAvailabilityZoneDelim" }, { [cw]: h, [cx]: [{ [cy]: "s3expressAvailabilityZoneDelim" }, "--"] }];
    bX = [{ [cw]: k, [cx]: [ad, 7, 27, true], [cz]: "s3expressAvailabilityZoneId" }, { [cw]: k, [cx]: [ad, 27, 29, true], [cz]: "s3expressAvailabilityZoneDelim" }, { [cw]: h, [cx]: [{ [cy]: "s3expressAvailabilityZoneDelim" }, "--"] }];
    bY = [ac];
    bZ = [{ [cw]: y, [cx]: [{ [cy]: x }, false] }];
    ca = [{ [cw]: h, [cx]: [{ [cy]: v }, "beta"] }];
    cb = ["*"];
    cc = [{ [cw]: y, [cx]: [{ [cy]: "Region" }, false] }];
    cd = [{ [cw]: h, [cx]: [{ [cy]: "Region" }, "us-east-1"] }];
    ce = [{ [cw]: h, [cx]: [aT, K] }];
    cf = [{ [cw]: i, [cx]: [aS, "resourceId[1]"], [cz]: L }, { [cw]: r, [cx]: [{ [cw]: h, [cx]: [aV, I] }] }];
    cg = [aS, "resourceId[1]"];
    ch = [Y];
    ci = [{ [cw]: r, [cx]: [{ [cw]: h, [cx]: [{ [cw]: i, [cx]: [aS, "region"] }, I] }] }];
    cj = [{ [cw]: r, [cx]: [{ [cw]: d, [cx]: [{ [cw]: i, [cx]: [aS, "resourceId[2]"] }] }] }];
    ck = [aS, "resourceId[2]"];
    cl = [{ [cw]: g, [cx]: [{ [cw]: i, [cx]: [aS, "region"] }], [cz]: "bucketPartition" }];
    cm = [{ [cw]: h, [cx]: [ba, { [cw]: i, [cx]: [{ [cy]: "partitionResult" }, j] }] }];
    cn = [{ [cw]: y, [cx]: [{ [cw]: i, [cx]: [aS, "region"] }, true] }];
    co = [{ [cw]: y, [cx]: [bb, false] }];
    cp = [{ [cw]: y, [cx]: [aV, false] }];
    cq = [X];
    cr = [{ [cw]: y, [cx]: [{ [cy]: "Region" }, true] }];
    _data = { version: "1.0", parameters: { Bucket: T, Region: T, UseFIPS: U, UseDualStack: U, Endpoint: T, ForcePathStyle: U, Accelerate: U, UseGlobalEndpoint: U, UseObjectLambdaEndpoint: V, Key: T, Prefix: T, CopySource: T, DisableAccessPoints: V, DisableMultiRegionAccessPoints: U, UseArnRegion: V, UseS3ExpressControlEndpoint: V, DisableS3ExpressSessionAuth: V }, [cu]: [{ [cv]: [{ [cw]: d, [cx]: by }], [cu]: [{ [cv]: [W, X], error: "Accelerate cannot be used with FIPS", [ct]: f }, { [cv]: [Y, Z], error: "Cannot set dual-stack in combination with a custom endpoint.", [ct]: f }, { [cv]: [Z, X], error: "A custom endpoint cannot be combined with FIPS", [ct]: f }, { [cv]: [Z, W], error: "A custom endpoint cannot be combined with S3 Accelerate", [ct]: f }, { [cv]: [X, aa, ab], error: "Partition does not support FIPS", [ct]: f }, { [cv]: [ac, { [cw]: k, [cx]: [ad, 0, a, c], [cz]: l }, { [cw]: h, [cx]: [{ [cy]: l }, "--x-s3"] }], [cu]: [ae, af, { [cv]: [ao, ap], [cu]: [{ [cv]: bG, [cu]: [{ [cv]: [aj, aq], [cu]: [{ [cv]: bH, endpoint: { [cA]: "https://s3express-control-fips.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cB]: ak, [cH]: al }, [ct]: n }, { [cv]: bI, endpoint: { [cA]: "https://s3express-control-fips.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cB]: ak, [cH]: al }, [ct]: n }, { [cv]: bJ, endpoint: { [cA]: "https://s3express-control.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cB]: ak, [cH]: al }, [ct]: n }, { [cv]: bK, endpoint: { [cA]: "https://s3express-control.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cB]: ak, [cH]: al }, [ct]: n }], [ct]: o }], [ct]: o }], [ct]: o }, { [cv]: bF, [cu]: [{ [cv]: bG, [cu]: [{ [cv]: bD, [cu]: [{ [cv]: bL, [cu]: bM, [ct]: o }, { [cv]: bN, [cu]: bM, [ct]: o }, { [cv]: bO, [cu]: bM, [ct]: o }, { [cv]: bP, [cu]: bM, [ct]: o }, { [cv]: bQ, [cu]: bM, [ct]: o }, at], [ct]: o }, { [cv]: bL, [cu]: bR, [ct]: o }, { [cv]: bN, [cu]: bR, [ct]: o }, { [cv]: bO, [cu]: bR, [ct]: o }, { [cv]: bP, [cu]: bR, [ct]: o }, { [cv]: bQ, [cu]: bR, [ct]: o }, at], [ct]: o }], [ct]: o }, an], [ct]: o }, { [cv]: [ac, { [cw]: k, [cx]: bS, [cz]: s }, { [cw]: h, [cx]: [{ [cy]: s }, "--xa-s3"] }], [cu]: [ae, af, { [cv]: bF, [cu]: [{ [cv]: bG, [cu]: [{ [cv]: bD, [cu]: [{ [cv]: bT, [cu]: bM, [ct]: o }, { [cv]: bU, [cu]: bM, [ct]: o }, { [cv]: bV, [cu]: bM, [ct]: o }, { [cv]: bW, [cu]: bM, [ct]: o }, { [cv]: bX, [cu]: bM, [ct]: o }, at], [ct]: o }, { [cv]: bT, [cu]: bR, [ct]: o }, { [cv]: bU, [cu]: bR, [ct]: o }, { [cv]: bV, [cu]: bR, [ct]: o }, { [cv]: bW, [cu]: bR, [ct]: o }, { [cv]: bX, [cu]: bR, [ct]: o }, at], [ct]: o }], [ct]: o }, an], [ct]: o }, { [cv]: [au, ao, ap], [cu]: [{ [cv]: bG, [cu]: [{ [cv]: bC, endpoint: { [cA]: t, [cB]: ak, [cH]: al }, [ct]: n }, { [cv]: bH, endpoint: { [cA]: "https://s3express-control-fips.dualstack.{Region}.{partitionResult#dnsSuffix}", [cB]: ak, [cH]: al }, [ct]: n }, { [cv]: bI, endpoint: { [cA]: "https://s3express-control-fips.{Region}.{partitionResult#dnsSuffix}", [cB]: ak, [cH]: al }, [ct]: n }, { [cv]: bJ, endpoint: { [cA]: "https://s3express-control.dualstack.{Region}.{partitionResult#dnsSuffix}", [cB]: ak, [cH]: al }, [ct]: n }, { [cv]: bK, endpoint: { [cA]: "https://s3express-control.{Region}.{partitionResult#dnsSuffix}", [cB]: ak, [cH]: al }, [ct]: n }], [ct]: o }], [ct]: o }, { [cv]: [ac, { [cw]: k, [cx]: [ad, 49, 50, c], [cz]: u }, { [cw]: k, [cx]: [ad, 8, 12, c], [cz]: v }, { [cw]: k, [cx]: bS, [cz]: w }, { [cw]: k, [cx]: [ad, 32, 49, c], [cz]: x }, { [cw]: g, [cx]: by, [cz]: "regionPartition" }, { [cw]: h, [cx]: [{ [cy]: w }, "--op-s3"] }], [cu]: [{ [cv]: bZ, [cu]: [{ [cv]: [{ [cw]: h, [cx]: [av, "e"] }], [cu]: [{ [cv]: ca, [cu]: [aw, { [cv]: bC, endpoint: { [cA]: "https://{Bucket}.ec2.{url#authority}", [cB]: ax, [cH]: al }, [ct]: n }], [ct]: o }, { endpoint: { [cA]: "https://{Bucket}.ec2.s3-outposts.{Region}.{regionPartition#dnsSuffix}", [cB]: ax, [cH]: al }, [ct]: n }], [ct]: o }, { [cv]: [{ [cw]: h, [cx]: [av, "o"] }], [cu]: [{ [cv]: ca, [cu]: [aw, { [cv]: bC, endpoint: { [cA]: "https://{Bucket}.op-{outpostId}.{url#authority}", [cB]: ax, [cH]: al }, [ct]: n }], [ct]: o }, { endpoint: { [cA]: "https://{Bucket}.op-{outpostId}.s3-outposts.{Region}.{regionPartition#dnsSuffix}", [cB]: ax, [cH]: al }, [ct]: n }], [ct]: o }, { error: 'Unrecognized hardware type: "Expected hardware type o or e but got {hardwareType}"', [ct]: f }], [ct]: o }, { error: "Invalid ARN: The outpost Id must only contain a-z, A-Z, 0-9 and `-`.", [ct]: f }], [ct]: o }, { [cv]: bY, [cu]: [{ [cv]: [Z, { [cw]: r, [cx]: [{ [cw]: d, [cx]: [{ [cw]: m, [cx]: bz }] }] }], error: "Custom endpoint `{Endpoint}` was not a valid URI", [ct]: f }, { [cv]: [ay, am], [cu]: [{ [cv]: bG, [cu]: [{ [cv]: cc, [cu]: [{ [cv]: [W, ab], error: "S3 Accelerate cannot be used in this region", [ct]: f }, { [cv]: [Y, X, aA, aq, aB], endpoint: { [cA]: "https://{Bucket}.s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}", [cB]: aC, [cH]: al }, [ct]: n }, { [cv]: [Y, X, aA, aq, aD, aE], [cu]: [{ endpoint: aF, [ct]: n }], [ct]: o }, { [cv]: [Y, X, aA, aq, aD, aH], endpoint: aF, [ct]: n }, { [cv]: [ar, X, aA, aq, aB], endpoint: { [cA]: "https://{Bucket}.s3-fips.us-east-1.{partitionResult#dnsSuffix}", [cB]: aC, [cH]: al }, [ct]: n }, { [cv]: [ar, X, aA, aq, aD, aE], [cu]: [{ endpoint: aI, [ct]: n }], [ct]: o }, { [cv]: [ar, X, aA, aq, aD, aH], endpoint: aI, [ct]: n }, { [cv]: [Y, as, W, aq, aB], endpoint: { [cA]: "https://{Bucket}.s3-accelerate.dualstack.us-east-1.{partitionResult#dnsSuffix}", [cB]: aC, [cH]: al }, [ct]: n }, { [cv]: [Y, as, W, aq, aD, aE], [cu]: [{ endpoint: aJ, [ct]: n }], [ct]: o }, { [cv]: [Y, as, W, aq, aD, aH], endpoint: aJ, [ct]: n }, { [cv]: [Y, as, aA, aq, aB], endpoint: { [cA]: "https://{Bucket}.s3.dualstack.us-east-1.{partitionResult#dnsSuffix}", [cB]: aC, [cH]: al }, [ct]: n }, { [cv]: [Y, as, aA, aq, aD, aE], [cu]: [{ endpoint: aK, [ct]: n }], [ct]: o }, { [cv]: [Y, as, aA, aq, aD, aH], endpoint: aK, [ct]: n }, { [cv]: [ar, as, aA, Z, ag, ah, aB], endpoint: { [cA]: C, [cB]: aC, [cH]: al }, [ct]: n }, { [cv]: [ar, as, aA, Z, ag, aL, aB], endpoint: { [cA]: q, [cB]: aC, [cH]: al }, [ct]: n }, { [cv]: [ar, as, aA, Z, ag, ah, aD, aE], [cu]: [{ [cv]: cd, endpoint: aM, [ct]: n }, { endpoint: aM, [ct]: n }], [ct]: o }, { [cv]: [ar, as, aA, Z, ag, aL, aD, aE], [cu]: [{ [cv]: cd, endpoint: aN, [ct]: n }, aO], [ct]: o }, { [cv]: [ar, as, aA, Z, ag, ah, aD, aH], endpoint: aM, [ct]: n }, { [cv]: [ar, as, aA, Z, ag, aL, aD, aH], endpoint: aN, [ct]: n }, { [cv]: [ar, as, W, aq, aB], endpoint: { [cA]: D, [cB]: aC, [cH]: al }, [ct]: n }, { [cv]: [ar, as, W, aq, aD, aE], [cu]: [{ [cv]: cd, endpoint: aP, [ct]: n }, { endpoint: aP, [ct]: n }], [ct]: o }, { [cv]: [ar, as, W, aq, aD, aH], endpoint: aP, [ct]: n }, { [cv]: [ar, as, aA, aq, aB], endpoint: { [cA]: E, [cB]: aC, [cH]: al }, [ct]: n }, { [cv]: [ar, as, aA, aq, aD, aE], [cu]: [{ [cv]: cd, endpoint: { [cA]: E, [cB]: aG, [cH]: al }, [ct]: n }, { endpoint: aQ, [ct]: n }], [ct]: o }, { [cv]: [ar, as, aA, aq, aD, aH], endpoint: aQ, [ct]: n }], [ct]: o }, aR], [ct]: o }], [ct]: o }, { [cv]: [Z, ag, { [cw]: h, [cx]: [{ [cw]: i, [cx]: [ai, "scheme"] }, "http"] }, { [cw]: p, [cx]: [ad, c] }, ay, as, ar, aA], [cu]: [{ [cv]: bG, [cu]: [{ [cv]: cc, [cu]: [aO], [ct]: o }, aR], [ct]: o }], [ct]: o }, { [cv]: [ay, { [cw]: F, [cx]: bA, [cz]: G }], [cu]: [{ [cv]: [{ [cw]: i, [cx]: [aS, "resourceId[0]"], [cz]: H }, { [cw]: r, [cx]: [{ [cw]: h, [cx]: [aT, I] }] }], [cu]: [{ [cv]: [{ [cw]: h, [cx]: [aU, J] }], [cu]: [{ [cv]: ce, [cu]: [{ [cv]: cf, [cu]: [aW, aX, { [cv]: ci, [cu]: [aY, { [cv]: cj, [cu]: [aZ, { [cv]: cl, [cu]: [{ [cv]: bG, [cu]: [{ [cv]: cm, [cu]: [{ [cv]: cn, [cu]: [{ [cv]: [{ [cw]: h, [cx]: [bb, I] }], error: "Invalid ARN: Missing account id", [ct]: f }, { [cv]: co, [cu]: [{ [cv]: cp, [cu]: [{ [cv]: bC, endpoint: { [cA]: M, [cB]: bc, [cH]: al }, [ct]: n }, { [cv]: cq, endpoint: { [cA]: "https://{accessPointName}-{bucketArn#accountId}.s3-object-lambda-fips.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cB]: bc, [cH]: al }, [ct]: n }, { endpoint: { [cA]: "https://{accessPointName}-{bucketArn#accountId}.s3-object-lambda.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cB]: bc, [cH]: al }, [ct]: n }], [ct]: o }, bd], [ct]: o }, be], [ct]: o }, bf], [ct]: o }, bg], [ct]: o }], [ct]: o }], [ct]: o }, bh], [ct]: o }, { error: "Invalid ARN: bucket ARN is missing a region", [ct]: f }], [ct]: o }, bi], [ct]: o }, { error: "Invalid ARN: Object Lambda ARNs only support `accesspoint` arn types, but found: `{arnType}`", [ct]: f }], [ct]: o }, { [cv]: ce, [cu]: [{ [cv]: cf, [cu]: [{ [cv]: ci, [cu]: [{ [cv]: ce, [cu]: [{ [cv]: ci, [cu]: [aY, { [cv]: cj, [cu]: [aZ, { [cv]: cl, [cu]: [{ [cv]: bG, [cu]: [{ [cv]: [{ [cw]: h, [cx]: [ba, "{partitionResult#name}"] }], [cu]: [{ [cv]: cn, [cu]: [{ [cv]: [{ [cw]: h, [cx]: [aU, B] }], [cu]: [{ [cv]: co, [cu]: [{ [cv]: cp, [cu]: [{ [cv]: bB, error: "Access Points do not support S3 Accelerate", [ct]: f }, { [cv]: bH, endpoint: { [cA]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint-fips.dualstack.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cB]: bj, [cH]: al }, [ct]: n }, { [cv]: bI, endpoint: { [cA]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint-fips.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cB]: bj, [cH]: al }, [ct]: n }, { [cv]: bJ, endpoint: { [cA]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint.dualstack.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cB]: bj, [cH]: al }, [ct]: n }, { [cv]: [as, ar, Z, ag], endpoint: { [cA]: M, [cB]: bj, [cH]: al }, [ct]: n }, { [cv]: bK, endpoint: { [cA]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cB]: bj, [cH]: al }, [ct]: n }], [ct]: o }, bd], [ct]: o }, be], [ct]: o }, { error: "Invalid ARN: The ARN was not for the S3 service, found: {bucketArn#service}", [ct]: f }], [ct]: o }, bf], [ct]: o }, bg], [ct]: o }], [ct]: o }], [ct]: o }, bh], [ct]: o }], [ct]: o }], [ct]: o }, { [cv]: [{ [cw]: y, [cx]: [aV, c] }], [cu]: [{ [cv]: ch, error: "S3 MRAP does not support dual-stack", [ct]: f }, { [cv]: cq, error: "S3 MRAP does not support FIPS", [ct]: f }, { [cv]: bB, error: "S3 MRAP does not support S3 Accelerate", [ct]: f }, { [cv]: [{ [cw]: e, [cx]: [{ [cy]: "DisableMultiRegionAccessPoints" }, c] }], error: "Invalid configuration: Multi-Region Access Point ARNs are disabled.", [ct]: f }, { [cv]: [{ [cw]: g, [cx]: by, [cz]: N }], [cu]: [{ [cv]: [{ [cw]: h, [cx]: [{ [cw]: i, [cx]: [{ [cy]: N }, j] }, { [cw]: i, [cx]: [aS, "partition"] }] }], [cu]: [{ endpoint: { [cA]: "https://{accessPointName}.accesspoint.s3-global.{mrapPartition#dnsSuffix}", [cB]: { [cD]: [{ [cE]: c, name: z, [cF]: B, [cI]: cb }] }, [cH]: al }, [ct]: n }], [ct]: o }, { error: "Client was configured for partition `{mrapPartition#name}` but bucket referred to partition `{bucketArn#partition}`", [ct]: f }], [ct]: o }], [ct]: o }, { error: "Invalid Access Point Name", [ct]: f }], [ct]: o }, bi], [ct]: o }, { [cv]: [{ [cw]: h, [cx]: [aU, A] }], [cu]: [{ [cv]: ch, error: "S3 Outposts does not support Dual-stack", [ct]: f }, { [cv]: cq, error: "S3 Outposts does not support FIPS", [ct]: f }, { [cv]: bB, error: "S3 Outposts does not support S3 Accelerate", [ct]: f }, { [cv]: [{ [cw]: d, [cx]: [{ [cw]: i, [cx]: [aS, "resourceId[4]"] }] }], error: "Invalid Arn: Outpost Access Point ARN contains sub resources", [ct]: f }, { [cv]: [{ [cw]: i, [cx]: cg, [cz]: x }], [cu]: [{ [cv]: bZ, [cu]: [aZ, { [cv]: cl, [cu]: [{ [cv]: bG, [cu]: [{ [cv]: cm, [cu]: [{ [cv]: cn, [cu]: [{ [cv]: co, [cu]: [{ [cv]: [{ [cw]: i, [cx]: ck, [cz]: O }], [cu]: [{ [cv]: [{ [cw]: i, [cx]: [aS, "resourceId[3]"], [cz]: L }], [cu]: [{ [cv]: [{ [cw]: h, [cx]: [{ [cy]: O }, K] }], [cu]: [{ [cv]: bC, endpoint: { [cA]: "https://{accessPointName}-{bucketArn#accountId}.{outpostId}.{url#authority}", [cB]: bk, [cH]: al }, [ct]: n }, { endpoint: { [cA]: "https://{accessPointName}-{bucketArn#accountId}.{outpostId}.s3-outposts.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cB]: bk, [cH]: al }, [ct]: n }], [ct]: o }, { error: "Expected an outpost type `accesspoint`, found {outpostType}", [ct]: f }], [ct]: o }, { error: "Invalid ARN: expected an access point name", [ct]: f }], [ct]: o }, { error: "Invalid ARN: Expected a 4-component resource", [ct]: f }], [ct]: o }, be], [ct]: o }, bf], [ct]: o }, bg], [ct]: o }], [ct]: o }], [ct]: o }, { error: "Invalid ARN: The outpost Id may only contain a-z, A-Z, 0-9 and `-`. Found: `{outpostId}`", [ct]: f }], [ct]: o }, { error: "Invalid ARN: The Outpost Id was not set", [ct]: f }], [ct]: o }, { error: "Invalid ARN: Unrecognized format: {Bucket} (type: {arnType})", [ct]: f }], [ct]: o }, { error: "Invalid ARN: No ARN type specified", [ct]: f }], [ct]: o }, { [cv]: [{ [cw]: k, [cx]: [ad, 0, 4, b], [cz]: P }, { [cw]: h, [cx]: [{ [cy]: P }, "arn:"] }, { [cw]: r, [cx]: [{ [cw]: d, [cx]: [bl] }] }], error: "Invalid ARN: `{Bucket}` was not a valid ARN", [ct]: f }, { [cv]: [{ [cw]: e, [cx]: [az, c] }, bl], error: "Path-style addressing cannot be used with ARN buckets", [ct]: f }, { [cv]: bE, [cu]: [{ [cv]: bG, [cu]: [{ [cv]: [aA], [cu]: [{ [cv]: [Y, aq, X, aB], endpoint: { [cA]: "https://s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cB]: aC, [cH]: al }, [ct]: n }, { [cv]: [Y, aq, X, aD, aE], [cu]: [{ endpoint: bm, [ct]: n }], [ct]: o }, { [cv]: [Y, aq, X, aD, aH], endpoint: bm, [ct]: n }, { [cv]: [ar, aq, X, aB], endpoint: { [cA]: "https://s3-fips.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cB]: aC, [cH]: al }, [ct]: n }, { [cv]: [ar, aq, X, aD, aE], [cu]: [{ endpoint: bn, [ct]: n }], [ct]: o }, { [cv]: [ar, aq, X, aD, aH], endpoint: bn, [ct]: n }, { [cv]: [Y, aq, as, aB], endpoint: { [cA]: "https://s3.dualstack.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cB]: aC, [cH]: al }, [ct]: n }, { [cv]: [Y, aq, as, aD, aE], [cu]: [{ endpoint: bo, [ct]: n }], [ct]: o }, { [cv]: [Y, aq, as, aD, aH], endpoint: bo, [ct]: n }, { [cv]: [ar, Z, ag, as, aB], endpoint: { [cA]: Q, [cB]: aC, [cH]: al }, [ct]: n }, { [cv]: [ar, Z, ag, as, aD, aE], [cu]: [{ [cv]: cd, endpoint: bp, [ct]: n }, { endpoint: bp, [ct]: n }], [ct]: o }, { [cv]: [ar, Z, ag, as, aD, aH], endpoint: bp, [ct]: n }, { [cv]: [ar, aq, as, aB], endpoint: { [cA]: R, [cB]: aC, [cH]: al }, [ct]: n }, { [cv]: [ar, aq, as, aD, aE], [cu]: [{ [cv]: cd, endpoint: { [cA]: R, [cB]: aG, [cH]: al }, [ct]: n }, { endpoint: bq, [ct]: n }], [ct]: o }, { [cv]: [ar, aq, as, aD, aH], endpoint: bq, [ct]: n }], [ct]: o }, { error: "Path-style addressing cannot be used with S3 Accelerate", [ct]: f }], [ct]: o }], [ct]: o }], [ct]: o }, { [cv]: [{ [cw]: d, [cx]: [br] }, { [cw]: e, [cx]: [br, c] }], [cu]: [{ [cv]: bG, [cu]: [{ [cv]: cr, [cu]: [aW, aX, { [cv]: bC, endpoint: { [cA]: t, [cB]: bs, [cH]: al }, [ct]: n }, { [cv]: cq, endpoint: { [cA]: "https://s3-object-lambda-fips.{Region}.{partitionResult#dnsSuffix}", [cB]: bs, [cH]: al }, [ct]: n }, { endpoint: { [cA]: "https://s3-object-lambda.{Region}.{partitionResult#dnsSuffix}", [cB]: bs, [cH]: al }, [ct]: n }], [ct]: o }, aR], [ct]: o }], [ct]: o }, { [cv]: [au], [cu]: [{ [cv]: bG, [cu]: [{ [cv]: cr, [cu]: [{ [cv]: [X, Y, aq, aB], endpoint: { [cA]: "https://s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}", [cB]: aC, [cH]: al }, [ct]: n }, { [cv]: [X, Y, aq, aD, aE], [cu]: [{ endpoint: bt, [ct]: n }], [ct]: o }, { [cv]: [X, Y, aq, aD, aH], endpoint: bt, [ct]: n }, { [cv]: [X, ar, aq, aB], endpoint: { [cA]: "https://s3-fips.us-east-1.{partitionResult#dnsSuffix}", [cB]: aC, [cH]: al }, [ct]: n }, { [cv]: [X, ar, aq, aD, aE], [cu]: [{ endpoint: bu, [ct]: n }], [ct]: o }, { [cv]: [X, ar, aq, aD, aH], endpoint: bu, [ct]: n }, { [cv]: [as, Y, aq, aB], endpoint: { [cA]: "https://s3.dualstack.us-east-1.{partitionResult#dnsSuffix}", [cB]: aC, [cH]: al }, [ct]: n }, { [cv]: [as, Y, aq, aD, aE], [cu]: [{ endpoint: bv, [ct]: n }], [ct]: o }, { [cv]: [as, Y, aq, aD, aH], endpoint: bv, [ct]: n }, { [cv]: [as, ar, Z, ag, aB], endpoint: { [cA]: t, [cB]: aC, [cH]: al }, [ct]: n }, { [cv]: [as, ar, Z, ag, aD, aE], [cu]: [{ [cv]: cd, endpoint: bw, [ct]: n }, { endpoint: bw, [ct]: n }], [ct]: o }, { [cv]: [as, ar, Z, ag, aD, aH], endpoint: bw, [ct]: n }, { [cv]: [as, ar, aq, aB], endpoint: { [cA]: S, [cB]: aC, [cH]: al }, [ct]: n }, { [cv]: [as, ar, aq, aD, aE], [cu]: [{ [cv]: cd, endpoint: { [cA]: S, [cB]: aG, [cH]: al }, [ct]: n }, { endpoint: bx, [ct]: n }], [ct]: o }, { [cv]: [as, ar, aq, aD, aH], endpoint: bx, [ct]: n }], [ct]: o }, aR], [ct]: o }], [ct]: o }], [ct]: o }, { error: "A region must be set when sending requests to S3.", [ct]: f }] };
    ruleSet = _data;
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/endpoint/endpointResolver.js
var cache, defaultEndpointResolver;
var init_endpointResolver = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/endpoint/endpointResolver.js"() {
    "use strict";
    init_dist_es33();
    init_dist_es30();
    init_ruleset();
    cache = new EndpointCache({
      size: 50,
      params: [
        "Accelerate",
        "Bucket",
        "DisableAccessPoints",
        "DisableMultiRegionAccessPoints",
        "DisableS3ExpressSessionAuth",
        "Endpoint",
        "ForcePathStyle",
        "Region",
        "UseArnRegion",
        "UseDualStack",
        "UseFIPS",
        "UseGlobalEndpoint",
        "UseObjectLambdaEndpoint",
        "UseS3ExpressControlEndpoint"
      ]
    });
    defaultEndpointResolver = (endpointParams, context = {}) => {
      return cache.get(endpointParams, () => resolveEndpoint(ruleSet, {
        endpointParams,
        logger: context.logger
      }));
    };
    customEndpointFunctions.aws = awsEndpointFunctions;
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/auth/httpAuthSchemeProvider.js
function createAwsAuthSigv4HttpAuthOption(authParameters) {
  return {
    schemeId: "aws.auth#sigv4",
    signingProperties: {
      name: "s3",
      region: authParameters.region
    },
    propertiesExtractor: (config, context) => ({
      signingProperties: {
        config,
        context
      }
    })
  };
}
function createAwsAuthSigv4aHttpAuthOption(authParameters) {
  return {
    schemeId: "aws.auth#sigv4a",
    signingProperties: {
      name: "s3",
      region: authParameters.region
    },
    propertiesExtractor: (config, context) => ({
      signingProperties: {
        config,
        context
      }
    })
  };
}
var createEndpointRuleSetHttpAuthSchemeParametersProvider, _defaultS3HttpAuthSchemeParametersProvider, defaultS3HttpAuthSchemeParametersProvider, createEndpointRuleSetHttpAuthSchemeProvider, _defaultS3HttpAuthSchemeProvider, defaultS3HttpAuthSchemeProvider, resolveHttpAuthSchemeConfig;
var init_httpAuthSchemeProvider = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/auth/httpAuthSchemeProvider.js"() {
    "use strict";
    init_dist_es22();
    init_dist_es42();
    init_dist_es38();
    init_dist_es4();
    init_endpointResolver();
    createEndpointRuleSetHttpAuthSchemeParametersProvider = (defaultHttpAuthSchemeParametersProvider) => async (config, context, input) => {
      if (!input) {
        throw new Error(`Could not find \`input\` for \`defaultEndpointRuleSetHttpAuthSchemeParametersProvider\``);
      }
      const defaultParameters = await defaultHttpAuthSchemeParametersProvider(config, context, input);
      const instructionsFn = getSmithyContext(context)?.commandInstance?.constructor?.getEndpointParameterInstructions;
      if (!instructionsFn) {
        throw new Error(`getEndpointParameterInstructions() is not defined on \`${context.commandName}\``);
      }
      const endpointParameters = await resolveParams(input, { getEndpointParameterInstructions: instructionsFn }, config);
      return Object.assign(defaultParameters, endpointParameters);
    };
    _defaultS3HttpAuthSchemeParametersProvider = async (config, context, input) => {
      return {
        operation: getSmithyContext(context).operation,
        region: await normalizeProvider(config.region)() || (() => {
          throw new Error("expected `region` to be configured for `aws.auth#sigv4`");
        })()
      };
    };
    defaultS3HttpAuthSchemeParametersProvider = createEndpointRuleSetHttpAuthSchemeParametersProvider(_defaultS3HttpAuthSchemeParametersProvider);
    createEndpointRuleSetHttpAuthSchemeProvider = (defaultEndpointResolver2, defaultHttpAuthSchemeResolver, createHttpAuthOptionFunctions) => {
      const endpointRuleSetHttpAuthSchemeProvider = (authParameters) => {
        const endpoint = defaultEndpointResolver2(authParameters);
        const authSchemes = endpoint.properties?.authSchemes;
        if (!authSchemes) {
          return defaultHttpAuthSchemeResolver(authParameters);
        }
        const options = [];
        for (const scheme of authSchemes) {
          const { name: resolvedName, properties = {}, ...rest } = scheme;
          const name = resolvedName.toLowerCase();
          if (resolvedName !== name) {
            console.warn(`HttpAuthScheme has been normalized with lowercasing: \`${resolvedName}\` to \`${name}\``);
          }
          let schemeId;
          if (name === "sigv4a") {
            schemeId = "aws.auth#sigv4a";
            const sigv4Present = authSchemes.find((s2) => {
              const name2 = s2.name.toLowerCase();
              return name2 !== "sigv4a" && name2.startsWith("sigv4");
            });
            if (SignatureV4MultiRegion.sigv4aDependency() === "none" && sigv4Present) {
              continue;
            }
          } else if (name.startsWith("sigv4")) {
            schemeId = "aws.auth#sigv4";
          } else {
            throw new Error(`Unknown HttpAuthScheme found in \`@smithy.rules#endpointRuleSet\`: \`${name}\``);
          }
          const createOption = createHttpAuthOptionFunctions[schemeId];
          if (!createOption) {
            throw new Error(`Could not find HttpAuthOption create function for \`${schemeId}\``);
          }
          const option = createOption(authParameters);
          option.schemeId = schemeId;
          option.signingProperties = { ...option.signingProperties || {}, ...rest, ...properties };
          options.push(option);
        }
        return options;
      };
      return endpointRuleSetHttpAuthSchemeProvider;
    };
    _defaultS3HttpAuthSchemeProvider = (authParameters) => {
      const options = [];
      switch (authParameters.operation) {
        default: {
          options.push(createAwsAuthSigv4HttpAuthOption(authParameters));
          options.push(createAwsAuthSigv4aHttpAuthOption(authParameters));
        }
      }
      return options;
    };
    defaultS3HttpAuthSchemeProvider = createEndpointRuleSetHttpAuthSchemeProvider(defaultEndpointResolver, _defaultS3HttpAuthSchemeProvider, {
      "aws.auth#sigv4": createAwsAuthSigv4HttpAuthOption,
      "aws.auth#sigv4a": createAwsAuthSigv4aHttpAuthOption
    });
    resolveHttpAuthSchemeConfig = (config) => {
      const config_0 = resolveAwsSdkSigV4Config(config);
      const config_1 = resolveAwsSdkSigV4AConfig(config_0);
      return Object.assign(config_1, {
        authSchemePreference: normalizeProvider(config.authSchemePreference ?? [])
      });
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/endpoint/EndpointParameters.js
var resolveClientEndpointParameters, commonParams;
var init_EndpointParameters = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/endpoint/EndpointParameters.js"() {
    "use strict";
    resolveClientEndpointParameters = (options) => {
      return Object.assign(options, {
        useFipsEndpoint: options.useFipsEndpoint ?? false,
        useDualstackEndpoint: options.useDualstackEndpoint ?? false,
        forcePathStyle: options.forcePathStyle ?? false,
        useAccelerateEndpoint: options.useAccelerateEndpoint ?? false,
        useGlobalEndpoint: options.useGlobalEndpoint ?? false,
        disableMultiregionAccessPoints: options.disableMultiregionAccessPoints ?? false,
        defaultSigningName: "s3"
      });
    };
    commonParams = {
      ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
      UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
      DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
      Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
      DisableS3ExpressSessionAuth: { type: "clientContextParams", name: "disableS3ExpressSessionAuth" },
      UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/models/S3ServiceException.js
var S3ServiceException;
var init_S3ServiceException = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/models/S3ServiceException.js"() {
    "use strict";
    init_dist_es20();
    S3ServiceException = class _S3ServiceException extends ServiceException {
      constructor(options) {
        super(options);
        Object.setPrototypeOf(this, _S3ServiceException.prototype);
      }
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/models/models_0.js
var RequestCharged, RequestPayer, NoSuchUpload, BucketAccelerateStatus, Type, Permission, OwnerOverride, ChecksumType, ServerSideEncryption, ObjectCannedACL, ChecksumAlgorithm2, MetadataDirective, ObjectLockLegalHoldStatus, ObjectLockMode, StorageClass, TaggingDirective, ObjectNotInActiveTierError, BucketAlreadyExists, BucketAlreadyOwnedByYou, BucketCannedACL, DataRedundancy, BucketType, LocationType, BucketLocationConstraint, ObjectOwnership, InventoryConfigurationState, TableSseAlgorithm, ExpirationState, SessionMode, NoSuchBucket, AnalyticsFilter, AnalyticsS3ExportFileFormat, StorageClassAnalysisSchemaVersion, IntelligentTieringStatus, IntelligentTieringAccessTier, InventoryFormat, InventoryIncludedObjectVersions, InventoryOptionalField, InventoryFrequency, TransitionStorageClass, ExpirationStatus, TransitionDefaultMinimumObjectSize, BucketLogsPermission, PartitionDateSource, S3TablesBucketType, MetricsFilter, Event, FilterRuleName, DeleteMarkerReplicationStatus, MetricsStatus, ReplicationTimeStatus, ExistingObjectReplicationStatus, ReplicaModificationsStatus, SseKmsEncryptedObjectsStatus, ReplicationRuleStatus, Payer, MFADeleteStatus, BucketVersioningStatus, Protocol, ReplicationStatus, ChecksumMode, InvalidObjectState, NoSuchKey, ObjectAttributes, ObjectLockEnabled, ObjectLockRetentionMode, NotFound, ArchiveStatus, EncodingType, CompleteMultipartUploadOutputFilterSensitiveLog, CompleteMultipartUploadRequestFilterSensitiveLog, CopyObjectOutputFilterSensitiveLog, CopyObjectRequestFilterSensitiveLog, CreateMultipartUploadOutputFilterSensitiveLog, CreateMultipartUploadRequestFilterSensitiveLog, SessionCredentialsFilterSensitiveLog, CreateSessionOutputFilterSensitiveLog, CreateSessionRequestFilterSensitiveLog, ServerSideEncryptionByDefaultFilterSensitiveLog, ServerSideEncryptionRuleFilterSensitiveLog, ServerSideEncryptionConfigurationFilterSensitiveLog, GetBucketEncryptionOutputFilterSensitiveLog, SSEKMSFilterSensitiveLog, InventoryEncryptionFilterSensitiveLog, InventoryS3BucketDestinationFilterSensitiveLog, InventoryDestinationFilterSensitiveLog, InventoryConfigurationFilterSensitiveLog, GetBucketInventoryConfigurationOutputFilterSensitiveLog, GetObjectOutputFilterSensitiveLog, GetObjectRequestFilterSensitiveLog, GetObjectAttributesRequestFilterSensitiveLog, GetObjectTorrentOutputFilterSensitiveLog, HeadObjectOutputFilterSensitiveLog, HeadObjectRequestFilterSensitiveLog, ListBucketInventoryConfigurationsOutputFilterSensitiveLog;
var init_models_0 = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/models/models_0.js"() {
    "use strict";
    init_dist_es20();
    init_S3ServiceException();
    RequestCharged = {
      requester: "requester"
    };
    RequestPayer = {
      requester: "requester"
    };
    NoSuchUpload = class _NoSuchUpload extends S3ServiceException {
      name = "NoSuchUpload";
      $fault = "client";
      constructor(opts) {
        super({
          name: "NoSuchUpload",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _NoSuchUpload.prototype);
      }
    };
    BucketAccelerateStatus = {
      Enabled: "Enabled",
      Suspended: "Suspended"
    };
    Type = {
      AmazonCustomerByEmail: "AmazonCustomerByEmail",
      CanonicalUser: "CanonicalUser",
      Group: "Group"
    };
    Permission = {
      FULL_CONTROL: "FULL_CONTROL",
      READ: "READ",
      READ_ACP: "READ_ACP",
      WRITE: "WRITE",
      WRITE_ACP: "WRITE_ACP"
    };
    OwnerOverride = {
      Destination: "Destination"
    };
    ChecksumType = {
      COMPOSITE: "COMPOSITE",
      FULL_OBJECT: "FULL_OBJECT"
    };
    ServerSideEncryption = {
      AES256: "AES256",
      aws_fsx: "aws:fsx",
      aws_kms: "aws:kms",
      aws_kms_dsse: "aws:kms:dsse"
    };
    ObjectCannedACL = {
      authenticated_read: "authenticated-read",
      aws_exec_read: "aws-exec-read",
      bucket_owner_full_control: "bucket-owner-full-control",
      bucket_owner_read: "bucket-owner-read",
      private: "private",
      public_read: "public-read",
      public_read_write: "public-read-write"
    };
    ChecksumAlgorithm2 = {
      CRC32: "CRC32",
      CRC32C: "CRC32C",
      CRC64NVME: "CRC64NVME",
      SHA1: "SHA1",
      SHA256: "SHA256"
    };
    MetadataDirective = {
      COPY: "COPY",
      REPLACE: "REPLACE"
    };
    ObjectLockLegalHoldStatus = {
      OFF: "OFF",
      ON: "ON"
    };
    ObjectLockMode = {
      COMPLIANCE: "COMPLIANCE",
      GOVERNANCE: "GOVERNANCE"
    };
    StorageClass = {
      DEEP_ARCHIVE: "DEEP_ARCHIVE",
      EXPRESS_ONEZONE: "EXPRESS_ONEZONE",
      FSX_OPENZFS: "FSX_OPENZFS",
      GLACIER: "GLACIER",
      GLACIER_IR: "GLACIER_IR",
      INTELLIGENT_TIERING: "INTELLIGENT_TIERING",
      ONEZONE_IA: "ONEZONE_IA",
      OUTPOSTS: "OUTPOSTS",
      REDUCED_REDUNDANCY: "REDUCED_REDUNDANCY",
      SNOW: "SNOW",
      STANDARD: "STANDARD",
      STANDARD_IA: "STANDARD_IA"
    };
    TaggingDirective = {
      COPY: "COPY",
      REPLACE: "REPLACE"
    };
    ObjectNotInActiveTierError = class _ObjectNotInActiveTierError extends S3ServiceException {
      name = "ObjectNotInActiveTierError";
      $fault = "client";
      constructor(opts) {
        super({
          name: "ObjectNotInActiveTierError",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _ObjectNotInActiveTierError.prototype);
      }
    };
    BucketAlreadyExists = class _BucketAlreadyExists extends S3ServiceException {
      name = "BucketAlreadyExists";
      $fault = "client";
      constructor(opts) {
        super({
          name: "BucketAlreadyExists",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _BucketAlreadyExists.prototype);
      }
    };
    BucketAlreadyOwnedByYou = class _BucketAlreadyOwnedByYou extends S3ServiceException {
      name = "BucketAlreadyOwnedByYou";
      $fault = "client";
      constructor(opts) {
        super({
          name: "BucketAlreadyOwnedByYou",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _BucketAlreadyOwnedByYou.prototype);
      }
    };
    BucketCannedACL = {
      authenticated_read: "authenticated-read",
      private: "private",
      public_read: "public-read",
      public_read_write: "public-read-write"
    };
    DataRedundancy = {
      SingleAvailabilityZone: "SingleAvailabilityZone",
      SingleLocalZone: "SingleLocalZone"
    };
    BucketType = {
      Directory: "Directory"
    };
    LocationType = {
      AvailabilityZone: "AvailabilityZone",
      LocalZone: "LocalZone"
    };
    BucketLocationConstraint = {
      EU: "EU",
      af_south_1: "af-south-1",
      ap_east_1: "ap-east-1",
      ap_northeast_1: "ap-northeast-1",
      ap_northeast_2: "ap-northeast-2",
      ap_northeast_3: "ap-northeast-3",
      ap_south_1: "ap-south-1",
      ap_south_2: "ap-south-2",
      ap_southeast_1: "ap-southeast-1",
      ap_southeast_2: "ap-southeast-2",
      ap_southeast_3: "ap-southeast-3",
      ap_southeast_4: "ap-southeast-4",
      ap_southeast_5: "ap-southeast-5",
      ca_central_1: "ca-central-1",
      cn_north_1: "cn-north-1",
      cn_northwest_1: "cn-northwest-1",
      eu_central_1: "eu-central-1",
      eu_central_2: "eu-central-2",
      eu_north_1: "eu-north-1",
      eu_south_1: "eu-south-1",
      eu_south_2: "eu-south-2",
      eu_west_1: "eu-west-1",
      eu_west_2: "eu-west-2",
      eu_west_3: "eu-west-3",
      il_central_1: "il-central-1",
      me_central_1: "me-central-1",
      me_south_1: "me-south-1",
      sa_east_1: "sa-east-1",
      us_east_2: "us-east-2",
      us_gov_east_1: "us-gov-east-1",
      us_gov_west_1: "us-gov-west-1",
      us_west_1: "us-west-1",
      us_west_2: "us-west-2"
    };
    ObjectOwnership = {
      BucketOwnerEnforced: "BucketOwnerEnforced",
      BucketOwnerPreferred: "BucketOwnerPreferred",
      ObjectWriter: "ObjectWriter"
    };
    InventoryConfigurationState = {
      DISABLED: "DISABLED",
      ENABLED: "ENABLED"
    };
    TableSseAlgorithm = {
      AES256: "AES256",
      aws_kms: "aws:kms"
    };
    ExpirationState = {
      DISABLED: "DISABLED",
      ENABLED: "ENABLED"
    };
    SessionMode = {
      ReadOnly: "ReadOnly",
      ReadWrite: "ReadWrite"
    };
    NoSuchBucket = class _NoSuchBucket extends S3ServiceException {
      name = "NoSuchBucket";
      $fault = "client";
      constructor(opts) {
        super({
          name: "NoSuchBucket",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _NoSuchBucket.prototype);
      }
    };
    (function(AnalyticsFilter2) {
      AnalyticsFilter2.visit = (value, visitor) => {
        if (value.Prefix !== void 0)
          return visitor.Prefix(value.Prefix);
        if (value.Tag !== void 0)
          return visitor.Tag(value.Tag);
        if (value.And !== void 0)
          return visitor.And(value.And);
        return visitor._(value.$unknown[0], value.$unknown[1]);
      };
    })(AnalyticsFilter || (AnalyticsFilter = {}));
    AnalyticsS3ExportFileFormat = {
      CSV: "CSV"
    };
    StorageClassAnalysisSchemaVersion = {
      V_1: "V_1"
    };
    IntelligentTieringStatus = {
      Disabled: "Disabled",
      Enabled: "Enabled"
    };
    IntelligentTieringAccessTier = {
      ARCHIVE_ACCESS: "ARCHIVE_ACCESS",
      DEEP_ARCHIVE_ACCESS: "DEEP_ARCHIVE_ACCESS"
    };
    InventoryFormat = {
      CSV: "CSV",
      ORC: "ORC",
      Parquet: "Parquet"
    };
    InventoryIncludedObjectVersions = {
      All: "All",
      Current: "Current"
    };
    InventoryOptionalField = {
      BucketKeyStatus: "BucketKeyStatus",
      ChecksumAlgorithm: "ChecksumAlgorithm",
      ETag: "ETag",
      EncryptionStatus: "EncryptionStatus",
      IntelligentTieringAccessTier: "IntelligentTieringAccessTier",
      IsMultipartUploaded: "IsMultipartUploaded",
      LastModifiedDate: "LastModifiedDate",
      ObjectAccessControlList: "ObjectAccessControlList",
      ObjectLockLegalHoldStatus: "ObjectLockLegalHoldStatus",
      ObjectLockMode: "ObjectLockMode",
      ObjectLockRetainUntilDate: "ObjectLockRetainUntilDate",
      ObjectOwner: "ObjectOwner",
      ReplicationStatus: "ReplicationStatus",
      Size: "Size",
      StorageClass: "StorageClass"
    };
    InventoryFrequency = {
      Daily: "Daily",
      Weekly: "Weekly"
    };
    TransitionStorageClass = {
      DEEP_ARCHIVE: "DEEP_ARCHIVE",
      GLACIER: "GLACIER",
      GLACIER_IR: "GLACIER_IR",
      INTELLIGENT_TIERING: "INTELLIGENT_TIERING",
      ONEZONE_IA: "ONEZONE_IA",
      STANDARD_IA: "STANDARD_IA"
    };
    ExpirationStatus = {
      Disabled: "Disabled",
      Enabled: "Enabled"
    };
    TransitionDefaultMinimumObjectSize = {
      all_storage_classes_128K: "all_storage_classes_128K",
      varies_by_storage_class: "varies_by_storage_class"
    };
    BucketLogsPermission = {
      FULL_CONTROL: "FULL_CONTROL",
      READ: "READ",
      WRITE: "WRITE"
    };
    PartitionDateSource = {
      DeliveryTime: "DeliveryTime",
      EventTime: "EventTime"
    };
    S3TablesBucketType = {
      aws: "aws",
      customer: "customer"
    };
    (function(MetricsFilter2) {
      MetricsFilter2.visit = (value, visitor) => {
        if (value.Prefix !== void 0)
          return visitor.Prefix(value.Prefix);
        if (value.Tag !== void 0)
          return visitor.Tag(value.Tag);
        if (value.AccessPointArn !== void 0)
          return visitor.AccessPointArn(value.AccessPointArn);
        if (value.And !== void 0)
          return visitor.And(value.And);
        return visitor._(value.$unknown[0], value.$unknown[1]);
      };
    })(MetricsFilter || (MetricsFilter = {}));
    Event = {
      s3_IntelligentTiering: "s3:IntelligentTiering",
      s3_LifecycleExpiration_: "s3:LifecycleExpiration:*",
      s3_LifecycleExpiration_Delete: "s3:LifecycleExpiration:Delete",
      s3_LifecycleExpiration_DeleteMarkerCreated: "s3:LifecycleExpiration:DeleteMarkerCreated",
      s3_LifecycleTransition: "s3:LifecycleTransition",
      s3_ObjectAcl_Put: "s3:ObjectAcl:Put",
      s3_ObjectCreated_: "s3:ObjectCreated:*",
      s3_ObjectCreated_CompleteMultipartUpload: "s3:ObjectCreated:CompleteMultipartUpload",
      s3_ObjectCreated_Copy: "s3:ObjectCreated:Copy",
      s3_ObjectCreated_Post: "s3:ObjectCreated:Post",
      s3_ObjectCreated_Put: "s3:ObjectCreated:Put",
      s3_ObjectRemoved_: "s3:ObjectRemoved:*",
      s3_ObjectRemoved_Delete: "s3:ObjectRemoved:Delete",
      s3_ObjectRemoved_DeleteMarkerCreated: "s3:ObjectRemoved:DeleteMarkerCreated",
      s3_ObjectRestore_: "s3:ObjectRestore:*",
      s3_ObjectRestore_Completed: "s3:ObjectRestore:Completed",
      s3_ObjectRestore_Delete: "s3:ObjectRestore:Delete",
      s3_ObjectRestore_Post: "s3:ObjectRestore:Post",
      s3_ObjectTagging_: "s3:ObjectTagging:*",
      s3_ObjectTagging_Delete: "s3:ObjectTagging:Delete",
      s3_ObjectTagging_Put: "s3:ObjectTagging:Put",
      s3_ReducedRedundancyLostObject: "s3:ReducedRedundancyLostObject",
      s3_Replication_: "s3:Replication:*",
      s3_Replication_OperationFailedReplication: "s3:Replication:OperationFailedReplication",
      s3_Replication_OperationMissedThreshold: "s3:Replication:OperationMissedThreshold",
      s3_Replication_OperationNotTracked: "s3:Replication:OperationNotTracked",
      s3_Replication_OperationReplicatedAfterThreshold: "s3:Replication:OperationReplicatedAfterThreshold"
    };
    FilterRuleName = {
      prefix: "prefix",
      suffix: "suffix"
    };
    DeleteMarkerReplicationStatus = {
      Disabled: "Disabled",
      Enabled: "Enabled"
    };
    MetricsStatus = {
      Disabled: "Disabled",
      Enabled: "Enabled"
    };
    ReplicationTimeStatus = {
      Disabled: "Disabled",
      Enabled: "Enabled"
    };
    ExistingObjectReplicationStatus = {
      Disabled: "Disabled",
      Enabled: "Enabled"
    };
    ReplicaModificationsStatus = {
      Disabled: "Disabled",
      Enabled: "Enabled"
    };
    SseKmsEncryptedObjectsStatus = {
      Disabled: "Disabled",
      Enabled: "Enabled"
    };
    ReplicationRuleStatus = {
      Disabled: "Disabled",
      Enabled: "Enabled"
    };
    Payer = {
      BucketOwner: "BucketOwner",
      Requester: "Requester"
    };
    MFADeleteStatus = {
      Disabled: "Disabled",
      Enabled: "Enabled"
    };
    BucketVersioningStatus = {
      Enabled: "Enabled",
      Suspended: "Suspended"
    };
    Protocol = {
      http: "http",
      https: "https"
    };
    ReplicationStatus = {
      COMPLETE: "COMPLETE",
      COMPLETED: "COMPLETED",
      FAILED: "FAILED",
      PENDING: "PENDING",
      REPLICA: "REPLICA"
    };
    ChecksumMode = {
      ENABLED: "ENABLED"
    };
    InvalidObjectState = class _InvalidObjectState extends S3ServiceException {
      name = "InvalidObjectState";
      $fault = "client";
      StorageClass;
      AccessTier;
      constructor(opts) {
        super({
          name: "InvalidObjectState",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _InvalidObjectState.prototype);
        this.StorageClass = opts.StorageClass;
        this.AccessTier = opts.AccessTier;
      }
    };
    NoSuchKey = class _NoSuchKey extends S3ServiceException {
      name = "NoSuchKey";
      $fault = "client";
      constructor(opts) {
        super({
          name: "NoSuchKey",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _NoSuchKey.prototype);
      }
    };
    ObjectAttributes = {
      CHECKSUM: "Checksum",
      ETAG: "ETag",
      OBJECT_PARTS: "ObjectParts",
      OBJECT_SIZE: "ObjectSize",
      STORAGE_CLASS: "StorageClass"
    };
    ObjectLockEnabled = {
      Enabled: "Enabled"
    };
    ObjectLockRetentionMode = {
      COMPLIANCE: "COMPLIANCE",
      GOVERNANCE: "GOVERNANCE"
    };
    NotFound = class _NotFound extends S3ServiceException {
      name = "NotFound";
      $fault = "client";
      constructor(opts) {
        super({
          name: "NotFound",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _NotFound.prototype);
      }
    };
    ArchiveStatus = {
      ARCHIVE_ACCESS: "ARCHIVE_ACCESS",
      DEEP_ARCHIVE_ACCESS: "DEEP_ARCHIVE_ACCESS"
    };
    EncodingType = {
      url: "url"
    };
    CompleteMultipartUploadOutputFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.SSEKMSKeyId && { SSEKMSKeyId: SENSITIVE_STRING2 }
    });
    CompleteMultipartUploadRequestFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.SSECustomerKey && { SSECustomerKey: SENSITIVE_STRING2 }
    });
    CopyObjectOutputFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.SSEKMSKeyId && { SSEKMSKeyId: SENSITIVE_STRING2 },
      ...obj.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: SENSITIVE_STRING2 }
    });
    CopyObjectRequestFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.SSECustomerKey && { SSECustomerKey: SENSITIVE_STRING2 },
      ...obj.SSEKMSKeyId && { SSEKMSKeyId: SENSITIVE_STRING2 },
      ...obj.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: SENSITIVE_STRING2 },
      ...obj.CopySourceSSECustomerKey && { CopySourceSSECustomerKey: SENSITIVE_STRING2 }
    });
    CreateMultipartUploadOutputFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.SSEKMSKeyId && { SSEKMSKeyId: SENSITIVE_STRING2 },
      ...obj.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: SENSITIVE_STRING2 }
    });
    CreateMultipartUploadRequestFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.SSECustomerKey && { SSECustomerKey: SENSITIVE_STRING2 },
      ...obj.SSEKMSKeyId && { SSEKMSKeyId: SENSITIVE_STRING2 },
      ...obj.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: SENSITIVE_STRING2 }
    });
    SessionCredentialsFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.SecretAccessKey && { SecretAccessKey: SENSITIVE_STRING2 },
      ...obj.SessionToken && { SessionToken: SENSITIVE_STRING2 }
    });
    CreateSessionOutputFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.SSEKMSKeyId && { SSEKMSKeyId: SENSITIVE_STRING2 },
      ...obj.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: SENSITIVE_STRING2 },
      ...obj.Credentials && { Credentials: SessionCredentialsFilterSensitiveLog(obj.Credentials) }
    });
    CreateSessionRequestFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.SSEKMSKeyId && { SSEKMSKeyId: SENSITIVE_STRING2 },
      ...obj.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: SENSITIVE_STRING2 }
    });
    ServerSideEncryptionByDefaultFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.KMSMasterKeyID && { KMSMasterKeyID: SENSITIVE_STRING2 }
    });
    ServerSideEncryptionRuleFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.ApplyServerSideEncryptionByDefault && {
        ApplyServerSideEncryptionByDefault: ServerSideEncryptionByDefaultFilterSensitiveLog(obj.ApplyServerSideEncryptionByDefault)
      }
    });
    ServerSideEncryptionConfigurationFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.Rules && { Rules: obj.Rules.map((item) => ServerSideEncryptionRuleFilterSensitiveLog(item)) }
    });
    GetBucketEncryptionOutputFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.ServerSideEncryptionConfiguration && {
        ServerSideEncryptionConfiguration: ServerSideEncryptionConfigurationFilterSensitiveLog(obj.ServerSideEncryptionConfiguration)
      }
    });
    SSEKMSFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.KeyId && { KeyId: SENSITIVE_STRING2 }
    });
    InventoryEncryptionFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.SSEKMS && { SSEKMS: SSEKMSFilterSensitiveLog(obj.SSEKMS) }
    });
    InventoryS3BucketDestinationFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.Encryption && { Encryption: InventoryEncryptionFilterSensitiveLog(obj.Encryption) }
    });
    InventoryDestinationFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.S3BucketDestination && {
        S3BucketDestination: InventoryS3BucketDestinationFilterSensitiveLog(obj.S3BucketDestination)
      }
    });
    InventoryConfigurationFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.Destination && { Destination: InventoryDestinationFilterSensitiveLog(obj.Destination) }
    });
    GetBucketInventoryConfigurationOutputFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.InventoryConfiguration && {
        InventoryConfiguration: InventoryConfigurationFilterSensitiveLog(obj.InventoryConfiguration)
      }
    });
    GetObjectOutputFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.SSEKMSKeyId && { SSEKMSKeyId: SENSITIVE_STRING2 }
    });
    GetObjectRequestFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.SSECustomerKey && { SSECustomerKey: SENSITIVE_STRING2 }
    });
    GetObjectAttributesRequestFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.SSECustomerKey && { SSECustomerKey: SENSITIVE_STRING2 }
    });
    GetObjectTorrentOutputFilterSensitiveLog = (obj) => ({
      ...obj
    });
    HeadObjectOutputFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.SSEKMSKeyId && { SSEKMSKeyId: SENSITIVE_STRING2 }
    });
    HeadObjectRequestFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.SSECustomerKey && { SSECustomerKey: SENSITIVE_STRING2 }
    });
    ListBucketInventoryConfigurationsOutputFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.InventoryConfigurationList && {
        InventoryConfigurationList: obj.InventoryConfigurationList.map((item) => InventoryConfigurationFilterSensitiveLog(item))
      }
    });
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/models/models_1.js
var ObjectStorageClass, OptionalObjectAttributes, ObjectVersionStorageClass, MFADelete, EncryptionTypeMismatch, InvalidRequest, InvalidWriteOffset, TooManyParts, IdempotencyParameterMismatch, ObjectAlreadyInActiveTierError, Tier, ExpressionType, CompressionType, FileHeaderInfo, JSONType, QuoteFields, RestoreRequestType, SelectObjectContentEventStream, ListPartsRequestFilterSensitiveLog, PutBucketEncryptionRequestFilterSensitiveLog, PutBucketInventoryConfigurationRequestFilterSensitiveLog, PutObjectOutputFilterSensitiveLog, PutObjectRequestFilterSensitiveLog, EncryptionFilterSensitiveLog, S3LocationFilterSensitiveLog, OutputLocationFilterSensitiveLog, RestoreRequestFilterSensitiveLog, RestoreObjectRequestFilterSensitiveLog, SelectObjectContentEventStreamFilterSensitiveLog, SelectObjectContentOutputFilterSensitiveLog, SelectObjectContentRequestFilterSensitiveLog, UploadPartOutputFilterSensitiveLog, UploadPartRequestFilterSensitiveLog, UploadPartCopyOutputFilterSensitiveLog, UploadPartCopyRequestFilterSensitiveLog, WriteGetObjectResponseRequestFilterSensitiveLog;
var init_models_1 = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/models/models_1.js"() {
    "use strict";
    init_dist_es20();
    init_models_0();
    init_S3ServiceException();
    ObjectStorageClass = {
      DEEP_ARCHIVE: "DEEP_ARCHIVE",
      EXPRESS_ONEZONE: "EXPRESS_ONEZONE",
      FSX_OPENZFS: "FSX_OPENZFS",
      GLACIER: "GLACIER",
      GLACIER_IR: "GLACIER_IR",
      INTELLIGENT_TIERING: "INTELLIGENT_TIERING",
      ONEZONE_IA: "ONEZONE_IA",
      OUTPOSTS: "OUTPOSTS",
      REDUCED_REDUNDANCY: "REDUCED_REDUNDANCY",
      SNOW: "SNOW",
      STANDARD: "STANDARD",
      STANDARD_IA: "STANDARD_IA"
    };
    OptionalObjectAttributes = {
      RESTORE_STATUS: "RestoreStatus"
    };
    ObjectVersionStorageClass = {
      STANDARD: "STANDARD"
    };
    MFADelete = {
      Disabled: "Disabled",
      Enabled: "Enabled"
    };
    EncryptionTypeMismatch = class _EncryptionTypeMismatch extends S3ServiceException {
      name = "EncryptionTypeMismatch";
      $fault = "client";
      constructor(opts) {
        super({
          name: "EncryptionTypeMismatch",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _EncryptionTypeMismatch.prototype);
      }
    };
    InvalidRequest = class _InvalidRequest extends S3ServiceException {
      name = "InvalidRequest";
      $fault = "client";
      constructor(opts) {
        super({
          name: "InvalidRequest",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _InvalidRequest.prototype);
      }
    };
    InvalidWriteOffset = class _InvalidWriteOffset extends S3ServiceException {
      name = "InvalidWriteOffset";
      $fault = "client";
      constructor(opts) {
        super({
          name: "InvalidWriteOffset",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _InvalidWriteOffset.prototype);
      }
    };
    TooManyParts = class _TooManyParts extends S3ServiceException {
      name = "TooManyParts";
      $fault = "client";
      constructor(opts) {
        super({
          name: "TooManyParts",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _TooManyParts.prototype);
      }
    };
    IdempotencyParameterMismatch = class _IdempotencyParameterMismatch extends S3ServiceException {
      name = "IdempotencyParameterMismatch";
      $fault = "client";
      constructor(opts) {
        super({
          name: "IdempotencyParameterMismatch",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _IdempotencyParameterMismatch.prototype);
      }
    };
    ObjectAlreadyInActiveTierError = class _ObjectAlreadyInActiveTierError extends S3ServiceException {
      name = "ObjectAlreadyInActiveTierError";
      $fault = "client";
      constructor(opts) {
        super({
          name: "ObjectAlreadyInActiveTierError",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _ObjectAlreadyInActiveTierError.prototype);
      }
    };
    Tier = {
      Bulk: "Bulk",
      Expedited: "Expedited",
      Standard: "Standard"
    };
    ExpressionType = {
      SQL: "SQL"
    };
    CompressionType = {
      BZIP2: "BZIP2",
      GZIP: "GZIP",
      NONE: "NONE"
    };
    FileHeaderInfo = {
      IGNORE: "IGNORE",
      NONE: "NONE",
      USE: "USE"
    };
    JSONType = {
      DOCUMENT: "DOCUMENT",
      LINES: "LINES"
    };
    QuoteFields = {
      ALWAYS: "ALWAYS",
      ASNEEDED: "ASNEEDED"
    };
    RestoreRequestType = {
      SELECT: "SELECT"
    };
    (function(SelectObjectContentEventStream2) {
      SelectObjectContentEventStream2.visit = (value, visitor) => {
        if (value.Records !== void 0)
          return visitor.Records(value.Records);
        if (value.Stats !== void 0)
          return visitor.Stats(value.Stats);
        if (value.Progress !== void 0)
          return visitor.Progress(value.Progress);
        if (value.Cont !== void 0)
          return visitor.Cont(value.Cont);
        if (value.End !== void 0)
          return visitor.End(value.End);
        return visitor._(value.$unknown[0], value.$unknown[1]);
      };
    })(SelectObjectContentEventStream || (SelectObjectContentEventStream = {}));
    ListPartsRequestFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.SSECustomerKey && { SSECustomerKey: SENSITIVE_STRING2 }
    });
    PutBucketEncryptionRequestFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.ServerSideEncryptionConfiguration && {
        ServerSideEncryptionConfiguration: ServerSideEncryptionConfigurationFilterSensitiveLog(obj.ServerSideEncryptionConfiguration)
      }
    });
    PutBucketInventoryConfigurationRequestFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.InventoryConfiguration && {
        InventoryConfiguration: InventoryConfigurationFilterSensitiveLog(obj.InventoryConfiguration)
      }
    });
    PutObjectOutputFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.SSEKMSKeyId && { SSEKMSKeyId: SENSITIVE_STRING2 },
      ...obj.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: SENSITIVE_STRING2 }
    });
    PutObjectRequestFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.SSECustomerKey && { SSECustomerKey: SENSITIVE_STRING2 },
      ...obj.SSEKMSKeyId && { SSEKMSKeyId: SENSITIVE_STRING2 },
      ...obj.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: SENSITIVE_STRING2 }
    });
    EncryptionFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.KMSKeyId && { KMSKeyId: SENSITIVE_STRING2 }
    });
    S3LocationFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.Encryption && { Encryption: EncryptionFilterSensitiveLog(obj.Encryption) }
    });
    OutputLocationFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.S3 && { S3: S3LocationFilterSensitiveLog(obj.S3) }
    });
    RestoreRequestFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.OutputLocation && { OutputLocation: OutputLocationFilterSensitiveLog(obj.OutputLocation) }
    });
    RestoreObjectRequestFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.RestoreRequest && { RestoreRequest: RestoreRequestFilterSensitiveLog(obj.RestoreRequest) }
    });
    SelectObjectContentEventStreamFilterSensitiveLog = (obj) => {
      if (obj.Records !== void 0)
        return { Records: obj.Records };
      if (obj.Stats !== void 0)
        return { Stats: obj.Stats };
      if (obj.Progress !== void 0)
        return { Progress: obj.Progress };
      if (obj.Cont !== void 0)
        return { Cont: obj.Cont };
      if (obj.End !== void 0)
        return { End: obj.End };
      if (obj.$unknown !== void 0)
        return { [obj.$unknown[0]]: "UNKNOWN" };
    };
    SelectObjectContentOutputFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.Payload && { Payload: "STREAMING_CONTENT" }
    });
    SelectObjectContentRequestFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.SSECustomerKey && { SSECustomerKey: SENSITIVE_STRING2 }
    });
    UploadPartOutputFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.SSEKMSKeyId && { SSEKMSKeyId: SENSITIVE_STRING2 }
    });
    UploadPartRequestFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.SSECustomerKey && { SSECustomerKey: SENSITIVE_STRING2 }
    });
    UploadPartCopyOutputFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.SSEKMSKeyId && { SSEKMSKeyId: SENSITIVE_STRING2 }
    });
    UploadPartCopyRequestFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.SSECustomerKey && { SSECustomerKey: SENSITIVE_STRING2 },
      ...obj.CopySourceSSECustomerKey && { CopySourceSSECustomerKey: SENSITIVE_STRING2 }
    });
    WriteGetObjectResponseRequestFilterSensitiveLog = (obj) => ({
      ...obj,
      ...obj.SSEKMSKeyId && { SSEKMSKeyId: SENSITIVE_STRING2 }
    });
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/protocols/Aws_restXml.js
var se_AbortMultipartUploadCommand, se_CompleteMultipartUploadCommand, se_CopyObjectCommand, se_CreateBucketCommand, se_CreateBucketMetadataConfigurationCommand, se_CreateBucketMetadataTableConfigurationCommand, se_CreateMultipartUploadCommand, se_CreateSessionCommand, se_DeleteBucketCommand, se_DeleteBucketAnalyticsConfigurationCommand, se_DeleteBucketCorsCommand, se_DeleteBucketEncryptionCommand, se_DeleteBucketIntelligentTieringConfigurationCommand, se_DeleteBucketInventoryConfigurationCommand, se_DeleteBucketLifecycleCommand, se_DeleteBucketMetadataConfigurationCommand, se_DeleteBucketMetadataTableConfigurationCommand, se_DeleteBucketMetricsConfigurationCommand, se_DeleteBucketOwnershipControlsCommand, se_DeleteBucketPolicyCommand, se_DeleteBucketReplicationCommand, se_DeleteBucketTaggingCommand, se_DeleteBucketWebsiteCommand, se_DeleteObjectCommand, se_DeleteObjectsCommand, se_DeleteObjectTaggingCommand, se_DeletePublicAccessBlockCommand, se_GetBucketAccelerateConfigurationCommand, se_GetBucketAclCommand, se_GetBucketAnalyticsConfigurationCommand, se_GetBucketCorsCommand, se_GetBucketEncryptionCommand, se_GetBucketIntelligentTieringConfigurationCommand, se_GetBucketInventoryConfigurationCommand, se_GetBucketLifecycleConfigurationCommand, se_GetBucketLocationCommand, se_GetBucketLoggingCommand, se_GetBucketMetadataConfigurationCommand, se_GetBucketMetadataTableConfigurationCommand, se_GetBucketMetricsConfigurationCommand, se_GetBucketNotificationConfigurationCommand, se_GetBucketOwnershipControlsCommand, se_GetBucketPolicyCommand, se_GetBucketPolicyStatusCommand, se_GetBucketReplicationCommand, se_GetBucketRequestPaymentCommand, se_GetBucketTaggingCommand, se_GetBucketVersioningCommand, se_GetBucketWebsiteCommand, se_GetObjectCommand, se_GetObjectAclCommand, se_GetObjectAttributesCommand, se_GetObjectLegalHoldCommand, se_GetObjectLockConfigurationCommand, se_GetObjectRetentionCommand, se_GetObjectTaggingCommand, se_GetObjectTorrentCommand, se_GetPublicAccessBlockCommand, se_HeadBucketCommand, se_HeadObjectCommand, se_ListBucketAnalyticsConfigurationsCommand, se_ListBucketIntelligentTieringConfigurationsCommand, se_ListBucketInventoryConfigurationsCommand, se_ListBucketMetricsConfigurationsCommand, se_ListBucketsCommand, se_ListDirectoryBucketsCommand, se_ListMultipartUploadsCommand, se_ListObjectsCommand, se_ListObjectsV2Command, se_ListObjectVersionsCommand, se_ListPartsCommand, se_PutBucketAccelerateConfigurationCommand, se_PutBucketAclCommand, se_PutBucketAnalyticsConfigurationCommand, se_PutBucketCorsCommand, se_PutBucketEncryptionCommand, se_PutBucketIntelligentTieringConfigurationCommand, se_PutBucketInventoryConfigurationCommand, se_PutBucketLifecycleConfigurationCommand, se_PutBucketLoggingCommand, se_PutBucketMetricsConfigurationCommand, se_PutBucketNotificationConfigurationCommand, se_PutBucketOwnershipControlsCommand, se_PutBucketPolicyCommand, se_PutBucketReplicationCommand, se_PutBucketRequestPaymentCommand, se_PutBucketTaggingCommand, se_PutBucketVersioningCommand, se_PutBucketWebsiteCommand, se_PutObjectCommand, se_PutObjectAclCommand, se_PutObjectLegalHoldCommand, se_PutObjectLockConfigurationCommand, se_PutObjectRetentionCommand, se_PutObjectTaggingCommand, se_PutPublicAccessBlockCommand, se_RenameObjectCommand, se_RestoreObjectCommand, se_SelectObjectContentCommand, se_UpdateBucketMetadataInventoryTableConfigurationCommand, se_UpdateBucketMetadataJournalTableConfigurationCommand, se_UploadPartCommand, se_UploadPartCopyCommand, se_WriteGetObjectResponseCommand, de_AbortMultipartUploadCommand, de_CompleteMultipartUploadCommand, de_CopyObjectCommand, de_CreateBucketCommand, de_CreateBucketMetadataConfigurationCommand, de_CreateBucketMetadataTableConfigurationCommand, de_CreateMultipartUploadCommand, de_CreateSessionCommand, de_DeleteBucketCommand, de_DeleteBucketAnalyticsConfigurationCommand, de_DeleteBucketCorsCommand, de_DeleteBucketEncryptionCommand, de_DeleteBucketIntelligentTieringConfigurationCommand, de_DeleteBucketInventoryConfigurationCommand, de_DeleteBucketLifecycleCommand, de_DeleteBucketMetadataConfigurationCommand, de_DeleteBucketMetadataTableConfigurationCommand, de_DeleteBucketMetricsConfigurationCommand, de_DeleteBucketOwnershipControlsCommand, de_DeleteBucketPolicyCommand, de_DeleteBucketReplicationCommand, de_DeleteBucketTaggingCommand, de_DeleteBucketWebsiteCommand, de_DeleteObjectCommand, de_DeleteObjectsCommand, de_DeleteObjectTaggingCommand, de_DeletePublicAccessBlockCommand, de_GetBucketAccelerateConfigurationCommand, de_GetBucketAclCommand, de_GetBucketAnalyticsConfigurationCommand, de_GetBucketCorsCommand, de_GetBucketEncryptionCommand, de_GetBucketIntelligentTieringConfigurationCommand, de_GetBucketInventoryConfigurationCommand, de_GetBucketLifecycleConfigurationCommand, de_GetBucketLocationCommand, de_GetBucketLoggingCommand, de_GetBucketMetadataConfigurationCommand, de_GetBucketMetadataTableConfigurationCommand, de_GetBucketMetricsConfigurationCommand, de_GetBucketNotificationConfigurationCommand, de_GetBucketOwnershipControlsCommand, de_GetBucketPolicyCommand, de_GetBucketPolicyStatusCommand, de_GetBucketReplicationCommand, de_GetBucketRequestPaymentCommand, de_GetBucketTaggingCommand, de_GetBucketVersioningCommand, de_GetBucketWebsiteCommand, de_GetObjectCommand, de_GetObjectAclCommand, de_GetObjectAttributesCommand, de_GetObjectLegalHoldCommand, de_GetObjectLockConfigurationCommand, de_GetObjectRetentionCommand, de_GetObjectTaggingCommand, de_GetObjectTorrentCommand, de_GetPublicAccessBlockCommand, de_HeadBucketCommand, de_HeadObjectCommand, de_ListBucketAnalyticsConfigurationsCommand, de_ListBucketIntelligentTieringConfigurationsCommand, de_ListBucketInventoryConfigurationsCommand, de_ListBucketMetricsConfigurationsCommand, de_ListBucketsCommand, de_ListDirectoryBucketsCommand, de_ListMultipartUploadsCommand, de_ListObjectsCommand, de_ListObjectsV2Command, de_ListObjectVersionsCommand, de_ListPartsCommand, de_PutBucketAccelerateConfigurationCommand, de_PutBucketAclCommand, de_PutBucketAnalyticsConfigurationCommand, de_PutBucketCorsCommand, de_PutBucketEncryptionCommand, de_PutBucketIntelligentTieringConfigurationCommand, de_PutBucketInventoryConfigurationCommand, de_PutBucketLifecycleConfigurationCommand, de_PutBucketLoggingCommand, de_PutBucketMetricsConfigurationCommand, de_PutBucketNotificationConfigurationCommand, de_PutBucketOwnershipControlsCommand, de_PutBucketPolicyCommand, de_PutBucketReplicationCommand, de_PutBucketRequestPaymentCommand, de_PutBucketTaggingCommand, de_PutBucketVersioningCommand, de_PutBucketWebsiteCommand, de_PutObjectCommand, de_PutObjectAclCommand, de_PutObjectLegalHoldCommand, de_PutObjectLockConfigurationCommand, de_PutObjectRetentionCommand, de_PutObjectTaggingCommand, de_PutPublicAccessBlockCommand, de_RenameObjectCommand, de_RestoreObjectCommand, de_SelectObjectContentCommand, de_UpdateBucketMetadataInventoryTableConfigurationCommand, de_UpdateBucketMetadataJournalTableConfigurationCommand, de_UploadPartCommand, de_UploadPartCopyCommand, de_WriteGetObjectResponseCommand, de_CommandError, throwDefaultError2, de_BucketAlreadyExistsRes, de_BucketAlreadyOwnedByYouRes, de_EncryptionTypeMismatchRes, de_IdempotencyParameterMismatchRes, de_InvalidObjectStateRes, de_InvalidRequestRes, de_InvalidWriteOffsetRes, de_NoSuchBucketRes, de_NoSuchKeyRes, de_NoSuchUploadRes, de_NotFoundRes, de_ObjectAlreadyInActiveTierErrorRes, de_ObjectNotInActiveTierErrorRes, de_TooManyPartsRes, de_SelectObjectContentEventStream, de_ContinuationEvent_event, de_EndEvent_event, de_ProgressEvent_event, de_RecordsEvent_event, de_StatsEvent_event, se_AbortIncompleteMultipartUpload, se_AccelerateConfiguration, se_AccessControlPolicy, se_AccessControlTranslation, se_AllowedHeaders, se_AllowedMethods, se_AllowedOrigins, se_AnalyticsAndOperator, se_AnalyticsConfiguration, se_AnalyticsExportDestination, se_AnalyticsFilter, se_AnalyticsS3BucketDestination, se_BucketInfo, se_BucketLifecycleConfiguration, se_BucketLoggingStatus, se_CompletedMultipartUpload, se_CompletedPart, se_CompletedPartList, se_Condition, se_CORSConfiguration, se_CORSRule, se_CORSRules, se_CreateBucketConfiguration, se_CSVInput, se_CSVOutput, se_DefaultRetention, se_Delete, se_DeleteMarkerReplication, se_Destination, se_Encryption, se_EncryptionConfiguration, se_ErrorDocument, se_EventBridgeConfiguration, se_EventList, se_ExistingObjectReplication, se_ExposeHeaders, se_FilterRule, se_FilterRuleList, se_GlacierJobParameters, se_Grant, se_Grantee, se_Grants, se_IndexDocument, se_InputSerialization, se_IntelligentTieringAndOperator, se_IntelligentTieringConfiguration, se_IntelligentTieringFilter, se_InventoryConfiguration, se_InventoryDestination, se_InventoryEncryption, se_InventoryFilter, se_InventoryOptionalFields, se_InventoryS3BucketDestination, se_InventorySchedule, se_InventoryTableConfiguration, se_InventoryTableConfigurationUpdates, se_JournalTableConfiguration, se_JournalTableConfigurationUpdates, se_JSONInput, se_JSONOutput, se_LambdaFunctionConfiguration, se_LambdaFunctionConfigurationList, se_LifecycleExpiration, se_LifecycleRule, se_LifecycleRuleAndOperator, se_LifecycleRuleFilter, se_LifecycleRules, se_LocationInfo, se_LoggingEnabled, se_MetadataConfiguration, se_MetadataEntry, se_MetadataTableConfiguration, se_MetadataTableEncryptionConfiguration, se_Metrics, se_MetricsAndOperator, se_MetricsConfiguration, se_MetricsFilter, se_NoncurrentVersionExpiration, se_NoncurrentVersionTransition, se_NoncurrentVersionTransitionList, se_NotificationConfiguration, se_NotificationConfigurationFilter, se_ObjectIdentifier, se_ObjectIdentifierList, se_ObjectLockConfiguration, se_ObjectLockLegalHold, se_ObjectLockRetention, se_ObjectLockRule, se_OutputLocation, se_OutputSerialization, se_Owner, se_OwnershipControls, se_OwnershipControlsRule, se_OwnershipControlsRules, se_ParquetInput, se_PartitionedPrefix, se_PublicAccessBlockConfiguration, se_QueueConfiguration, se_QueueConfigurationList, se_RecordExpiration, se_Redirect, se_RedirectAllRequestsTo, se_ReplicaModifications, se_ReplicationConfiguration, se_ReplicationRule, se_ReplicationRuleAndOperator, se_ReplicationRuleFilter, se_ReplicationRules, se_ReplicationTime, se_ReplicationTimeValue, se_RequestPaymentConfiguration, se_RequestProgress, se_RestoreRequest, se_RoutingRule, se_RoutingRules, se_S3KeyFilter, se_S3Location, se_S3TablesDestination, se_ScanRange, se_SelectParameters, se_ServerSideEncryptionByDefault, se_ServerSideEncryptionConfiguration, se_ServerSideEncryptionRule, se_ServerSideEncryptionRules, se_SimplePrefix, se_SourceSelectionCriteria, se_SSEKMS, se_SseKmsEncryptedObjects, se_SSES3, se_StorageClassAnalysis, se_StorageClassAnalysisDataExport, se_Tag, se_Tagging, se_TagSet, se_TargetGrant, se_TargetGrants, se_TargetObjectKeyFormat, se_Tiering, se_TieringList, se_TopicConfiguration, se_TopicConfigurationList, se_Transition, se_TransitionList, se_UserMetadata, se_VersioningConfiguration, se_WebsiteConfiguration, de_AbortIncompleteMultipartUpload, de_AccessControlTranslation, de_AllowedHeaders, de_AllowedMethods, de_AllowedOrigins, de_AnalyticsAndOperator, de_AnalyticsConfiguration, de_AnalyticsConfigurationList, de_AnalyticsExportDestination, de_AnalyticsFilter, de_AnalyticsS3BucketDestination, de_Bucket, de_Buckets, de_Checksum, de_ChecksumAlgorithmList, de_CommonPrefix, de_CommonPrefixList, de_Condition, de_ContinuationEvent, de_CopyObjectResult, de_CopyPartResult, de_CORSRule, de_CORSRules, de_DefaultRetention, de_DeletedObject, de_DeletedObjects, de_DeleteMarkerEntry, de_DeleteMarkerReplication, de_DeleteMarkers, de_Destination, de_DestinationResult, de_EncryptionConfiguration, de_EndEvent, de__Error, de_ErrorDetails, de_ErrorDocument, de_Errors, de_EventBridgeConfiguration, de_EventList, de_ExistingObjectReplication, de_ExposeHeaders, de_FilterRule, de_FilterRuleList, de_GetBucketMetadataConfigurationResult, de_GetBucketMetadataTableConfigurationResult, de_GetObjectAttributesParts, de_Grant, de_Grantee, de_Grants, de_IndexDocument, de_Initiator, de_IntelligentTieringAndOperator, de_IntelligentTieringConfiguration, de_IntelligentTieringConfigurationList, de_IntelligentTieringFilter, de_InventoryConfiguration, de_InventoryConfigurationList, de_InventoryDestination, de_InventoryEncryption, de_InventoryFilter, de_InventoryOptionalFields, de_InventoryS3BucketDestination, de_InventorySchedule, de_InventoryTableConfigurationResult, de_JournalTableConfigurationResult, de_LambdaFunctionConfiguration, de_LambdaFunctionConfigurationList, de_LifecycleExpiration, de_LifecycleRule, de_LifecycleRuleAndOperator, de_LifecycleRuleFilter, de_LifecycleRules, de_LoggingEnabled, de_MetadataConfigurationResult, de_MetadataTableConfigurationResult, de_Metrics, de_MetricsAndOperator, de_MetricsConfiguration, de_MetricsConfigurationList, de_MetricsFilter, de_MultipartUpload, de_MultipartUploadList, de_NoncurrentVersionExpiration, de_NoncurrentVersionTransition, de_NoncurrentVersionTransitionList, de_NotificationConfigurationFilter, de__Object, de_ObjectList, de_ObjectLockConfiguration, de_ObjectLockLegalHold, de_ObjectLockRetention, de_ObjectLockRule, de_ObjectPart, de_ObjectVersion, de_ObjectVersionList, de_Owner, de_OwnershipControls, de_OwnershipControlsRule, de_OwnershipControlsRules, de_Part, de_PartitionedPrefix, de_Parts, de_PartsList, de_PolicyStatus, de_Progress, de_PublicAccessBlockConfiguration, de_QueueConfiguration, de_QueueConfigurationList, de_RecordExpiration, de_Redirect, de_RedirectAllRequestsTo, de_ReplicaModifications, de_ReplicationConfiguration, de_ReplicationRule, de_ReplicationRuleAndOperator, de_ReplicationRuleFilter, de_ReplicationRules, de_ReplicationTime, de_ReplicationTimeValue, de_RestoreStatus, de_RoutingRule, de_RoutingRules, de_S3KeyFilter, de_S3TablesDestinationResult, de_ServerSideEncryptionByDefault, de_ServerSideEncryptionConfiguration, de_ServerSideEncryptionRule, de_ServerSideEncryptionRules, de_SessionCredentials, de_SimplePrefix, de_SourceSelectionCriteria, de_SSEKMS, de_SseKmsEncryptedObjects, de_SSES3, de_Stats, de_StorageClassAnalysis, de_StorageClassAnalysisDataExport, de_Tag, de_TagSet, de_TargetGrant, de_TargetGrants, de_TargetObjectKeyFormat, de_Tiering, de_TieringList, de_TopicConfiguration, de_TopicConfigurationList, de_Transition, de_TransitionList, deserializeMetadata2, collectBodyString2, _A, _AAO, _AC, _ACL, _ACLc, _ACLn, _ACP, _ACT, _ACc, _AD, _AED, _AF, _AH, _AHl, _AI, _AIMU, _AIc, _AKI, _AM, _AMl, _AO, _AOl, _APA, _APAc, _AQRD, _AR, _ARI, _AS, _ASBD, _ASEFF, _ASSEBD, _AT, _Ac, _B, _BA, _BAI, _BAS, _BGR, _BI, _BKE, _BLC, _BLCu, _BLN, _BLP, _BLS, _BLT, _BN, _BP, _BPA, _BPP, _BR, _BRy, _BS, _BT, _BVS, _Bu, _C, _CA, _CACL, _CBC, _CC, _CCRC, _CCRCC, _CCRCNVME, _CD, _CDr, _CE, _CF, _CFC, _CL, _CLo, _CM, _CMD, _CMU, _CORSC, _CORSR, _CORSRu, _CP, _CPo, _CR, _CRSBA, _CS, _CSHA, _CSHAh, _CSIM, _CSIMS, _CSINM, _CSIUS, _CSR, _CSSSECA, _CSSSECK, _CSSSECKMD, _CSV, _CSVI, _CSVIn, _CSVO, _CSo, _CT, _CTl, _CTo, _CTom, _CTon, _Ch, _Co, _Cod, _Com, _Con, _D, _DAI, _DE, _DIM, _DIMS, _DINM, _DIUS, _DM, _DMR, _DMRS, _DMVI, _DMe, _DN, _DR, _DRe, _DRes, _Da, _Dat, _De, _Del, _Des, _Desc, _E, _EA, _EBC, _EBO, _EC, _ECn, _ED, _EH, _EHx, _EM, _EODM, _EOR, _EORS, _ERP, _ES, _ESBO, _ESx, _ESxp, _ET, _ETa, _ETn, _ETv, _ETx, _En, _Ena, _End, _Er, _Err, _Ev, _Eve, _Ex, _Exp, _F, _FD, _FHI, _FO, _FR, _FRN, _FRV, _FRi, _Fi, _Fo, _Fr, _G, _GFC, _GJP, _GR, _GRACP, _GW, _GWACP, _Gr, _Gra, _HECRE, _HN, _HRC, _I, _IC, _ICL, _ICS, _ID, _ID_, _IDn, _IE, _IEn, _IF, _IFn, _IFnv, _II, _IIOV, _IL, _IM, _IMIT, _IMLMT, _IMS, _IMSf, _INM, _IOF, _IOV, _IP, _IPA, _IRIP, _IS, _ISBD, _ISn, _IT, _ITAO, _ITAT, _ITC, _ITCL, _ITCR, _ITCU, _ITCn, _ITD, _ITF, _ITI, _ITS, _IUS, _In, _Ini, _JSON, _JSONI, _JSONO, _JSONT, _JTC, _JTCR, _JTCU, _K, _KC, _KI, _KKA, _KM, _KMSC, _KMSKI, _KMSMKID, _KPE, _L, _LC, _LE, _LEi, _LFA, _LFC, _LFCa, _LI, _LM, _LMT, _LNAS, _LP, _LR, _LRAO, _LRF, _LT, _M, _MAO, _MAS, _MB, _MC, _MCL, _MCR, _MCe, _MD, _MDB, _MDf, _ME, _MF, _MFA, _MFAD, _MI, _MK, _MKe, _MM, _MOS, _MP, _MS, _MTC, _MTCR, _MTEC, _MU, _MV, _Me, _Mes, _Mi, _Mo, _N, _NC, _NCF, _NCT, _ND, _NI, _NKM, _NM, _NNV, _NPNM, _NUIM, _NVE, _NVIM, _NVT, _NVTo, _O, _OA, _OC, _OCACL, _OCR, _OF, _OI, _OK, _OL, _OLC, _OLE, _OLEFB, _OLLH, _OLLHS, _OLM, _OLR, _OLRM, _OLRUD, _OLRb, _OO, _OOA, _OOw, _OP, _OS, _OSGT, _OSGTB, _OSLT, _OSLTB, _OSV, _OSb, _OVI, _Ob, _P, _PABC, _PC, _PDS, _PI, _PN, _PNM, _PP, _Pa, _Par, _Parq, _Part, _Pe, _Pr, _Pri, _Q, _QA, _QC, _QCu, _QCuo, _QEC, _QF, _Qu, _R, _RART, _RC, _RCC, _RCD, _RCE, _RCL, _RCT, _RCe, _RD, _RE, _RED, _REDe, _REe, _RKKID, _RKPW, _RKW, _RM, _RMS, _ROP, _RP, _RPB, _RPC, _RPe, _RR, _RRAO, _RRF, _RRS, _RRT, _RRe, _RRes, _RRo, _RRou, _RS, _RSe, _RSes, _RT, _RTS, _RTV, _RTe, _RUD, _Re, _Red, _Ro, _Ru, _Rul, _S, _SA, _SAK, _SAs, _SBD, _SC, _SCA, _SCADE, _SCASV, _SCt, _SDV, _SIM, _SIMS, _SINM, _SIUS, _SK, _SKEO, _SKEOS, _SKF, _SKe, _SL, _SM, _SOCR, _SP, _SPi, _SR, _SS, _SSC, _SSE, _SSEA, _SSEBD, _SSEC, _SSECA, _SSECK, _SSECKMD, _SSEKMS, _SSEKMSEC, _SSEKMSKI, _SSER, _SSES, _ST, _STBA, _STD, _STDR, _STN, _S_, _Sc, _Se, _Si, _St, _Su, _T, _TA, _TAa, _TB, _TBA, _TBT, _TC, _TCo, _TCop, _TD, _TDMOS, _TG, _TGa, _TN, _TNa, _TOKF, _TP, _TPC, _TS, _TSA, _TSC, _TSa, _Ta, _Tag, _Ti, _Tie, _Tier, _Tim, _To, _Top, _Tr, _Tra, _Ty, _U, _UI, _UIM, _UM, _URI, _Up, _V, _VC, _VCe, _VI, _VIM, _Va, _Ve, _WC, _WOB, _WRL, _Y, _a, _ac, _acl, _ar, _at, _br, _c, _cc, _cd, _ce, _cl, _cl_, _cm, _cr, _ct, _ct_, _d, _de, _e, _en, _et, _eta, _ex, _fo, _i, _im, _ims, _in, _inm, _it, _ius, _km, _l, _lh, _lm, _lo, _log, _lt, _m, _mC, _mIT, _mJT, _mT, _ma, _mb, _mdb, _me, _mk, _mp, _mu, _n, _oC, _ol, _p, _pAB, _pN, _pS, _pnm, _pr, _r, _rO, _rP, _ra, _rcc, _rcd, _rce, _rcl, _rct, _re, _res, _ret, _s, _sa, _se, _st, _t, _to, _u, _uI, _uim, _v, _vI, _ve, _ver, _vim, _w, _x, _xaa, _xaad, _xaapa, _xaari, _xaas, _xaba, _xabgr, _xabln, _xablt, _xabole, _xabolt, _xabr, _xaca, _xacc, _xacc_, _xacc__, _xacm, _xacrsba, _xacs, _xacs_, _xacs__, _xacsim, _xacsims, _xacsinm, _xacsius, _xacsm, _xacsr, _xacssseca, _xacssseck, _xacssseckm, _xacsvi, _xact, _xact_, _xadm, _xae, _xaebo, _xafec, _xafem, _xafhar, _xafhcc, _xafhcd, _xafhce, _xafhcl, _xafhcr, _xafhct, _xafhe, _xafhe_, _xafhlm, _xafhxacc, _xafhxacc_, _xafhxacc__, _xafhxacs, _xafhxacs_, _xafhxadm, _xafhxae, _xafhxamm, _xafhxampc, _xafhxaollh, _xafhxaolm, _xafhxaolrud, _xafhxar, _xafhxarc, _xafhxars, _xafhxasc, _xafhxasse, _xafhxasseakki, _xafhxassebke, _xafhxasseca, _xafhxasseckm, _xafhxatc, _xafhxavi, _xafs, _xagfc, _xagr, _xagra, _xagw, _xagwa, _xaimit, _xaimlmt, _xaims, _xam, _xamd, _xamm, _xamos, _xamp, _xampc, _xaoa, _xaollh, _xaolm, _xaolrud, _xaoo, _xaooa, _xaos, _xapnm, _xar, _xarc, _xarop, _xarp, _xarr, _xars, _xars_, _xarsim, _xarsims, _xarsinm, _xarsius, _xart, _xasc, _xasca, _xasdv, _xasebo, _xasse, _xasseakki, _xassebke, _xassec, _xasseca, _xasseck, _xasseckm, _xat, _xatc, _xatd, _xatdmos, _xavi, _xawob, _xawrl, _xi;
var init_Aws_restXml = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/protocols/Aws_restXml.js"() {
    "use strict";
    init_dist_es22();
    init_dist_es21();
    init_dist_es14();
    init_dist_es2();
    init_dist_es20();
    init_dist_es13();
    init_models_0();
    init_models_1();
    init_S3ServiceException();
    se_AbortMultipartUploadCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xarp]: input[_RP],
        [_xaebo]: input[_EBO],
        [_xaimit]: [() => isSerializableHeaderValue(input[_IMIT]), () => dateToUtcString(input[_IMIT]).toString()]
      });
      b2.bp("/{Key+}");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      b2.p("Key", () => input.Key, "{Key+}", true);
      const query = map({
        [_xi]: [, "AbortMultipartUpload"],
        [_uI]: [, expectNonNull(input[_UI], `UploadId`)]
      });
      let body;
      b2.m("DELETE").h(headers).q(query).b(body);
      return b2.build();
    };
    se_CompleteMultipartUploadCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_xacc]: input[_CCRC],
        [_xacc_]: input[_CCRCC],
        [_xacc__]: input[_CCRCNVME],
        [_xacs]: input[_CSHA],
        [_xacs_]: input[_CSHAh],
        [_xact]: input[_CT],
        [_xamos]: [() => isSerializableHeaderValue(input[_MOS]), () => input[_MOS].toString()],
        [_xarp]: input[_RP],
        [_xaebo]: input[_EBO],
        [_im]: input[_IM],
        [_inm]: input[_INM],
        [_xasseca]: input[_SSECA],
        [_xasseck]: input[_SSECK],
        [_xasseckm]: input[_SSECKMD]
      });
      b2.bp("/{Key+}");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      b2.p("Key", () => input.Key, "{Key+}", true);
      const query = map({
        [_uI]: [, expectNonNull(input[_UI], `UploadId`)]
      });
      let body;
      let contents;
      if (input.MultipartUpload !== void 0) {
        contents = se_CompletedMultipartUpload(input.MultipartUpload, context);
        contents = contents.n("CompleteMultipartUpload");
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("POST").h(headers).q(query).b(body);
      return b2.build();
    };
    se_CopyObjectCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        ...input.Metadata !== void 0 && Object.keys(input.Metadata).reduce((acc, suffix) => {
          acc[`x-amz-meta-${suffix.toLowerCase()}`] = input.Metadata[suffix];
          return acc;
        }, {}),
        [_xaa]: input[_ACL],
        [_cc]: input[_CC],
        [_xaca]: input[_CA],
        [_cd]: input[_CD],
        [_ce]: input[_CE],
        [_cl]: input[_CL],
        [_ct]: input[_CTo],
        [_xacs__]: input[_CS],
        [_xacsim]: input[_CSIM],
        [_xacsims]: [() => isSerializableHeaderValue(input[_CSIMS]), () => dateToUtcString(input[_CSIMS]).toString()],
        [_xacsinm]: input[_CSINM],
        [_xacsius]: [() => isSerializableHeaderValue(input[_CSIUS]), () => dateToUtcString(input[_CSIUS]).toString()],
        [_e]: [() => isSerializableHeaderValue(input[_E]), () => dateToUtcString(input[_E]).toString()],
        [_xagfc]: input[_GFC],
        [_xagr]: input[_GR],
        [_xagra]: input[_GRACP],
        [_xagwa]: input[_GWACP],
        [_im]: input[_IM],
        [_inm]: input[_INM],
        [_xamd]: input[_MD],
        [_xatd]: input[_TD],
        [_xasse]: input[_SSE],
        [_xasc]: input[_SC],
        [_xawrl]: input[_WRL],
        [_xasseca]: input[_SSECA],
        [_xasseck]: input[_SSECK],
        [_xasseckm]: input[_SSECKMD],
        [_xasseakki]: input[_SSEKMSKI],
        [_xassec]: input[_SSEKMSEC],
        [_xassebke]: [() => isSerializableHeaderValue(input[_BKE]), () => input[_BKE].toString()],
        [_xacssseca]: input[_CSSSECA],
        [_xacssseck]: input[_CSSSECK],
        [_xacssseckm]: input[_CSSSECKMD],
        [_xarp]: input[_RP],
        [_xat]: input[_T],
        [_xaolm]: input[_OLM],
        [_xaolrud]: [() => isSerializableHeaderValue(input[_OLRUD]), () => serializeDateTime(input[_OLRUD]).toString()],
        [_xaollh]: input[_OLLHS],
        [_xaebo]: input[_EBO],
        [_xasebo]: input[_ESBO]
      });
      b2.bp("/{Key+}");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      b2.p("Key", () => input.Key, "{Key+}", true);
      const query = map({
        [_xi]: [, "CopyObject"]
      });
      let body;
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_CreateBucketCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_xaa]: input[_ACL],
        [_xagfc]: input[_GFC],
        [_xagr]: input[_GR],
        [_xagra]: input[_GRACP],
        [_xagw]: input[_GW],
        [_xagwa]: input[_GWACP],
        [_xabole]: [() => isSerializableHeaderValue(input[_OLEFB]), () => input[_OLEFB].toString()],
        [_xaoo]: input[_OO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      let body;
      let contents;
      if (input.CreateBucketConfiguration !== void 0) {
        contents = se_CreateBucketConfiguration(input.CreateBucketConfiguration, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("PUT").h(headers).b(body);
      return b2.build();
    };
    se_CreateBucketMetadataConfigurationCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_mC]: [, ""]
      });
      let body;
      let contents;
      if (input.MetadataConfiguration !== void 0) {
        contents = se_MetadataConfiguration(input.MetadataConfiguration, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("POST").h(headers).q(query).b(body);
      return b2.build();
    };
    se_CreateBucketMetadataTableConfigurationCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_mT]: [, ""]
      });
      let body;
      let contents;
      if (input.MetadataTableConfiguration !== void 0) {
        contents = se_MetadataTableConfiguration(input.MetadataTableConfiguration, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("POST").h(headers).q(query).b(body);
      return b2.build();
    };
    se_CreateMultipartUploadCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        ...input.Metadata !== void 0 && Object.keys(input.Metadata).reduce((acc, suffix) => {
          acc[`x-amz-meta-${suffix.toLowerCase()}`] = input.Metadata[suffix];
          return acc;
        }, {}),
        [_xaa]: input[_ACL],
        [_cc]: input[_CC],
        [_cd]: input[_CD],
        [_ce]: input[_CE],
        [_cl]: input[_CL],
        [_ct]: input[_CTo],
        [_e]: [() => isSerializableHeaderValue(input[_E]), () => dateToUtcString(input[_E]).toString()],
        [_xagfc]: input[_GFC],
        [_xagr]: input[_GR],
        [_xagra]: input[_GRACP],
        [_xagwa]: input[_GWACP],
        [_xasse]: input[_SSE],
        [_xasc]: input[_SC],
        [_xawrl]: input[_WRL],
        [_xasseca]: input[_SSECA],
        [_xasseck]: input[_SSECK],
        [_xasseckm]: input[_SSECKMD],
        [_xasseakki]: input[_SSEKMSKI],
        [_xassec]: input[_SSEKMSEC],
        [_xassebke]: [() => isSerializableHeaderValue(input[_BKE]), () => input[_BKE].toString()],
        [_xarp]: input[_RP],
        [_xat]: input[_T],
        [_xaolm]: input[_OLM],
        [_xaolrud]: [() => isSerializableHeaderValue(input[_OLRUD]), () => serializeDateTime(input[_OLRUD]).toString()],
        [_xaollh]: input[_OLLHS],
        [_xaebo]: input[_EBO],
        [_xaca]: input[_CA],
        [_xact]: input[_CT]
      });
      b2.bp("/{Key+}");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      b2.p("Key", () => input.Key, "{Key+}", true);
      const query = map({
        [_u]: [, ""]
      });
      let body;
      b2.m("POST").h(headers).q(query).b(body);
      return b2.build();
    };
    se_CreateSessionCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xacsm]: input[_SM],
        [_xasse]: input[_SSE],
        [_xasseakki]: input[_SSEKMSKI],
        [_xassec]: input[_SSEKMSEC],
        [_xassebke]: [() => isSerializableHeaderValue(input[_BKE]), () => input[_BKE].toString()]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_s]: [, ""]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_DeleteBucketCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      let body;
      b2.m("DELETE").h(headers).b(body);
      return b2.build();
    };
    se_DeleteBucketAnalyticsConfigurationCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_a]: [, ""],
        [_i]: [, expectNonNull(input[_I], `Id`)]
      });
      let body;
      b2.m("DELETE").h(headers).q(query).b(body);
      return b2.build();
    };
    se_DeleteBucketCorsCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_c]: [, ""]
      });
      let body;
      b2.m("DELETE").h(headers).q(query).b(body);
      return b2.build();
    };
    se_DeleteBucketEncryptionCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_en]: [, ""]
      });
      let body;
      b2.m("DELETE").h(headers).q(query).b(body);
      return b2.build();
    };
    se_DeleteBucketIntelligentTieringConfigurationCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_it]: [, ""],
        [_i]: [, expectNonNull(input[_I], `Id`)]
      });
      let body;
      b2.m("DELETE").h(headers).q(query).b(body);
      return b2.build();
    };
    se_DeleteBucketInventoryConfigurationCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_in]: [, ""],
        [_i]: [, expectNonNull(input[_I], `Id`)]
      });
      let body;
      b2.m("DELETE").h(headers).q(query).b(body);
      return b2.build();
    };
    se_DeleteBucketLifecycleCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_l]: [, ""]
      });
      let body;
      b2.m("DELETE").h(headers).q(query).b(body);
      return b2.build();
    };
    se_DeleteBucketMetadataConfigurationCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_mC]: [, ""]
      });
      let body;
      b2.m("DELETE").h(headers).q(query).b(body);
      return b2.build();
    };
    se_DeleteBucketMetadataTableConfigurationCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_mT]: [, ""]
      });
      let body;
      b2.m("DELETE").h(headers).q(query).b(body);
      return b2.build();
    };
    se_DeleteBucketMetricsConfigurationCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_m]: [, ""],
        [_i]: [, expectNonNull(input[_I], `Id`)]
      });
      let body;
      b2.m("DELETE").h(headers).q(query).b(body);
      return b2.build();
    };
    se_DeleteBucketOwnershipControlsCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_oC]: [, ""]
      });
      let body;
      b2.m("DELETE").h(headers).q(query).b(body);
      return b2.build();
    };
    se_DeleteBucketPolicyCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_p]: [, ""]
      });
      let body;
      b2.m("DELETE").h(headers).q(query).b(body);
      return b2.build();
    };
    se_DeleteBucketReplicationCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_r]: [, ""]
      });
      let body;
      b2.m("DELETE").h(headers).q(query).b(body);
      return b2.build();
    };
    se_DeleteBucketTaggingCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_t]: [, ""]
      });
      let body;
      b2.m("DELETE").h(headers).q(query).b(body);
      return b2.build();
    };
    se_DeleteBucketWebsiteCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_w]: [, ""]
      });
      let body;
      b2.m("DELETE").h(headers).q(query).b(body);
      return b2.build();
    };
    se_DeleteObjectCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xam]: input[_MFA],
        [_xarp]: input[_RP],
        [_xabgr]: [() => isSerializableHeaderValue(input[_BGR]), () => input[_BGR].toString()],
        [_xaebo]: input[_EBO],
        [_im]: input[_IM],
        [_xaimlmt]: [() => isSerializableHeaderValue(input[_IMLMT]), () => dateToUtcString(input[_IMLMT]).toString()],
        [_xaims]: [() => isSerializableHeaderValue(input[_IMS]), () => input[_IMS].toString()]
      });
      b2.bp("/{Key+}");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      b2.p("Key", () => input.Key, "{Key+}", true);
      const query = map({
        [_xi]: [, "DeleteObject"],
        [_vI]: [, input[_VI]]
      });
      let body;
      b2.m("DELETE").h(headers).q(query).b(body);
      return b2.build();
    };
    se_DeleteObjectsCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_xam]: input[_MFA],
        [_xarp]: input[_RP],
        [_xabgr]: [() => isSerializableHeaderValue(input[_BGR]), () => input[_BGR].toString()],
        [_xaebo]: input[_EBO],
        [_xasca]: input[_CA]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_d]: [, ""]
      });
      let body;
      let contents;
      if (input.Delete !== void 0) {
        contents = se_Delete(input.Delete, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("POST").h(headers).q(query).b(body);
      return b2.build();
    };
    se_DeleteObjectTaggingCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/{Key+}");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      b2.p("Key", () => input.Key, "{Key+}", true);
      const query = map({
        [_t]: [, ""],
        [_vI]: [, input[_VI]]
      });
      let body;
      b2.m("DELETE").h(headers).q(query).b(body);
      return b2.build();
    };
    se_DeletePublicAccessBlockCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_pAB]: [, ""]
      });
      let body;
      b2.m("DELETE").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetBucketAccelerateConfigurationCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO],
        [_xarp]: input[_RP]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_ac]: [, ""]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetBucketAclCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_acl]: [, ""]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetBucketAnalyticsConfigurationCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_a]: [, ""],
        [_xi]: [, "GetBucketAnalyticsConfiguration"],
        [_i]: [, expectNonNull(input[_I], `Id`)]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetBucketCorsCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_c]: [, ""]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetBucketEncryptionCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_en]: [, ""]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetBucketIntelligentTieringConfigurationCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_it]: [, ""],
        [_xi]: [, "GetBucketIntelligentTieringConfiguration"],
        [_i]: [, expectNonNull(input[_I], `Id`)]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetBucketInventoryConfigurationCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_in]: [, ""],
        [_xi]: [, "GetBucketInventoryConfiguration"],
        [_i]: [, expectNonNull(input[_I], `Id`)]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetBucketLifecycleConfigurationCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_l]: [, ""]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetBucketLocationCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_lo]: [, ""]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetBucketLoggingCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_log]: [, ""]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetBucketMetadataConfigurationCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_mC]: [, ""]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetBucketMetadataTableConfigurationCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_mT]: [, ""]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetBucketMetricsConfigurationCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_m]: [, ""],
        [_xi]: [, "GetBucketMetricsConfiguration"],
        [_i]: [, expectNonNull(input[_I], `Id`)]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetBucketNotificationConfigurationCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_n]: [, ""]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetBucketOwnershipControlsCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_oC]: [, ""]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetBucketPolicyCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_p]: [, ""]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetBucketPolicyStatusCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_pS]: [, ""]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetBucketReplicationCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_r]: [, ""]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetBucketRequestPaymentCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_rP]: [, ""]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetBucketTaggingCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_t]: [, ""]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetBucketVersioningCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_v]: [, ""]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetBucketWebsiteCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_w]: [, ""]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetObjectCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_im]: input[_IM],
        [_ims]: [() => isSerializableHeaderValue(input[_IMSf]), () => dateToUtcString(input[_IMSf]).toString()],
        [_inm]: input[_INM],
        [_ius]: [() => isSerializableHeaderValue(input[_IUS]), () => dateToUtcString(input[_IUS]).toString()],
        [_ra]: input[_R],
        [_xasseca]: input[_SSECA],
        [_xasseck]: input[_SSECK],
        [_xasseckm]: input[_SSECKMD],
        [_xarp]: input[_RP],
        [_xaebo]: input[_EBO],
        [_xacm]: input[_CM]
      });
      b2.bp("/{Key+}");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      b2.p("Key", () => input.Key, "{Key+}", true);
      const query = map({
        [_xi]: [, "GetObject"],
        [_rcc]: [, input[_RCC]],
        [_rcd]: [, input[_RCD]],
        [_rce]: [, input[_RCE]],
        [_rcl]: [, input[_RCL]],
        [_rct]: [, input[_RCT]],
        [_re]: [() => input.ResponseExpires !== void 0, () => dateToUtcString(input[_RE]).toString()],
        [_vI]: [, input[_VI]],
        [_pN]: [() => input.PartNumber !== void 0, () => input[_PN].toString()]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetObjectAclCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xarp]: input[_RP],
        [_xaebo]: input[_EBO]
      });
      b2.bp("/{Key+}");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      b2.p("Key", () => input.Key, "{Key+}", true);
      const query = map({
        [_acl]: [, ""],
        [_vI]: [, input[_VI]]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetObjectAttributesCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xamp]: [() => isSerializableHeaderValue(input[_MP]), () => input[_MP].toString()],
        [_xapnm]: input[_PNM],
        [_xasseca]: input[_SSECA],
        [_xasseck]: input[_SSECK],
        [_xasseckm]: input[_SSECKMD],
        [_xarp]: input[_RP],
        [_xaebo]: input[_EBO],
        [_xaoa]: [() => isSerializableHeaderValue(input[_OA]), () => (input[_OA] || []).map(quoteHeader).join(", ")]
      });
      b2.bp("/{Key+}");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      b2.p("Key", () => input.Key, "{Key+}", true);
      const query = map({
        [_at]: [, ""],
        [_vI]: [, input[_VI]]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetObjectLegalHoldCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xarp]: input[_RP],
        [_xaebo]: input[_EBO]
      });
      b2.bp("/{Key+}");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      b2.p("Key", () => input.Key, "{Key+}", true);
      const query = map({
        [_lh]: [, ""],
        [_vI]: [, input[_VI]]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetObjectLockConfigurationCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_ol]: [, ""]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetObjectRetentionCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xarp]: input[_RP],
        [_xaebo]: input[_EBO]
      });
      b2.bp("/{Key+}");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      b2.p("Key", () => input.Key, "{Key+}", true);
      const query = map({
        [_ret]: [, ""],
        [_vI]: [, input[_VI]]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetObjectTaggingCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO],
        [_xarp]: input[_RP]
      });
      b2.bp("/{Key+}");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      b2.p("Key", () => input.Key, "{Key+}", true);
      const query = map({
        [_t]: [, ""],
        [_vI]: [, input[_VI]]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetObjectTorrentCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xarp]: input[_RP],
        [_xaebo]: input[_EBO]
      });
      b2.bp("/{Key+}");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      b2.p("Key", () => input.Key, "{Key+}", true);
      const query = map({
        [_to]: [, ""]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_GetPublicAccessBlockCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_pAB]: [, ""]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_HeadBucketCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      let body;
      b2.m("HEAD").h(headers).b(body);
      return b2.build();
    };
    se_HeadObjectCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_im]: input[_IM],
        [_ims]: [() => isSerializableHeaderValue(input[_IMSf]), () => dateToUtcString(input[_IMSf]).toString()],
        [_inm]: input[_INM],
        [_ius]: [() => isSerializableHeaderValue(input[_IUS]), () => dateToUtcString(input[_IUS]).toString()],
        [_ra]: input[_R],
        [_xasseca]: input[_SSECA],
        [_xasseck]: input[_SSECK],
        [_xasseckm]: input[_SSECKMD],
        [_xarp]: input[_RP],
        [_xaebo]: input[_EBO],
        [_xacm]: input[_CM]
      });
      b2.bp("/{Key+}");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      b2.p("Key", () => input.Key, "{Key+}", true);
      const query = map({
        [_rcc]: [, input[_RCC]],
        [_rcd]: [, input[_RCD]],
        [_rce]: [, input[_RCE]],
        [_rcl]: [, input[_RCL]],
        [_rct]: [, input[_RCT]],
        [_re]: [() => input.ResponseExpires !== void 0, () => dateToUtcString(input[_RE]).toString()],
        [_vI]: [, input[_VI]],
        [_pN]: [() => input.PartNumber !== void 0, () => input[_PN].toString()]
      });
      let body;
      b2.m("HEAD").h(headers).q(query).b(body);
      return b2.build();
    };
    se_ListBucketAnalyticsConfigurationsCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_a]: [, ""],
        [_xi]: [, "ListBucketAnalyticsConfigurations"],
        [_ct_]: [, input[_CTon]]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_ListBucketIntelligentTieringConfigurationsCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_it]: [, ""],
        [_xi]: [, "ListBucketIntelligentTieringConfigurations"],
        [_ct_]: [, input[_CTon]]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_ListBucketInventoryConfigurationsCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_in]: [, ""],
        [_xi]: [, "ListBucketInventoryConfigurations"],
        [_ct_]: [, input[_CTon]]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_ListBucketMetricsConfigurationsCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_m]: [, ""],
        [_xi]: [, "ListBucketMetricsConfigurations"],
        [_ct_]: [, input[_CTon]]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_ListBucketsCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = {};
      b2.bp("/");
      const query = map({
        [_xi]: [, "ListBuckets"],
        [_mb]: [() => input.MaxBuckets !== void 0, () => input[_MB].toString()],
        [_ct_]: [, input[_CTon]],
        [_pr]: [, input[_P]],
        [_br]: [, input[_BR]]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_ListDirectoryBucketsCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = {};
      b2.bp("/");
      const query = map({
        [_xi]: [, "ListDirectoryBuckets"],
        [_ct_]: [, input[_CTon]],
        [_mdb]: [() => input.MaxDirectoryBuckets !== void 0, () => input[_MDB].toString()]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_ListMultipartUploadsCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO],
        [_xarp]: input[_RP]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_u]: [, ""],
        [_de]: [, input[_D]],
        [_et]: [, input[_ET]],
        [_km]: [, input[_KM]],
        [_mu]: [() => input.MaxUploads !== void 0, () => input[_MU].toString()],
        [_pr]: [, input[_P]],
        [_uim]: [, input[_UIM]]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_ListObjectsCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xarp]: input[_RP],
        [_xaebo]: input[_EBO],
        [_xaooa]: [() => isSerializableHeaderValue(input[_OOA]), () => (input[_OOA] || []).map(quoteHeader).join(", ")]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_de]: [, input[_D]],
        [_et]: [, input[_ET]],
        [_ma]: [, input[_M]],
        [_mk]: [() => input.MaxKeys !== void 0, () => input[_MK].toString()],
        [_pr]: [, input[_P]]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_ListObjectsV2Command = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xarp]: input[_RP],
        [_xaebo]: input[_EBO],
        [_xaooa]: [() => isSerializableHeaderValue(input[_OOA]), () => (input[_OOA] || []).map(quoteHeader).join(", ")]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_lt]: [, "2"],
        [_de]: [, input[_D]],
        [_et]: [, input[_ET]],
        [_mk]: [() => input.MaxKeys !== void 0, () => input[_MK].toString()],
        [_pr]: [, input[_P]],
        [_ct_]: [, input[_CTon]],
        [_fo]: [() => input.FetchOwner !== void 0, () => input[_FO].toString()],
        [_sa]: [, input[_SA]]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_ListObjectVersionsCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO],
        [_xarp]: input[_RP],
        [_xaooa]: [() => isSerializableHeaderValue(input[_OOA]), () => (input[_OOA] || []).map(quoteHeader).join(", ")]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_ver]: [, ""],
        [_de]: [, input[_D]],
        [_et]: [, input[_ET]],
        [_km]: [, input[_KM]],
        [_mk]: [() => input.MaxKeys !== void 0, () => input[_MK].toString()],
        [_pr]: [, input[_P]],
        [_vim]: [, input[_VIM]]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_ListPartsCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xarp]: input[_RP],
        [_xaebo]: input[_EBO],
        [_xasseca]: input[_SSECA],
        [_xasseck]: input[_SSECK],
        [_xasseckm]: input[_SSECKMD]
      });
      b2.bp("/{Key+}");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      b2.p("Key", () => input.Key, "{Key+}", true);
      const query = map({
        [_xi]: [, "ListParts"],
        [_mp]: [() => input.MaxParts !== void 0, () => input[_MP].toString()],
        [_pnm]: [, input[_PNM]],
        [_uI]: [, expectNonNull(input[_UI], `UploadId`)]
      });
      let body;
      b2.m("GET").h(headers).q(query).b(body);
      return b2.build();
    };
    se_PutBucketAccelerateConfigurationCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_xaebo]: input[_EBO],
        [_xasca]: input[_CA]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_ac]: [, ""]
      });
      let body;
      let contents;
      if (input.AccelerateConfiguration !== void 0) {
        contents = se_AccelerateConfiguration(input.AccelerateConfiguration, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_PutBucketAclCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_xaa]: input[_ACL],
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xagfc]: input[_GFC],
        [_xagr]: input[_GR],
        [_xagra]: input[_GRACP],
        [_xagw]: input[_GW],
        [_xagwa]: input[_GWACP],
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_acl]: [, ""]
      });
      let body;
      let contents;
      if (input.AccessControlPolicy !== void 0) {
        contents = se_AccessControlPolicy(input.AccessControlPolicy, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_PutBucketAnalyticsConfigurationCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_a]: [, ""],
        [_i]: [, expectNonNull(input[_I], `Id`)]
      });
      let body;
      let contents;
      if (input.AnalyticsConfiguration !== void 0) {
        contents = se_AnalyticsConfiguration(input.AnalyticsConfiguration, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_PutBucketCorsCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_c]: [, ""]
      });
      let body;
      let contents;
      if (input.CORSConfiguration !== void 0) {
        contents = se_CORSConfiguration(input.CORSConfiguration, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_PutBucketEncryptionCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_en]: [, ""]
      });
      let body;
      let contents;
      if (input.ServerSideEncryptionConfiguration !== void 0) {
        contents = se_ServerSideEncryptionConfiguration(input.ServerSideEncryptionConfiguration, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_PutBucketIntelligentTieringConfigurationCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_it]: [, ""],
        [_i]: [, expectNonNull(input[_I], `Id`)]
      });
      let body;
      let contents;
      if (input.IntelligentTieringConfiguration !== void 0) {
        contents = se_IntelligentTieringConfiguration(input.IntelligentTieringConfiguration, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_PutBucketInventoryConfigurationCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_in]: [, ""],
        [_i]: [, expectNonNull(input[_I], `Id`)]
      });
      let body;
      let contents;
      if (input.InventoryConfiguration !== void 0) {
        contents = se_InventoryConfiguration(input.InventoryConfiguration, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_PutBucketLifecycleConfigurationCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_xasca]: input[_CA],
        [_xaebo]: input[_EBO],
        [_xatdmos]: input[_TDMOS]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_l]: [, ""]
      });
      let body;
      let contents;
      if (input.LifecycleConfiguration !== void 0) {
        contents = se_BucketLifecycleConfiguration(input.LifecycleConfiguration, context);
        contents = contents.n("LifecycleConfiguration");
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_PutBucketLoggingCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_log]: [, ""]
      });
      let body;
      let contents;
      if (input.BucketLoggingStatus !== void 0) {
        contents = se_BucketLoggingStatus(input.BucketLoggingStatus, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_PutBucketMetricsConfigurationCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_m]: [, ""],
        [_i]: [, expectNonNull(input[_I], `Id`)]
      });
      let body;
      let contents;
      if (input.MetricsConfiguration !== void 0) {
        contents = se_MetricsConfiguration(input.MetricsConfiguration, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_PutBucketNotificationConfigurationCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_xaebo]: input[_EBO],
        [_xasdv]: [() => isSerializableHeaderValue(input[_SDV]), () => input[_SDV].toString()]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_n]: [, ""]
      });
      let body;
      let contents;
      if (input.NotificationConfiguration !== void 0) {
        contents = se_NotificationConfiguration(input.NotificationConfiguration, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_PutBucketOwnershipControlsCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_cm]: input[_CMD],
        [_xaebo]: input[_EBO],
        [_xasca]: input[_CA]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_oC]: [, ""]
      });
      let body;
      let contents;
      if (input.OwnershipControls !== void 0) {
        contents = se_OwnershipControls(input.OwnershipControls, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_PutBucketPolicyCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "text/plain",
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xacrsba]: [() => isSerializableHeaderValue(input[_CRSBA]), () => input[_CRSBA].toString()],
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_p]: [, ""]
      });
      let body;
      let contents;
      if (input.Policy !== void 0) {
        contents = input.Policy;
        body = contents;
      }
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_PutBucketReplicationCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xabolt]: input[_To],
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_r]: [, ""]
      });
      let body;
      let contents;
      if (input.ReplicationConfiguration !== void 0) {
        contents = se_ReplicationConfiguration(input.ReplicationConfiguration, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_PutBucketRequestPaymentCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_rP]: [, ""]
      });
      let body;
      let contents;
      if (input.RequestPaymentConfiguration !== void 0) {
        contents = se_RequestPaymentConfiguration(input.RequestPaymentConfiguration, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_PutBucketTaggingCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_t]: [, ""]
      });
      let body;
      let contents;
      if (input.Tagging !== void 0) {
        contents = se_Tagging(input.Tagging, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_PutBucketVersioningCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xam]: input[_MFA],
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_v]: [, ""]
      });
      let body;
      let contents;
      if (input.VersioningConfiguration !== void 0) {
        contents = se_VersioningConfiguration(input.VersioningConfiguration, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_PutBucketWebsiteCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_w]: [, ""]
      });
      let body;
      let contents;
      if (input.WebsiteConfiguration !== void 0) {
        contents = se_WebsiteConfiguration(input.WebsiteConfiguration, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_PutObjectCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        ...input.Metadata !== void 0 && Object.keys(input.Metadata).reduce((acc, suffix) => {
          acc[`x-amz-meta-${suffix.toLowerCase()}`] = input.Metadata[suffix];
          return acc;
        }, {}),
        [_ct]: input[_CTo] || "application/octet-stream",
        [_xaa]: input[_ACL],
        [_cc]: input[_CC],
        [_cd]: input[_CD],
        [_ce]: input[_CE],
        [_cl]: input[_CL],
        [_cl_]: [() => isSerializableHeaderValue(input[_CLo]), () => input[_CLo].toString()],
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xacc]: input[_CCRC],
        [_xacc_]: input[_CCRCC],
        [_xacc__]: input[_CCRCNVME],
        [_xacs]: input[_CSHA],
        [_xacs_]: input[_CSHAh],
        [_e]: [() => isSerializableHeaderValue(input[_E]), () => dateToUtcString(input[_E]).toString()],
        [_im]: input[_IM],
        [_inm]: input[_INM],
        [_xagfc]: input[_GFC],
        [_xagr]: input[_GR],
        [_xagra]: input[_GRACP],
        [_xagwa]: input[_GWACP],
        [_xawob]: [() => isSerializableHeaderValue(input[_WOB]), () => input[_WOB].toString()],
        [_xasse]: input[_SSE],
        [_xasc]: input[_SC],
        [_xawrl]: input[_WRL],
        [_xasseca]: input[_SSECA],
        [_xasseck]: input[_SSECK],
        [_xasseckm]: input[_SSECKMD],
        [_xasseakki]: input[_SSEKMSKI],
        [_xassec]: input[_SSEKMSEC],
        [_xassebke]: [() => isSerializableHeaderValue(input[_BKE]), () => input[_BKE].toString()],
        [_xarp]: input[_RP],
        [_xat]: input[_T],
        [_xaolm]: input[_OLM],
        [_xaolrud]: [() => isSerializableHeaderValue(input[_OLRUD]), () => serializeDateTime(input[_OLRUD]).toString()],
        [_xaollh]: input[_OLLHS],
        [_xaebo]: input[_EBO]
      });
      b2.bp("/{Key+}");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      b2.p("Key", () => input.Key, "{Key+}", true);
      const query = map({
        [_xi]: [, "PutObject"]
      });
      let body;
      let contents;
      if (input.Body !== void 0) {
        contents = input.Body;
        body = contents;
      }
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_PutObjectAclCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_xaa]: input[_ACL],
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xagfc]: input[_GFC],
        [_xagr]: input[_GR],
        [_xagra]: input[_GRACP],
        [_xagw]: input[_GW],
        [_xagwa]: input[_GWACP],
        [_xarp]: input[_RP],
        [_xaebo]: input[_EBO]
      });
      b2.bp("/{Key+}");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      b2.p("Key", () => input.Key, "{Key+}", true);
      const query = map({
        [_acl]: [, ""],
        [_vI]: [, input[_VI]]
      });
      let body;
      let contents;
      if (input.AccessControlPolicy !== void 0) {
        contents = se_AccessControlPolicy(input.AccessControlPolicy, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_PutObjectLegalHoldCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_xarp]: input[_RP],
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xaebo]: input[_EBO]
      });
      b2.bp("/{Key+}");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      b2.p("Key", () => input.Key, "{Key+}", true);
      const query = map({
        [_lh]: [, ""],
        [_vI]: [, input[_VI]]
      });
      let body;
      let contents;
      if (input.LegalHold !== void 0) {
        contents = se_ObjectLockLegalHold(input.LegalHold, context);
        contents = contents.n("LegalHold");
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_PutObjectLockConfigurationCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_xarp]: input[_RP],
        [_xabolt]: input[_To],
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_ol]: [, ""]
      });
      let body;
      let contents;
      if (input.ObjectLockConfiguration !== void 0) {
        contents = se_ObjectLockConfiguration(input.ObjectLockConfiguration, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_PutObjectRetentionCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_xarp]: input[_RP],
        [_xabgr]: [() => isSerializableHeaderValue(input[_BGR]), () => input[_BGR].toString()],
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xaebo]: input[_EBO]
      });
      b2.bp("/{Key+}");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      b2.p("Key", () => input.Key, "{Key+}", true);
      const query = map({
        [_ret]: [, ""],
        [_vI]: [, input[_VI]]
      });
      let body;
      let contents;
      if (input.Retention !== void 0) {
        contents = se_ObjectLockRetention(input.Retention, context);
        contents = contents.n("Retention");
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_PutObjectTaggingCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xaebo]: input[_EBO],
        [_xarp]: input[_RP]
      });
      b2.bp("/{Key+}");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      b2.p("Key", () => input.Key, "{Key+}", true);
      const query = map({
        [_t]: [, ""],
        [_vI]: [, input[_VI]]
      });
      let body;
      let contents;
      if (input.Tagging !== void 0) {
        contents = se_Tagging(input.Tagging, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_PutPublicAccessBlockCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_pAB]: [, ""]
      });
      let body;
      let contents;
      if (input.PublicAccessBlockConfiguration !== void 0) {
        contents = se_PublicAccessBlockConfiguration(input.PublicAccessBlockConfiguration, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_RenameObjectCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xars]: input[_RS],
        [_im]: input[_DIM],
        [_inm]: input[_DINM],
        [_ims]: [() => isSerializableHeaderValue(input[_DIMS]), () => dateToUtcString(input[_DIMS]).toString()],
        [_ius]: [() => isSerializableHeaderValue(input[_DIUS]), () => dateToUtcString(input[_DIUS]).toString()],
        [_xarsim]: input[_SIM],
        [_xarsinm]: input[_SINM],
        [_xarsims]: [() => isSerializableHeaderValue(input[_SIMS]), () => dateToUtcString(input[_SIMS]).toString()],
        [_xarsius]: [() => isSerializableHeaderValue(input[_SIUS]), () => dateToUtcString(input[_SIUS]).toString()],
        [_xact_]: input[_CTl] ?? v4()
      });
      b2.bp("/{Key+}");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      b2.p("Key", () => input.Key, "{Key+}", true);
      const query = map({
        [_rO]: [, ""]
      });
      let body;
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_RestoreObjectCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_xarp]: input[_RP],
        [_xasca]: input[_CA],
        [_xaebo]: input[_EBO]
      });
      b2.bp("/{Key+}");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      b2.p("Key", () => input.Key, "{Key+}", true);
      const query = map({
        [_res]: [, ""],
        [_vI]: [, input[_VI]]
      });
      let body;
      let contents;
      if (input.RestoreRequest !== void 0) {
        contents = se_RestoreRequest(input.RestoreRequest, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("POST").h(headers).q(query).b(body);
      return b2.build();
    };
    se_SelectObjectContentCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_xasseca]: input[_SSECA],
        [_xasseck]: input[_SSECK],
        [_xasseckm]: input[_SSECKMD],
        [_xaebo]: input[_EBO]
      });
      b2.bp("/{Key+}");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      b2.p("Key", () => input.Key, "{Key+}", true);
      const query = map({
        [_se]: [, ""],
        [_st]: [, "2"]
      });
      let body;
      body = _ve;
      const bn2 = new XmlNode(_SOCR);
      bn2.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
      bn2.cc(input, _Ex);
      bn2.cc(input, _ETx);
      if (input[_IS] != null) {
        bn2.c(se_InputSerialization(input[_IS], context).n(_IS));
      }
      if (input[_OS] != null) {
        bn2.c(se_OutputSerialization(input[_OS], context).n(_OS));
      }
      if (input[_RPe] != null) {
        bn2.c(se_RequestProgress(input[_RPe], context).n(_RPe));
      }
      if (input[_SR] != null) {
        bn2.c(se_ScanRange(input[_SR], context).n(_SR));
      }
      body += bn2.toString();
      b2.m("POST").h(headers).q(query).b(body);
      return b2.build();
    };
    se_UpdateBucketMetadataInventoryTableConfigurationCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_mIT]: [, ""]
      });
      let body;
      let contents;
      if (input.InventoryTableConfiguration !== void 0) {
        contents = se_InventoryTableConfigurationUpdates(input.InventoryTableConfiguration, context);
        contents = contents.n("InventoryTableConfiguration");
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_UpdateBucketMetadataJournalTableConfigurationCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xaebo]: input[_EBO]
      });
      b2.bp("/");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      const query = map({
        [_mJT]: [, ""]
      });
      let body;
      let contents;
      if (input.JournalTableConfiguration !== void 0) {
        contents = se_JournalTableConfigurationUpdates(input.JournalTableConfiguration, context);
        contents = contents.n("JournalTableConfiguration");
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
      }
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_UploadPartCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/octet-stream",
        [_cl_]: [() => isSerializableHeaderValue(input[_CLo]), () => input[_CLo].toString()],
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xacc]: input[_CCRC],
        [_xacc_]: input[_CCRCC],
        [_xacc__]: input[_CCRCNVME],
        [_xacs]: input[_CSHA],
        [_xacs_]: input[_CSHAh],
        [_xasseca]: input[_SSECA],
        [_xasseck]: input[_SSECK],
        [_xasseckm]: input[_SSECKMD],
        [_xarp]: input[_RP],
        [_xaebo]: input[_EBO]
      });
      b2.bp("/{Key+}");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      b2.p("Key", () => input.Key, "{Key+}", true);
      const query = map({
        [_xi]: [, "UploadPart"],
        [_pN]: [expectNonNull(input.PartNumber, `PartNumber`) != null, () => input[_PN].toString()],
        [_uI]: [, expectNonNull(input[_UI], `UploadId`)]
      });
      let body;
      let contents;
      if (input.Body !== void 0) {
        contents = input.Body;
        body = contents;
      }
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_UploadPartCopyCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        [_xacs__]: input[_CS],
        [_xacsim]: input[_CSIM],
        [_xacsims]: [() => isSerializableHeaderValue(input[_CSIMS]), () => dateToUtcString(input[_CSIMS]).toString()],
        [_xacsinm]: input[_CSINM],
        [_xacsius]: [() => isSerializableHeaderValue(input[_CSIUS]), () => dateToUtcString(input[_CSIUS]).toString()],
        [_xacsr]: input[_CSR],
        [_xasseca]: input[_SSECA],
        [_xasseck]: input[_SSECK],
        [_xasseckm]: input[_SSECKMD],
        [_xacssseca]: input[_CSSSECA],
        [_xacssseck]: input[_CSSSECK],
        [_xacssseckm]: input[_CSSSECKMD],
        [_xarp]: input[_RP],
        [_xaebo]: input[_EBO],
        [_xasebo]: input[_ESBO]
      });
      b2.bp("/{Key+}");
      b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
      b2.p("Key", () => input.Key, "{Key+}", true);
      const query = map({
        [_xi]: [, "UploadPartCopy"],
        [_pN]: [expectNonNull(input.PartNumber, `PartNumber`) != null, () => input[_PN].toString()],
        [_uI]: [, expectNonNull(input[_UI], `UploadId`)]
      });
      let body;
      b2.m("PUT").h(headers).q(query).b(body);
      return b2.build();
    };
    se_WriteGetObjectResponseCommand = async (input, context) => {
      const b2 = requestBuilder(input, context);
      const headers = map({}, isSerializableHeaderValue, {
        "x-amz-content-sha256": "UNSIGNED-PAYLOAD",
        ...input.Metadata !== void 0 && Object.keys(input.Metadata).reduce((acc, suffix) => {
          acc[`x-amz-meta-${suffix.toLowerCase()}`] = input.Metadata[suffix];
          return acc;
        }, {}),
        "content-type": "application/octet-stream",
        [_xarr]: input[_RR],
        [_xart]: input[_RT],
        [_xafs]: [() => isSerializableHeaderValue(input[_SCt]), () => input[_SCt].toString()],
        [_xafec]: input[_EC],
        [_xafem]: input[_EM],
        [_xafhar]: input[_AR],
        [_xafhcc]: input[_CC],
        [_xafhcd]: input[_CD],
        [_xafhce]: input[_CE],
        [_xafhcl]: input[_CL],
        [_cl_]: [() => isSerializableHeaderValue(input[_CLo]), () => input[_CLo].toString()],
        [_xafhcr]: input[_CR],
        [_xafhct]: input[_CTo],
        [_xafhxacc]: input[_CCRC],
        [_xafhxacc_]: input[_CCRCC],
        [_xafhxacc__]: input[_CCRCNVME],
        [_xafhxacs]: input[_CSHA],
        [_xafhxacs_]: input[_CSHAh],
        [_xafhxadm]: [() => isSerializableHeaderValue(input[_DM]), () => input[_DM].toString()],
        [_xafhe]: input[_ETa],
        [_xafhe_]: [() => isSerializableHeaderValue(input[_E]), () => dateToUtcString(input[_E]).toString()],
        [_xafhxae]: input[_Exp],
        [_xafhlm]: [() => isSerializableHeaderValue(input[_LM]), () => dateToUtcString(input[_LM]).toString()],
        [_xafhxamm]: [() => isSerializableHeaderValue(input[_MM]), () => input[_MM].toString()],
        [_xafhxaolm]: input[_OLM],
        [_xafhxaollh]: input[_OLLHS],
        [_xafhxaolrud]: [
          () => isSerializableHeaderValue(input[_OLRUD]),
          () => serializeDateTime(input[_OLRUD]).toString()
        ],
        [_xafhxampc]: [() => isSerializableHeaderValue(input[_PC]), () => input[_PC].toString()],
        [_xafhxars]: input[_RSe],
        [_xafhxarc]: input[_RC],
        [_xafhxar]: input[_Re],
        [_xafhxasse]: input[_SSE],
        [_xafhxasseca]: input[_SSECA],
        [_xafhxasseakki]: input[_SSEKMSKI],
        [_xafhxasseckm]: input[_SSECKMD],
        [_xafhxasc]: input[_SC],
        [_xafhxatc]: [() => isSerializableHeaderValue(input[_TC]), () => input[_TC].toString()],
        [_xafhxavi]: input[_VI],
        [_xafhxassebke]: [() => isSerializableHeaderValue(input[_BKE]), () => input[_BKE].toString()]
      });
      b2.bp("/WriteGetObjectResponse");
      let body;
      let contents;
      if (input.Body !== void 0) {
        contents = input.Body;
        body = contents;
      }
      let { hostname: resolvedHostname } = await context.endpoint();
      if (context.disableHostPrefix !== true) {
        resolvedHostname = "{RequestRoute}." + resolvedHostname;
        if (input.RequestRoute === void 0) {
          throw new Error("Empty value provided for input host prefix: RequestRoute.");
        }
        resolvedHostname = resolvedHostname.replace("{RequestRoute}", input.RequestRoute);
        if (!isValidHostname(resolvedHostname)) {
          throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
      }
      b2.hn(resolvedHostname);
      b2.m("POST").h(headers).b(body);
      return b2.build();
    };
    de_AbortMultipartUploadCommand = async (output, context) => {
      if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_RC]: [, output.headers[_xarc]]
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_CompleteMultipartUploadCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_Exp]: [, output.headers[_xae]],
        [_SSE]: [, output.headers[_xasse]],
        [_VI]: [, output.headers[_xavi]],
        [_SSEKMSKI]: [, output.headers[_xasseakki]],
        [_BKE]: [() => void 0 !== output.headers[_xassebke], () => parseBoolean(output.headers[_xassebke])],
        [_RC]: [, output.headers[_xarc]]
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (data[_B] != null) {
        contents[_B] = expectString(data[_B]);
      }
      if (data[_CCRC] != null) {
        contents[_CCRC] = expectString(data[_CCRC]);
      }
      if (data[_CCRCC] != null) {
        contents[_CCRCC] = expectString(data[_CCRCC]);
      }
      if (data[_CCRCNVME] != null) {
        contents[_CCRCNVME] = expectString(data[_CCRCNVME]);
      }
      if (data[_CSHA] != null) {
        contents[_CSHA] = expectString(data[_CSHA]);
      }
      if (data[_CSHAh] != null) {
        contents[_CSHAh] = expectString(data[_CSHAh]);
      }
      if (data[_CT] != null) {
        contents[_CT] = expectString(data[_CT]);
      }
      if (data[_ETa] != null) {
        contents[_ETa] = expectString(data[_ETa]);
      }
      if (data[_K] != null) {
        contents[_K] = expectString(data[_K]);
      }
      if (data[_L] != null) {
        contents[_L] = expectString(data[_L]);
      }
      return contents;
    };
    de_CopyObjectCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_Exp]: [, output.headers[_xae]],
        [_CSVI]: [, output.headers[_xacsvi]],
        [_VI]: [, output.headers[_xavi]],
        [_SSE]: [, output.headers[_xasse]],
        [_SSECA]: [, output.headers[_xasseca]],
        [_SSECKMD]: [, output.headers[_xasseckm]],
        [_SSEKMSKI]: [, output.headers[_xasseakki]],
        [_SSEKMSEC]: [, output.headers[_xassec]],
        [_BKE]: [() => void 0 !== output.headers[_xassebke], () => parseBoolean(output.headers[_xassebke])],
        [_RC]: [, output.headers[_xarc]]
      });
      const data = expectObject(await parseXmlBody(output.body, context));
      contents.CopyObjectResult = de_CopyObjectResult(data, context);
      return contents;
    };
    de_CreateBucketCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_L]: [, output.headers[_lo]],
        [_BA]: [, output.headers[_xaba]]
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_CreateBucketMetadataConfigurationCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_CreateBucketMetadataTableConfigurationCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_CreateMultipartUploadCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_AD]: [
          () => void 0 !== output.headers[_xaad],
          () => expectNonNull(parseRfc7231DateTime(output.headers[_xaad]))
        ],
        [_ARI]: [, output.headers[_xaari]],
        [_SSE]: [, output.headers[_xasse]],
        [_SSECA]: [, output.headers[_xasseca]],
        [_SSECKMD]: [, output.headers[_xasseckm]],
        [_SSEKMSKI]: [, output.headers[_xasseakki]],
        [_SSEKMSEC]: [, output.headers[_xassec]],
        [_BKE]: [() => void 0 !== output.headers[_xassebke], () => parseBoolean(output.headers[_xassebke])],
        [_RC]: [, output.headers[_xarc]],
        [_CA]: [, output.headers[_xaca]],
        [_CT]: [, output.headers[_xact]]
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (data[_B] != null) {
        contents[_B] = expectString(data[_B]);
      }
      if (data[_K] != null) {
        contents[_K] = expectString(data[_K]);
      }
      if (data[_UI] != null) {
        contents[_UI] = expectString(data[_UI]);
      }
      return contents;
    };
    de_CreateSessionCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_SSE]: [, output.headers[_xasse]],
        [_SSEKMSKI]: [, output.headers[_xasseakki]],
        [_SSEKMSEC]: [, output.headers[_xassec]],
        [_BKE]: [() => void 0 !== output.headers[_xassebke], () => parseBoolean(output.headers[_xassebke])]
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (data[_C] != null) {
        contents[_C] = de_SessionCredentials(data[_C], context);
      }
      return contents;
    };
    de_DeleteBucketCommand = async (output, context) => {
      if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_DeleteBucketAnalyticsConfigurationCommand = async (output, context) => {
      if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_DeleteBucketCorsCommand = async (output, context) => {
      if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_DeleteBucketEncryptionCommand = async (output, context) => {
      if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_DeleteBucketIntelligentTieringConfigurationCommand = async (output, context) => {
      if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_DeleteBucketInventoryConfigurationCommand = async (output, context) => {
      if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_DeleteBucketLifecycleCommand = async (output, context) => {
      if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_DeleteBucketMetadataConfigurationCommand = async (output, context) => {
      if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_DeleteBucketMetadataTableConfigurationCommand = async (output, context) => {
      if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_DeleteBucketMetricsConfigurationCommand = async (output, context) => {
      if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_DeleteBucketOwnershipControlsCommand = async (output, context) => {
      if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_DeleteBucketPolicyCommand = async (output, context) => {
      if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_DeleteBucketReplicationCommand = async (output, context) => {
      if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_DeleteBucketTaggingCommand = async (output, context) => {
      if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_DeleteBucketWebsiteCommand = async (output, context) => {
      if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_DeleteObjectCommand = async (output, context) => {
      if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_DM]: [() => void 0 !== output.headers[_xadm], () => parseBoolean(output.headers[_xadm])],
        [_VI]: [, output.headers[_xavi]],
        [_RC]: [, output.headers[_xarc]]
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_DeleteObjectsCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_RC]: [, output.headers[_xarc]]
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (String(data.Deleted).trim() === "") {
        contents[_De] = [];
      } else if (data[_De] != null) {
        contents[_De] = de_DeletedObjects(getArrayIfSingleItem(data[_De]), context);
      }
      if (String(data.Error).trim() === "") {
        contents[_Err] = [];
      } else if (data[_Er] != null) {
        contents[_Err] = de_Errors(getArrayIfSingleItem(data[_Er]), context);
      }
      return contents;
    };
    de_DeleteObjectTaggingCommand = async (output, context) => {
      if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_VI]: [, output.headers[_xavi]]
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_DeletePublicAccessBlockCommand = async (output, context) => {
      if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_GetBucketAccelerateConfigurationCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_RC]: [, output.headers[_xarc]]
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (data[_S] != null) {
        contents[_S] = expectString(data[_S]);
      }
      return contents;
    };
    de_GetBucketAclCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (String(data.AccessControlList).trim() === "") {
        contents[_Gr] = [];
      } else if (data[_ACLc] != null && data[_ACLc][_G] != null) {
        contents[_Gr] = de_Grants(getArrayIfSingleItem(data[_ACLc][_G]), context);
      }
      if (data[_O] != null) {
        contents[_O] = de_Owner(data[_O], context);
      }
      return contents;
    };
    de_GetBucketAnalyticsConfigurationCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectObject(await parseXmlBody(output.body, context));
      contents.AnalyticsConfiguration = de_AnalyticsConfiguration(data, context);
      return contents;
    };
    de_GetBucketCorsCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (String(data.CORSRule).trim() === "") {
        contents[_CORSRu] = [];
      } else if (data[_CORSR] != null) {
        contents[_CORSRu] = de_CORSRules(getArrayIfSingleItem(data[_CORSR]), context);
      }
      return contents;
    };
    de_GetBucketEncryptionCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectObject(await parseXmlBody(output.body, context));
      contents.ServerSideEncryptionConfiguration = de_ServerSideEncryptionConfiguration(data, context);
      return contents;
    };
    de_GetBucketIntelligentTieringConfigurationCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectObject(await parseXmlBody(output.body, context));
      contents.IntelligentTieringConfiguration = de_IntelligentTieringConfiguration(data, context);
      return contents;
    };
    de_GetBucketInventoryConfigurationCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectObject(await parseXmlBody(output.body, context));
      contents.InventoryConfiguration = de_InventoryConfiguration(data, context);
      return contents;
    };
    de_GetBucketLifecycleConfigurationCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_TDMOS]: [, output.headers[_xatdmos]]
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (String(data.Rule).trim() === "") {
        contents[_Rul] = [];
      } else if (data[_Ru] != null) {
        contents[_Rul] = de_LifecycleRules(getArrayIfSingleItem(data[_Ru]), context);
      }
      return contents;
    };
    de_GetBucketLocationCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (data[_LC] != null) {
        contents[_LC] = expectString(data[_LC]);
      }
      return contents;
    };
    de_GetBucketLoggingCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (data[_LE] != null) {
        contents[_LE] = de_LoggingEnabled(data[_LE], context);
      }
      return contents;
    };
    de_GetBucketMetadataConfigurationCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectObject(await parseXmlBody(output.body, context));
      contents.GetBucketMetadataConfigurationResult = de_GetBucketMetadataConfigurationResult(data, context);
      return contents;
    };
    de_GetBucketMetadataTableConfigurationCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectObject(await parseXmlBody(output.body, context));
      contents.GetBucketMetadataTableConfigurationResult = de_GetBucketMetadataTableConfigurationResult(data, context);
      return contents;
    };
    de_GetBucketMetricsConfigurationCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectObject(await parseXmlBody(output.body, context));
      contents.MetricsConfiguration = de_MetricsConfiguration(data, context);
      return contents;
    };
    de_GetBucketNotificationConfigurationCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (data[_EBC] != null) {
        contents[_EBC] = de_EventBridgeConfiguration(data[_EBC], context);
      }
      if (String(data.CloudFunctionConfiguration).trim() === "") {
        contents[_LFC] = [];
      } else if (data[_CFC] != null) {
        contents[_LFC] = de_LambdaFunctionConfigurationList(getArrayIfSingleItem(data[_CFC]), context);
      }
      if (String(data.QueueConfiguration).trim() === "") {
        contents[_QCu] = [];
      } else if (data[_QC] != null) {
        contents[_QCu] = de_QueueConfigurationList(getArrayIfSingleItem(data[_QC]), context);
      }
      if (String(data.TopicConfiguration).trim() === "") {
        contents[_TCop] = [];
      } else if (data[_TCo] != null) {
        contents[_TCop] = de_TopicConfigurationList(getArrayIfSingleItem(data[_TCo]), context);
      }
      return contents;
    };
    de_GetBucketOwnershipControlsCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectObject(await parseXmlBody(output.body, context));
      contents.OwnershipControls = de_OwnershipControls(data, context);
      return contents;
    };
    de_GetBucketPolicyCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = await collectBodyString2(output.body, context);
      contents.Policy = expectString(data);
      return contents;
    };
    de_GetBucketPolicyStatusCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectObject(await parseXmlBody(output.body, context));
      contents.PolicyStatus = de_PolicyStatus(data, context);
      return contents;
    };
    de_GetBucketReplicationCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectObject(await parseXmlBody(output.body, context));
      contents.ReplicationConfiguration = de_ReplicationConfiguration(data, context);
      return contents;
    };
    de_GetBucketRequestPaymentCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (data[_Pa] != null) {
        contents[_Pa] = expectString(data[_Pa]);
      }
      return contents;
    };
    de_GetBucketTaggingCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (String(data.TagSet).trim() === "") {
        contents[_TS] = [];
      } else if (data[_TS] != null && data[_TS][_Ta] != null) {
        contents[_TS] = de_TagSet(getArrayIfSingleItem(data[_TS][_Ta]), context);
      }
      return contents;
    };
    de_GetBucketVersioningCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (data[_MDf] != null) {
        contents[_MFAD] = expectString(data[_MDf]);
      }
      if (data[_S] != null) {
        contents[_S] = expectString(data[_S]);
      }
      return contents;
    };
    de_GetBucketWebsiteCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (data[_ED] != null) {
        contents[_ED] = de_ErrorDocument(data[_ED], context);
      }
      if (data[_ID] != null) {
        contents[_ID] = de_IndexDocument(data[_ID], context);
      }
      if (data[_RART] != null) {
        contents[_RART] = de_RedirectAllRequestsTo(data[_RART], context);
      }
      if (String(data.RoutingRules).trim() === "") {
        contents[_RRo] = [];
      } else if (data[_RRo] != null && data[_RRo][_RRou] != null) {
        contents[_RRo] = de_RoutingRules(getArrayIfSingleItem(data[_RRo][_RRou]), context);
      }
      return contents;
    };
    de_GetObjectCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_DM]: [() => void 0 !== output.headers[_xadm], () => parseBoolean(output.headers[_xadm])],
        [_AR]: [, output.headers[_ar]],
        [_Exp]: [, output.headers[_xae]],
        [_Re]: [, output.headers[_xar]],
        [_LM]: [() => void 0 !== output.headers[_lm], () => expectNonNull(parseRfc7231DateTime(output.headers[_lm]))],
        [_CLo]: [() => void 0 !== output.headers[_cl_], () => strictParseLong(output.headers[_cl_])],
        [_ETa]: [, output.headers[_eta]],
        [_CCRC]: [, output.headers[_xacc]],
        [_CCRCC]: [, output.headers[_xacc_]],
        [_CCRCNVME]: [, output.headers[_xacc__]],
        [_CSHA]: [, output.headers[_xacs]],
        [_CSHAh]: [, output.headers[_xacs_]],
        [_CT]: [, output.headers[_xact]],
        [_MM]: [() => void 0 !== output.headers[_xamm], () => strictParseInt32(output.headers[_xamm])],
        [_VI]: [, output.headers[_xavi]],
        [_CC]: [, output.headers[_cc]],
        [_CD]: [, output.headers[_cd]],
        [_CE]: [, output.headers[_ce]],
        [_CL]: [, output.headers[_cl]],
        [_CR]: [, output.headers[_cr]],
        [_CTo]: [, output.headers[_ct]],
        [_E]: [() => void 0 !== output.headers[_e], () => expectNonNull(parseRfc7231DateTime(output.headers[_e]))],
        [_ES]: [, output.headers[_ex]],
        [_WRL]: [, output.headers[_xawrl]],
        [_SSE]: [, output.headers[_xasse]],
        [_SSECA]: [, output.headers[_xasseca]],
        [_SSECKMD]: [, output.headers[_xasseckm]],
        [_SSEKMSKI]: [, output.headers[_xasseakki]],
        [_BKE]: [() => void 0 !== output.headers[_xassebke], () => parseBoolean(output.headers[_xassebke])],
        [_SC]: [, output.headers[_xasc]],
        [_RC]: [, output.headers[_xarc]],
        [_RSe]: [, output.headers[_xars_]],
        [_PC]: [() => void 0 !== output.headers[_xampc], () => strictParseInt32(output.headers[_xampc])],
        [_TC]: [() => void 0 !== output.headers[_xatc], () => strictParseInt32(output.headers[_xatc])],
        [_OLM]: [, output.headers[_xaolm]],
        [_OLRUD]: [
          () => void 0 !== output.headers[_xaolrud],
          () => expectNonNull(parseRfc3339DateTimeWithOffset(output.headers[_xaolrud]))
        ],
        [_OLLHS]: [, output.headers[_xaollh]],
        Metadata: [
          ,
          Object.keys(output.headers).filter((header) => header.startsWith("x-amz-meta-")).reduce((acc, header) => {
            acc[header.substring(11)] = output.headers[header];
            return acc;
          }, {})
        ]
      });
      const data = output.body;
      context.sdkStreamMixin(data);
      contents.Body = data;
      return contents;
    };
    de_GetObjectAclCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_RC]: [, output.headers[_xarc]]
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (String(data.AccessControlList).trim() === "") {
        contents[_Gr] = [];
      } else if (data[_ACLc] != null && data[_ACLc][_G] != null) {
        contents[_Gr] = de_Grants(getArrayIfSingleItem(data[_ACLc][_G]), context);
      }
      if (data[_O] != null) {
        contents[_O] = de_Owner(data[_O], context);
      }
      return contents;
    };
    de_GetObjectAttributesCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_DM]: [() => void 0 !== output.headers[_xadm], () => parseBoolean(output.headers[_xadm])],
        [_LM]: [() => void 0 !== output.headers[_lm], () => expectNonNull(parseRfc7231DateTime(output.headers[_lm]))],
        [_VI]: [, output.headers[_xavi]],
        [_RC]: [, output.headers[_xarc]]
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (data[_Ch] != null) {
        contents[_Ch] = de_Checksum(data[_Ch], context);
      }
      if (data[_ETa] != null) {
        contents[_ETa] = expectString(data[_ETa]);
      }
      if (data[_OP] != null) {
        contents[_OP] = de_GetObjectAttributesParts(data[_OP], context);
      }
      if (data[_OSb] != null) {
        contents[_OSb] = strictParseLong(data[_OSb]);
      }
      if (data[_SC] != null) {
        contents[_SC] = expectString(data[_SC]);
      }
      return contents;
    };
    de_GetObjectLegalHoldCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectObject(await parseXmlBody(output.body, context));
      contents.LegalHold = de_ObjectLockLegalHold(data, context);
      return contents;
    };
    de_GetObjectLockConfigurationCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectObject(await parseXmlBody(output.body, context));
      contents.ObjectLockConfiguration = de_ObjectLockConfiguration(data, context);
      return contents;
    };
    de_GetObjectRetentionCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectObject(await parseXmlBody(output.body, context));
      contents.Retention = de_ObjectLockRetention(data, context);
      return contents;
    };
    de_GetObjectTaggingCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_VI]: [, output.headers[_xavi]]
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (String(data.TagSet).trim() === "") {
        contents[_TS] = [];
      } else if (data[_TS] != null && data[_TS][_Ta] != null) {
        contents[_TS] = de_TagSet(getArrayIfSingleItem(data[_TS][_Ta]), context);
      }
      return contents;
    };
    de_GetObjectTorrentCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_RC]: [, output.headers[_xarc]]
      });
      const data = output.body;
      context.sdkStreamMixin(data);
      contents.Body = data;
      return contents;
    };
    de_GetPublicAccessBlockCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectObject(await parseXmlBody(output.body, context));
      contents.PublicAccessBlockConfiguration = de_PublicAccessBlockConfiguration(data, context);
      return contents;
    };
    de_HeadBucketCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_BA]: [, output.headers[_xaba]],
        [_BLT]: [, output.headers[_xablt]],
        [_BLN]: [, output.headers[_xabln]],
        [_BR]: [, output.headers[_xabr]],
        [_APA]: [() => void 0 !== output.headers[_xaapa], () => parseBoolean(output.headers[_xaapa])]
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_HeadObjectCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_DM]: [() => void 0 !== output.headers[_xadm], () => parseBoolean(output.headers[_xadm])],
        [_AR]: [, output.headers[_ar]],
        [_Exp]: [, output.headers[_xae]],
        [_Re]: [, output.headers[_xar]],
        [_AS]: [, output.headers[_xaas]],
        [_LM]: [() => void 0 !== output.headers[_lm], () => expectNonNull(parseRfc7231DateTime(output.headers[_lm]))],
        [_CLo]: [() => void 0 !== output.headers[_cl_], () => strictParseLong(output.headers[_cl_])],
        [_CCRC]: [, output.headers[_xacc]],
        [_CCRCC]: [, output.headers[_xacc_]],
        [_CCRCNVME]: [, output.headers[_xacc__]],
        [_CSHA]: [, output.headers[_xacs]],
        [_CSHAh]: [, output.headers[_xacs_]],
        [_CT]: [, output.headers[_xact]],
        [_ETa]: [, output.headers[_eta]],
        [_MM]: [() => void 0 !== output.headers[_xamm], () => strictParseInt32(output.headers[_xamm])],
        [_VI]: [, output.headers[_xavi]],
        [_CC]: [, output.headers[_cc]],
        [_CD]: [, output.headers[_cd]],
        [_CE]: [, output.headers[_ce]],
        [_CL]: [, output.headers[_cl]],
        [_CTo]: [, output.headers[_ct]],
        [_CR]: [, output.headers[_cr]],
        [_E]: [() => void 0 !== output.headers[_e], () => expectNonNull(parseRfc7231DateTime(output.headers[_e]))],
        [_ES]: [, output.headers[_ex]],
        [_WRL]: [, output.headers[_xawrl]],
        [_SSE]: [, output.headers[_xasse]],
        [_SSECA]: [, output.headers[_xasseca]],
        [_SSECKMD]: [, output.headers[_xasseckm]],
        [_SSEKMSKI]: [, output.headers[_xasseakki]],
        [_BKE]: [() => void 0 !== output.headers[_xassebke], () => parseBoolean(output.headers[_xassebke])],
        [_SC]: [, output.headers[_xasc]],
        [_RC]: [, output.headers[_xarc]],
        [_RSe]: [, output.headers[_xars_]],
        [_PC]: [() => void 0 !== output.headers[_xampc], () => strictParseInt32(output.headers[_xampc])],
        [_TC]: [() => void 0 !== output.headers[_xatc], () => strictParseInt32(output.headers[_xatc])],
        [_OLM]: [, output.headers[_xaolm]],
        [_OLRUD]: [
          () => void 0 !== output.headers[_xaolrud],
          () => expectNonNull(parseRfc3339DateTimeWithOffset(output.headers[_xaolrud]))
        ],
        [_OLLHS]: [, output.headers[_xaollh]],
        Metadata: [
          ,
          Object.keys(output.headers).filter((header) => header.startsWith("x-amz-meta-")).reduce((acc, header) => {
            acc[header.substring(11)] = output.headers[header];
            return acc;
          }, {})
        ]
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_ListBucketAnalyticsConfigurationsCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (String(data.AnalyticsConfiguration).trim() === "") {
        contents[_ACLn] = [];
      } else if (data[_AC] != null) {
        contents[_ACLn] = de_AnalyticsConfigurationList(getArrayIfSingleItem(data[_AC]), context);
      }
      if (data[_CTon] != null) {
        contents[_CTon] = expectString(data[_CTon]);
      }
      if (data[_IT] != null) {
        contents[_IT] = parseBoolean(data[_IT]);
      }
      if (data[_NCT] != null) {
        contents[_NCT] = expectString(data[_NCT]);
      }
      return contents;
    };
    de_ListBucketIntelligentTieringConfigurationsCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (data[_CTon] != null) {
        contents[_CTon] = expectString(data[_CTon]);
      }
      if (String(data.IntelligentTieringConfiguration).trim() === "") {
        contents[_ITCL] = [];
      } else if (data[_ITC] != null) {
        contents[_ITCL] = de_IntelligentTieringConfigurationList(getArrayIfSingleItem(data[_ITC]), context);
      }
      if (data[_IT] != null) {
        contents[_IT] = parseBoolean(data[_IT]);
      }
      if (data[_NCT] != null) {
        contents[_NCT] = expectString(data[_NCT]);
      }
      return contents;
    };
    de_ListBucketInventoryConfigurationsCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (data[_CTon] != null) {
        contents[_CTon] = expectString(data[_CTon]);
      }
      if (String(data.InventoryConfiguration).trim() === "") {
        contents[_ICL] = [];
      } else if (data[_IC] != null) {
        contents[_ICL] = de_InventoryConfigurationList(getArrayIfSingleItem(data[_IC]), context);
      }
      if (data[_IT] != null) {
        contents[_IT] = parseBoolean(data[_IT]);
      }
      if (data[_NCT] != null) {
        contents[_NCT] = expectString(data[_NCT]);
      }
      return contents;
    };
    de_ListBucketMetricsConfigurationsCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (data[_CTon] != null) {
        contents[_CTon] = expectString(data[_CTon]);
      }
      if (data[_IT] != null) {
        contents[_IT] = parseBoolean(data[_IT]);
      }
      if (String(data.MetricsConfiguration).trim() === "") {
        contents[_MCL] = [];
      } else if (data[_MC] != null) {
        contents[_MCL] = de_MetricsConfigurationList(getArrayIfSingleItem(data[_MC]), context);
      }
      if (data[_NCT] != null) {
        contents[_NCT] = expectString(data[_NCT]);
      }
      return contents;
    };
    de_ListBucketsCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (String(data.Buckets).trim() === "") {
        contents[_Bu] = [];
      } else if (data[_Bu] != null && data[_Bu][_B] != null) {
        contents[_Bu] = de_Buckets(getArrayIfSingleItem(data[_Bu][_B]), context);
      }
      if (data[_CTon] != null) {
        contents[_CTon] = expectString(data[_CTon]);
      }
      if (data[_O] != null) {
        contents[_O] = de_Owner(data[_O], context);
      }
      if (data[_P] != null) {
        contents[_P] = expectString(data[_P]);
      }
      return contents;
    };
    de_ListDirectoryBucketsCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (String(data.Buckets).trim() === "") {
        contents[_Bu] = [];
      } else if (data[_Bu] != null && data[_Bu][_B] != null) {
        contents[_Bu] = de_Buckets(getArrayIfSingleItem(data[_Bu][_B]), context);
      }
      if (data[_CTon] != null) {
        contents[_CTon] = expectString(data[_CTon]);
      }
      return contents;
    };
    de_ListMultipartUploadsCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_RC]: [, output.headers[_xarc]]
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (data[_B] != null) {
        contents[_B] = expectString(data[_B]);
      }
      if (String(data.CommonPrefixes).trim() === "") {
        contents[_CP] = [];
      } else if (data[_CP] != null) {
        contents[_CP] = de_CommonPrefixList(getArrayIfSingleItem(data[_CP]), context);
      }
      if (data[_D] != null) {
        contents[_D] = expectString(data[_D]);
      }
      if (data[_ET] != null) {
        contents[_ET] = expectString(data[_ET]);
      }
      if (data[_IT] != null) {
        contents[_IT] = parseBoolean(data[_IT]);
      }
      if (data[_KM] != null) {
        contents[_KM] = expectString(data[_KM]);
      }
      if (data[_MU] != null) {
        contents[_MU] = strictParseInt32(data[_MU]);
      }
      if (data[_NKM] != null) {
        contents[_NKM] = expectString(data[_NKM]);
      }
      if (data[_NUIM] != null) {
        contents[_NUIM] = expectString(data[_NUIM]);
      }
      if (data[_P] != null) {
        contents[_P] = expectString(data[_P]);
      }
      if (data[_UIM] != null) {
        contents[_UIM] = expectString(data[_UIM]);
      }
      if (String(data.Upload).trim() === "") {
        contents[_Up] = [];
      } else if (data[_U] != null) {
        contents[_Up] = de_MultipartUploadList(getArrayIfSingleItem(data[_U]), context);
      }
      return contents;
    };
    de_ListObjectsCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_RC]: [, output.headers[_xarc]]
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (String(data.CommonPrefixes).trim() === "") {
        contents[_CP] = [];
      } else if (data[_CP] != null) {
        contents[_CP] = de_CommonPrefixList(getArrayIfSingleItem(data[_CP]), context);
      }
      if (String(data.Contents).trim() === "") {
        contents[_Co] = [];
      } else if (data[_Co] != null) {
        contents[_Co] = de_ObjectList(getArrayIfSingleItem(data[_Co]), context);
      }
      if (data[_D] != null) {
        contents[_D] = expectString(data[_D]);
      }
      if (data[_ET] != null) {
        contents[_ET] = expectString(data[_ET]);
      }
      if (data[_IT] != null) {
        contents[_IT] = parseBoolean(data[_IT]);
      }
      if (data[_M] != null) {
        contents[_M] = expectString(data[_M]);
      }
      if (data[_MK] != null) {
        contents[_MK] = strictParseInt32(data[_MK]);
      }
      if (data[_N] != null) {
        contents[_N] = expectString(data[_N]);
      }
      if (data[_NM] != null) {
        contents[_NM] = expectString(data[_NM]);
      }
      if (data[_P] != null) {
        contents[_P] = expectString(data[_P]);
      }
      return contents;
    };
    de_ListObjectsV2Command = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_RC]: [, output.headers[_xarc]]
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (String(data.CommonPrefixes).trim() === "") {
        contents[_CP] = [];
      } else if (data[_CP] != null) {
        contents[_CP] = de_CommonPrefixList(getArrayIfSingleItem(data[_CP]), context);
      }
      if (String(data.Contents).trim() === "") {
        contents[_Co] = [];
      } else if (data[_Co] != null) {
        contents[_Co] = de_ObjectList(getArrayIfSingleItem(data[_Co]), context);
      }
      if (data[_CTon] != null) {
        contents[_CTon] = expectString(data[_CTon]);
      }
      if (data[_D] != null) {
        contents[_D] = expectString(data[_D]);
      }
      if (data[_ET] != null) {
        contents[_ET] = expectString(data[_ET]);
      }
      if (data[_IT] != null) {
        contents[_IT] = parseBoolean(data[_IT]);
      }
      if (data[_KC] != null) {
        contents[_KC] = strictParseInt32(data[_KC]);
      }
      if (data[_MK] != null) {
        contents[_MK] = strictParseInt32(data[_MK]);
      }
      if (data[_N] != null) {
        contents[_N] = expectString(data[_N]);
      }
      if (data[_NCT] != null) {
        contents[_NCT] = expectString(data[_NCT]);
      }
      if (data[_P] != null) {
        contents[_P] = expectString(data[_P]);
      }
      if (data[_SA] != null) {
        contents[_SA] = expectString(data[_SA]);
      }
      return contents;
    };
    de_ListObjectVersionsCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_RC]: [, output.headers[_xarc]]
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (String(data.CommonPrefixes).trim() === "") {
        contents[_CP] = [];
      } else if (data[_CP] != null) {
        contents[_CP] = de_CommonPrefixList(getArrayIfSingleItem(data[_CP]), context);
      }
      if (String(data.DeleteMarker).trim() === "") {
        contents[_DMe] = [];
      } else if (data[_DM] != null) {
        contents[_DMe] = de_DeleteMarkers(getArrayIfSingleItem(data[_DM]), context);
      }
      if (data[_D] != null) {
        contents[_D] = expectString(data[_D]);
      }
      if (data[_ET] != null) {
        contents[_ET] = expectString(data[_ET]);
      }
      if (data[_IT] != null) {
        contents[_IT] = parseBoolean(data[_IT]);
      }
      if (data[_KM] != null) {
        contents[_KM] = expectString(data[_KM]);
      }
      if (data[_MK] != null) {
        contents[_MK] = strictParseInt32(data[_MK]);
      }
      if (data[_N] != null) {
        contents[_N] = expectString(data[_N]);
      }
      if (data[_NKM] != null) {
        contents[_NKM] = expectString(data[_NKM]);
      }
      if (data[_NVIM] != null) {
        contents[_NVIM] = expectString(data[_NVIM]);
      }
      if (data[_P] != null) {
        contents[_P] = expectString(data[_P]);
      }
      if (data[_VIM] != null) {
        contents[_VIM] = expectString(data[_VIM]);
      }
      if (String(data.Version).trim() === "") {
        contents[_Ve] = [];
      } else if (data[_V] != null) {
        contents[_Ve] = de_ObjectVersionList(getArrayIfSingleItem(data[_V]), context);
      }
      return contents;
    };
    de_ListPartsCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_AD]: [
          () => void 0 !== output.headers[_xaad],
          () => expectNonNull(parseRfc7231DateTime(output.headers[_xaad]))
        ],
        [_ARI]: [, output.headers[_xaari]],
        [_RC]: [, output.headers[_xarc]]
      });
      const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
      if (data[_B] != null) {
        contents[_B] = expectString(data[_B]);
      }
      if (data[_CA] != null) {
        contents[_CA] = expectString(data[_CA]);
      }
      if (data[_CT] != null) {
        contents[_CT] = expectString(data[_CT]);
      }
      if (data[_In] != null) {
        contents[_In] = de_Initiator(data[_In], context);
      }
      if (data[_IT] != null) {
        contents[_IT] = parseBoolean(data[_IT]);
      }
      if (data[_K] != null) {
        contents[_K] = expectString(data[_K]);
      }
      if (data[_MP] != null) {
        contents[_MP] = strictParseInt32(data[_MP]);
      }
      if (data[_NPNM] != null) {
        contents[_NPNM] = expectString(data[_NPNM]);
      }
      if (data[_O] != null) {
        contents[_O] = de_Owner(data[_O], context);
      }
      if (data[_PNM] != null) {
        contents[_PNM] = expectString(data[_PNM]);
      }
      if (String(data.Part).trim() === "") {
        contents[_Part] = [];
      } else if (data[_Par] != null) {
        contents[_Part] = de_Parts(getArrayIfSingleItem(data[_Par]), context);
      }
      if (data[_SC] != null) {
        contents[_SC] = expectString(data[_SC]);
      }
      if (data[_UI] != null) {
        contents[_UI] = expectString(data[_UI]);
      }
      return contents;
    };
    de_PutBucketAccelerateConfigurationCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_PutBucketAclCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_PutBucketAnalyticsConfigurationCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_PutBucketCorsCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_PutBucketEncryptionCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_PutBucketIntelligentTieringConfigurationCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_PutBucketInventoryConfigurationCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_PutBucketLifecycleConfigurationCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_TDMOS]: [, output.headers[_xatdmos]]
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_PutBucketLoggingCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_PutBucketMetricsConfigurationCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_PutBucketNotificationConfigurationCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_PutBucketOwnershipControlsCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_PutBucketPolicyCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_PutBucketReplicationCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_PutBucketRequestPaymentCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_PutBucketTaggingCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_PutBucketVersioningCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_PutBucketWebsiteCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_PutObjectCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_Exp]: [, output.headers[_xae]],
        [_ETa]: [, output.headers[_eta]],
        [_CCRC]: [, output.headers[_xacc]],
        [_CCRCC]: [, output.headers[_xacc_]],
        [_CCRCNVME]: [, output.headers[_xacc__]],
        [_CSHA]: [, output.headers[_xacs]],
        [_CSHAh]: [, output.headers[_xacs_]],
        [_CT]: [, output.headers[_xact]],
        [_SSE]: [, output.headers[_xasse]],
        [_VI]: [, output.headers[_xavi]],
        [_SSECA]: [, output.headers[_xasseca]],
        [_SSECKMD]: [, output.headers[_xasseckm]],
        [_SSEKMSKI]: [, output.headers[_xasseakki]],
        [_SSEKMSEC]: [, output.headers[_xassec]],
        [_BKE]: [() => void 0 !== output.headers[_xassebke], () => parseBoolean(output.headers[_xassebke])],
        [_Si]: [() => void 0 !== output.headers[_xaos], () => strictParseLong(output.headers[_xaos])],
        [_RC]: [, output.headers[_xarc]]
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_PutObjectAclCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_RC]: [, output.headers[_xarc]]
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_PutObjectLegalHoldCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_RC]: [, output.headers[_xarc]]
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_PutObjectLockConfigurationCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_RC]: [, output.headers[_xarc]]
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_PutObjectRetentionCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_RC]: [, output.headers[_xarc]]
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_PutObjectTaggingCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_VI]: [, output.headers[_xavi]]
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_PutPublicAccessBlockCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_RenameObjectCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_RestoreObjectCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_RC]: [, output.headers[_xarc]],
        [_ROP]: [, output.headers[_xarop]]
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_SelectObjectContentCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      const data = output.body;
      contents.Payload = de_SelectObjectContentEventStream(data, context);
      return contents;
    };
    de_UpdateBucketMetadataInventoryTableConfigurationCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_UpdateBucketMetadataJournalTableConfigurationCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_UploadPartCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_SSE]: [, output.headers[_xasse]],
        [_ETa]: [, output.headers[_eta]],
        [_CCRC]: [, output.headers[_xacc]],
        [_CCRCC]: [, output.headers[_xacc_]],
        [_CCRCNVME]: [, output.headers[_xacc__]],
        [_CSHA]: [, output.headers[_xacs]],
        [_CSHAh]: [, output.headers[_xacs_]],
        [_SSECA]: [, output.headers[_xasseca]],
        [_SSECKMD]: [, output.headers[_xasseckm]],
        [_SSEKMSKI]: [, output.headers[_xasseakki]],
        [_BKE]: [() => void 0 !== output.headers[_xassebke], () => parseBoolean(output.headers[_xassebke])],
        [_RC]: [, output.headers[_xarc]]
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_UploadPartCopyCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output),
        [_CSVI]: [, output.headers[_xacsvi]],
        [_SSE]: [, output.headers[_xasse]],
        [_SSECA]: [, output.headers[_xasseca]],
        [_SSECKMD]: [, output.headers[_xasseckm]],
        [_SSEKMSKI]: [, output.headers[_xasseakki]],
        [_BKE]: [() => void 0 !== output.headers[_xassebke], () => parseBoolean(output.headers[_xassebke])],
        [_RC]: [, output.headers[_xarc]]
      });
      const data = expectObject(await parseXmlBody(output.body, context));
      contents.CopyPartResult = de_CopyPartResult(data, context);
      return contents;
    };
    de_WriteGetObjectResponseCommand = async (output, context) => {
      if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
      }
      const contents = map({
        $metadata: deserializeMetadata2(output)
      });
      await collectBody(output.body, context);
      return contents;
    };
    de_CommandError = async (output, context) => {
      const parsedOutput = {
        ...output,
        body: await parseXmlErrorBody(output.body, context)
      };
      const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
      switch (errorCode) {
        case "NoSuchUpload":
        case "com.amazonaws.s3#NoSuchUpload":
          throw await de_NoSuchUploadRes(parsedOutput, context);
        case "ObjectNotInActiveTierError":
        case "com.amazonaws.s3#ObjectNotInActiveTierError":
          throw await de_ObjectNotInActiveTierErrorRes(parsedOutput, context);
        case "BucketAlreadyExists":
        case "com.amazonaws.s3#BucketAlreadyExists":
          throw await de_BucketAlreadyExistsRes(parsedOutput, context);
        case "BucketAlreadyOwnedByYou":
        case "com.amazonaws.s3#BucketAlreadyOwnedByYou":
          throw await de_BucketAlreadyOwnedByYouRes(parsedOutput, context);
        case "NoSuchBucket":
        case "com.amazonaws.s3#NoSuchBucket":
          throw await de_NoSuchBucketRes(parsedOutput, context);
        case "InvalidObjectState":
        case "com.amazonaws.s3#InvalidObjectState":
          throw await de_InvalidObjectStateRes(parsedOutput, context);
        case "NoSuchKey":
        case "com.amazonaws.s3#NoSuchKey":
          throw await de_NoSuchKeyRes(parsedOutput, context);
        case "NotFound":
        case "com.amazonaws.s3#NotFound":
          throw await de_NotFoundRes(parsedOutput, context);
        case "EncryptionTypeMismatch":
        case "com.amazonaws.s3#EncryptionTypeMismatch":
          throw await de_EncryptionTypeMismatchRes(parsedOutput, context);
        case "InvalidRequest":
        case "com.amazonaws.s3#InvalidRequest":
          throw await de_InvalidRequestRes(parsedOutput, context);
        case "InvalidWriteOffset":
        case "com.amazonaws.s3#InvalidWriteOffset":
          throw await de_InvalidWriteOffsetRes(parsedOutput, context);
        case "TooManyParts":
        case "com.amazonaws.s3#TooManyParts":
          throw await de_TooManyPartsRes(parsedOutput, context);
        case "IdempotencyParameterMismatch":
        case "com.amazonaws.s3#IdempotencyParameterMismatch":
          throw await de_IdempotencyParameterMismatchRes(parsedOutput, context);
        case "ObjectAlreadyInActiveTierError":
        case "com.amazonaws.s3#ObjectAlreadyInActiveTierError":
          throw await de_ObjectAlreadyInActiveTierErrorRes(parsedOutput, context);
        default:
          const parsedBody = parsedOutput.body;
          return throwDefaultError2({
            output,
            parsedBody,
            errorCode
          });
      }
    };
    throwDefaultError2 = withBaseException(S3ServiceException);
    de_BucketAlreadyExistsRes = async (parsedOutput, context) => {
      const contents = map({});
      const data = parsedOutput.body;
      const exception = new BucketAlreadyExists({
        $metadata: deserializeMetadata2(parsedOutput),
        ...contents
      });
      return decorateServiceException(exception, parsedOutput.body);
    };
    de_BucketAlreadyOwnedByYouRes = async (parsedOutput, context) => {
      const contents = map({});
      const data = parsedOutput.body;
      const exception = new BucketAlreadyOwnedByYou({
        $metadata: deserializeMetadata2(parsedOutput),
        ...contents
      });
      return decorateServiceException(exception, parsedOutput.body);
    };
    de_EncryptionTypeMismatchRes = async (parsedOutput, context) => {
      const contents = map({});
      const data = parsedOutput.body;
      const exception = new EncryptionTypeMismatch({
        $metadata: deserializeMetadata2(parsedOutput),
        ...contents
      });
      return decorateServiceException(exception, parsedOutput.body);
    };
    de_IdempotencyParameterMismatchRes = async (parsedOutput, context) => {
      const contents = map({});
      const data = parsedOutput.body;
      const exception = new IdempotencyParameterMismatch({
        $metadata: deserializeMetadata2(parsedOutput),
        ...contents
      });
      return decorateServiceException(exception, parsedOutput.body);
    };
    de_InvalidObjectStateRes = async (parsedOutput, context) => {
      const contents = map({});
      const data = parsedOutput.body;
      if (data[_AT] != null) {
        contents[_AT] = expectString(data[_AT]);
      }
      if (data[_SC] != null) {
        contents[_SC] = expectString(data[_SC]);
      }
      const exception = new InvalidObjectState({
        $metadata: deserializeMetadata2(parsedOutput),
        ...contents
      });
      return decorateServiceException(exception, parsedOutput.body);
    };
    de_InvalidRequestRes = async (parsedOutput, context) => {
      const contents = map({});
      const data = parsedOutput.body;
      const exception = new InvalidRequest({
        $metadata: deserializeMetadata2(parsedOutput),
        ...contents
      });
      return decorateServiceException(exception, parsedOutput.body);
    };
    de_InvalidWriteOffsetRes = async (parsedOutput, context) => {
      const contents = map({});
      const data = parsedOutput.body;
      const exception = new InvalidWriteOffset({
        $metadata: deserializeMetadata2(parsedOutput),
        ...contents
      });
      return decorateServiceException(exception, parsedOutput.body);
    };
    de_NoSuchBucketRes = async (parsedOutput, context) => {
      const contents = map({});
      const data = parsedOutput.body;
      const exception = new NoSuchBucket({
        $metadata: deserializeMetadata2(parsedOutput),
        ...contents
      });
      return decorateServiceException(exception, parsedOutput.body);
    };
    de_NoSuchKeyRes = async (parsedOutput, context) => {
      const contents = map({});
      const data = parsedOutput.body;
      const exception = new NoSuchKey({
        $metadata: deserializeMetadata2(parsedOutput),
        ...contents
      });
      return decorateServiceException(exception, parsedOutput.body);
    };
    de_NoSuchUploadRes = async (parsedOutput, context) => {
      const contents = map({});
      const data = parsedOutput.body;
      const exception = new NoSuchUpload({
        $metadata: deserializeMetadata2(parsedOutput),
        ...contents
      });
      return decorateServiceException(exception, parsedOutput.body);
    };
    de_NotFoundRes = async (parsedOutput, context) => {
      const contents = map({});
      const data = parsedOutput.body;
      const exception = new NotFound({
        $metadata: deserializeMetadata2(parsedOutput),
        ...contents
      });
      return decorateServiceException(exception, parsedOutput.body);
    };
    de_ObjectAlreadyInActiveTierErrorRes = async (parsedOutput, context) => {
      const contents = map({});
      const data = parsedOutput.body;
      const exception = new ObjectAlreadyInActiveTierError({
        $metadata: deserializeMetadata2(parsedOutput),
        ...contents
      });
      return decorateServiceException(exception, parsedOutput.body);
    };
    de_ObjectNotInActiveTierErrorRes = async (parsedOutput, context) => {
      const contents = map({});
      const data = parsedOutput.body;
      const exception = new ObjectNotInActiveTierError({
        $metadata: deserializeMetadata2(parsedOutput),
        ...contents
      });
      return decorateServiceException(exception, parsedOutput.body);
    };
    de_TooManyPartsRes = async (parsedOutput, context) => {
      const contents = map({});
      const data = parsedOutput.body;
      const exception = new TooManyParts({
        $metadata: deserializeMetadata2(parsedOutput),
        ...contents
      });
      return decorateServiceException(exception, parsedOutput.body);
    };
    de_SelectObjectContentEventStream = (output, context) => {
      return context.eventStreamMarshaller.deserialize(output, async (event) => {
        if (event["Records"] != null) {
          return {
            Records: await de_RecordsEvent_event(event["Records"], context)
          };
        }
        if (event["Stats"] != null) {
          return {
            Stats: await de_StatsEvent_event(event["Stats"], context)
          };
        }
        if (event["Progress"] != null) {
          return {
            Progress: await de_ProgressEvent_event(event["Progress"], context)
          };
        }
        if (event["Cont"] != null) {
          return {
            Cont: await de_ContinuationEvent_event(event["Cont"], context)
          };
        }
        if (event["End"] != null) {
          return {
            End: await de_EndEvent_event(event["End"], context)
          };
        }
        return { $unknown: event };
      });
    };
    de_ContinuationEvent_event = async (output, context) => {
      const contents = {};
      const data = await parseXmlBody(output.body, context);
      Object.assign(contents, de_ContinuationEvent(data, context));
      return contents;
    };
    de_EndEvent_event = async (output, context) => {
      const contents = {};
      const data = await parseXmlBody(output.body, context);
      Object.assign(contents, de_EndEvent(data, context));
      return contents;
    };
    de_ProgressEvent_event = async (output, context) => {
      const contents = {};
      const data = await parseXmlBody(output.body, context);
      contents.Details = de_Progress(data, context);
      return contents;
    };
    de_RecordsEvent_event = async (output, context) => {
      const contents = {};
      contents.Payload = output.body;
      return contents;
    };
    de_StatsEvent_event = async (output, context) => {
      const contents = {};
      const data = await parseXmlBody(output.body, context);
      contents.Details = de_Stats(data, context);
      return contents;
    };
    se_AbortIncompleteMultipartUpload = (input, context) => {
      const bn2 = new XmlNode(_AIMU);
      if (input[_DAI] != null) {
        bn2.c(XmlNode.of(_DAI, String(input[_DAI])).n(_DAI));
      }
      return bn2;
    };
    se_AccelerateConfiguration = (input, context) => {
      const bn2 = new XmlNode(_ACc);
      if (input[_S] != null) {
        bn2.c(XmlNode.of(_BAS, input[_S]).n(_S));
      }
      return bn2;
    };
    se_AccessControlPolicy = (input, context) => {
      const bn2 = new XmlNode(_ACP);
      bn2.lc(input, "Grants", "AccessControlList", () => se_Grants(input[_Gr], context));
      if (input[_O] != null) {
        bn2.c(se_Owner(input[_O], context).n(_O));
      }
      return bn2;
    };
    se_AccessControlTranslation = (input, context) => {
      const bn2 = new XmlNode(_ACT);
      if (input[_O] != null) {
        bn2.c(XmlNode.of(_OOw, input[_O]).n(_O));
      }
      return bn2;
    };
    se_AllowedHeaders = (input, context) => {
      return input.filter((e2) => e2 != null).map((entry) => {
        const n2 = XmlNode.of(_AH, entry);
        return n2.n(_me);
      });
    };
    se_AllowedMethods = (input, context) => {
      return input.filter((e2) => e2 != null).map((entry) => {
        const n2 = XmlNode.of(_AM, entry);
        return n2.n(_me);
      });
    };
    se_AllowedOrigins = (input, context) => {
      return input.filter((e2) => e2 != null).map((entry) => {
        const n2 = XmlNode.of(_AO, entry);
        return n2.n(_me);
      });
    };
    se_AnalyticsAndOperator = (input, context) => {
      const bn2 = new XmlNode(_AAO);
      bn2.cc(input, _P);
      bn2.l(input, "Tags", "Tag", () => se_TagSet(input[_Tag], context));
      return bn2;
    };
    se_AnalyticsConfiguration = (input, context) => {
      const bn2 = new XmlNode(_AC);
      if (input[_I] != null) {
        bn2.c(XmlNode.of(_AI, input[_I]).n(_I));
      }
      if (input[_F] != null) {
        bn2.c(se_AnalyticsFilter(input[_F], context).n(_F));
      }
      if (input[_SCA] != null) {
        bn2.c(se_StorageClassAnalysis(input[_SCA], context).n(_SCA));
      }
      return bn2;
    };
    se_AnalyticsExportDestination = (input, context) => {
      const bn2 = new XmlNode(_AED);
      if (input[_SBD] != null) {
        bn2.c(se_AnalyticsS3BucketDestination(input[_SBD], context).n(_SBD));
      }
      return bn2;
    };
    se_AnalyticsFilter = (input, context) => {
      const bn2 = new XmlNode(_AF);
      AnalyticsFilter.visit(input, {
        Prefix: (value) => {
          if (input[_P] != null) {
            bn2.c(XmlNode.of(_P, value).n(_P));
          }
        },
        Tag: (value) => {
          if (input[_Ta] != null) {
            bn2.c(se_Tag(value, context).n(_Ta));
          }
        },
        And: (value) => {
          if (input[_A] != null) {
            bn2.c(se_AnalyticsAndOperator(value, context).n(_A));
          }
        },
        _: (name, value) => {
          if (!(value instanceof XmlNode || value instanceof XmlText)) {
            throw new Error("Unable to serialize unknown union members in XML.");
          }
          bn2.c(new XmlNode(name).c(value));
        }
      });
      return bn2;
    };
    se_AnalyticsS3BucketDestination = (input, context) => {
      const bn2 = new XmlNode(_ASBD);
      if (input[_Fo] != null) {
        bn2.c(XmlNode.of(_ASEFF, input[_Fo]).n(_Fo));
      }
      if (input[_BAI] != null) {
        bn2.c(XmlNode.of(_AIc, input[_BAI]).n(_BAI));
      }
      if (input[_B] != null) {
        bn2.c(XmlNode.of(_BN, input[_B]).n(_B));
      }
      bn2.cc(input, _P);
      return bn2;
    };
    se_BucketInfo = (input, context) => {
      const bn2 = new XmlNode(_BI);
      bn2.cc(input, _DR);
      if (input[_Ty] != null) {
        bn2.c(XmlNode.of(_BT, input[_Ty]).n(_Ty));
      }
      return bn2;
    };
    se_BucketLifecycleConfiguration = (input, context) => {
      const bn2 = new XmlNode(_BLC);
      bn2.l(input, "Rules", "Rule", () => se_LifecycleRules(input[_Rul], context));
      return bn2;
    };
    se_BucketLoggingStatus = (input, context) => {
      const bn2 = new XmlNode(_BLS);
      if (input[_LE] != null) {
        bn2.c(se_LoggingEnabled(input[_LE], context).n(_LE));
      }
      return bn2;
    };
    se_CompletedMultipartUpload = (input, context) => {
      const bn2 = new XmlNode(_CMU);
      bn2.l(input, "Parts", "Part", () => se_CompletedPartList(input[_Part], context));
      return bn2;
    };
    se_CompletedPart = (input, context) => {
      const bn2 = new XmlNode(_CPo);
      bn2.cc(input, _ETa);
      bn2.cc(input, _CCRC);
      bn2.cc(input, _CCRCC);
      bn2.cc(input, _CCRCNVME);
      bn2.cc(input, _CSHA);
      bn2.cc(input, _CSHAh);
      if (input[_PN] != null) {
        bn2.c(XmlNode.of(_PN, String(input[_PN])).n(_PN));
      }
      return bn2;
    };
    se_CompletedPartList = (input, context) => {
      return input.filter((e2) => e2 != null).map((entry) => {
        const n2 = se_CompletedPart(entry, context);
        return n2.n(_me);
      });
    };
    se_Condition = (input, context) => {
      const bn2 = new XmlNode(_Con);
      bn2.cc(input, _HECRE);
      bn2.cc(input, _KPE);
      return bn2;
    };
    se_CORSConfiguration = (input, context) => {
      const bn2 = new XmlNode(_CORSC);
      bn2.l(input, "CORSRules", "CORSRule", () => se_CORSRules(input[_CORSRu], context));
      return bn2;
    };
    se_CORSRule = (input, context) => {
      const bn2 = new XmlNode(_CORSR);
      bn2.cc(input, _ID_);
      bn2.l(input, "AllowedHeaders", "AllowedHeader", () => se_AllowedHeaders(input[_AHl], context));
      bn2.l(input, "AllowedMethods", "AllowedMethod", () => se_AllowedMethods(input[_AMl], context));
      bn2.l(input, "AllowedOrigins", "AllowedOrigin", () => se_AllowedOrigins(input[_AOl], context));
      bn2.l(input, "ExposeHeaders", "ExposeHeader", () => se_ExposeHeaders(input[_EH], context));
      if (input[_MAS] != null) {
        bn2.c(XmlNode.of(_MAS, String(input[_MAS])).n(_MAS));
      }
      return bn2;
    };
    se_CORSRules = (input, context) => {
      return input.filter((e2) => e2 != null).map((entry) => {
        const n2 = se_CORSRule(entry, context);
        return n2.n(_me);
      });
    };
    se_CreateBucketConfiguration = (input, context) => {
      const bn2 = new XmlNode(_CBC);
      if (input[_LC] != null) {
        bn2.c(XmlNode.of(_BLCu, input[_LC]).n(_LC));
      }
      if (input[_L] != null) {
        bn2.c(se_LocationInfo(input[_L], context).n(_L));
      }
      if (input[_B] != null) {
        bn2.c(se_BucketInfo(input[_B], context).n(_B));
      }
      bn2.lc(input, "Tags", "Tags", () => se_TagSet(input[_Tag], context));
      return bn2;
    };
    se_CSVInput = (input, context) => {
      const bn2 = new XmlNode(_CSVIn);
      bn2.cc(input, _FHI);
      bn2.cc(input, _Com);
      bn2.cc(input, _QEC);
      bn2.cc(input, _RD);
      bn2.cc(input, _FD);
      bn2.cc(input, _QCuo);
      if (input[_AQRD] != null) {
        bn2.c(XmlNode.of(_AQRD, String(input[_AQRD])).n(_AQRD));
      }
      return bn2;
    };
    se_CSVOutput = (input, context) => {
      const bn2 = new XmlNode(_CSVO);
      bn2.cc(input, _QF);
      bn2.cc(input, _QEC);
      bn2.cc(input, _RD);
      bn2.cc(input, _FD);
      bn2.cc(input, _QCuo);
      return bn2;
    };
    se_DefaultRetention = (input, context) => {
      const bn2 = new XmlNode(_DRe);
      if (input[_Mo] != null) {
        bn2.c(XmlNode.of(_OLRM, input[_Mo]).n(_Mo));
      }
      if (input[_Da] != null) {
        bn2.c(XmlNode.of(_Da, String(input[_Da])).n(_Da));
      }
      if (input[_Y] != null) {
        bn2.c(XmlNode.of(_Y, String(input[_Y])).n(_Y));
      }
      return bn2;
    };
    se_Delete = (input, context) => {
      const bn2 = new XmlNode(_Del);
      bn2.l(input, "Objects", "Object", () => se_ObjectIdentifierList(input[_Ob], context));
      if (input[_Q] != null) {
        bn2.c(XmlNode.of(_Q, String(input[_Q])).n(_Q));
      }
      return bn2;
    };
    se_DeleteMarkerReplication = (input, context) => {
      const bn2 = new XmlNode(_DMR);
      if (input[_S] != null) {
        bn2.c(XmlNode.of(_DMRS, input[_S]).n(_S));
      }
      return bn2;
    };
    se_Destination = (input, context) => {
      const bn2 = new XmlNode(_Des);
      if (input[_B] != null) {
        bn2.c(XmlNode.of(_BN, input[_B]).n(_B));
      }
      if (input[_Ac] != null) {
        bn2.c(XmlNode.of(_AIc, input[_Ac]).n(_Ac));
      }
      bn2.cc(input, _SC);
      if (input[_ACT] != null) {
        bn2.c(se_AccessControlTranslation(input[_ACT], context).n(_ACT));
      }
      if (input[_ECn] != null) {
        bn2.c(se_EncryptionConfiguration(input[_ECn], context).n(_ECn));
      }
      if (input[_RTe] != null) {
        bn2.c(se_ReplicationTime(input[_RTe], context).n(_RTe));
      }
      if (input[_Me] != null) {
        bn2.c(se_Metrics(input[_Me], context).n(_Me));
      }
      return bn2;
    };
    se_Encryption = (input, context) => {
      const bn2 = new XmlNode(_En);
      if (input[_ETn] != null) {
        bn2.c(XmlNode.of(_SSE, input[_ETn]).n(_ETn));
      }
      if (input[_KMSKI] != null) {
        bn2.c(XmlNode.of(_SSEKMSKI, input[_KMSKI]).n(_KMSKI));
      }
      bn2.cc(input, _KMSC);
      return bn2;
    };
    se_EncryptionConfiguration = (input, context) => {
      const bn2 = new XmlNode(_ECn);
      bn2.cc(input, _RKKID);
      return bn2;
    };
    se_ErrorDocument = (input, context) => {
      const bn2 = new XmlNode(_ED);
      if (input[_K] != null) {
        bn2.c(XmlNode.of(_OK, input[_K]).n(_K));
      }
      return bn2;
    };
    se_EventBridgeConfiguration = (input, context) => {
      const bn2 = new XmlNode(_EBC);
      return bn2;
    };
    se_EventList = (input, context) => {
      return input.filter((e2) => e2 != null).map((entry) => {
        const n2 = XmlNode.of(_Ev, entry);
        return n2.n(_me);
      });
    };
    se_ExistingObjectReplication = (input, context) => {
      const bn2 = new XmlNode(_EOR);
      if (input[_S] != null) {
        bn2.c(XmlNode.of(_EORS, input[_S]).n(_S));
      }
      return bn2;
    };
    se_ExposeHeaders = (input, context) => {
      return input.filter((e2) => e2 != null).map((entry) => {
        const n2 = XmlNode.of(_EHx, entry);
        return n2.n(_me);
      });
    };
    se_FilterRule = (input, context) => {
      const bn2 = new XmlNode(_FR);
      if (input[_N] != null) {
        bn2.c(XmlNode.of(_FRN, input[_N]).n(_N));
      }
      if (input[_Va] != null) {
        bn2.c(XmlNode.of(_FRV, input[_Va]).n(_Va));
      }
      return bn2;
    };
    se_FilterRuleList = (input, context) => {
      return input.filter((e2) => e2 != null).map((entry) => {
        const n2 = se_FilterRule(entry, context);
        return n2.n(_me);
      });
    };
    se_GlacierJobParameters = (input, context) => {
      const bn2 = new XmlNode(_GJP);
      bn2.cc(input, _Ti);
      return bn2;
    };
    se_Grant = (input, context) => {
      const bn2 = new XmlNode(_G);
      if (input[_Gra] != null) {
        const n2 = se_Grantee(input[_Gra], context).n(_Gra);
        n2.a("xmlns:xsi", "http://www.w3.org/2001/XMLSchema-instance");
        bn2.c(n2);
      }
      bn2.cc(input, _Pe);
      return bn2;
    };
    se_Grantee = (input, context) => {
      const bn2 = new XmlNode(_Gra);
      bn2.cc(input, _DN);
      bn2.cc(input, _EA);
      bn2.cc(input, _ID_);
      bn2.cc(input, _URI);
      bn2.a("xsi:type", input[_Ty]);
      return bn2;
    };
    se_Grants = (input, context) => {
      return input.filter((e2) => e2 != null).map((entry) => {
        const n2 = se_Grant(entry, context);
        return n2.n(_G);
      });
    };
    se_IndexDocument = (input, context) => {
      const bn2 = new XmlNode(_ID);
      bn2.cc(input, _Su);
      return bn2;
    };
    se_InputSerialization = (input, context) => {
      const bn2 = new XmlNode(_IS);
      if (input[_CSV] != null) {
        bn2.c(se_CSVInput(input[_CSV], context).n(_CSV));
      }
      bn2.cc(input, _CTom);
      if (input[_JSON] != null) {
        bn2.c(se_JSONInput(input[_JSON], context).n(_JSON));
      }
      if (input[_Parq] != null) {
        bn2.c(se_ParquetInput(input[_Parq], context).n(_Parq));
      }
      return bn2;
    };
    se_IntelligentTieringAndOperator = (input, context) => {
      const bn2 = new XmlNode(_ITAO);
      bn2.cc(input, _P);
      bn2.l(input, "Tags", "Tag", () => se_TagSet(input[_Tag], context));
      return bn2;
    };
    se_IntelligentTieringConfiguration = (input, context) => {
      const bn2 = new XmlNode(_ITC);
      if (input[_I] != null) {
        bn2.c(XmlNode.of(_ITI, input[_I]).n(_I));
      }
      if (input[_F] != null) {
        bn2.c(se_IntelligentTieringFilter(input[_F], context).n(_F));
      }
      if (input[_S] != null) {
        bn2.c(XmlNode.of(_ITS, input[_S]).n(_S));
      }
      bn2.l(input, "Tierings", "Tiering", () => se_TieringList(input[_Tie], context));
      return bn2;
    };
    se_IntelligentTieringFilter = (input, context) => {
      const bn2 = new XmlNode(_ITF);
      bn2.cc(input, _P);
      if (input[_Ta] != null) {
        bn2.c(se_Tag(input[_Ta], context).n(_Ta));
      }
      if (input[_A] != null) {
        bn2.c(se_IntelligentTieringAndOperator(input[_A], context).n(_A));
      }
      return bn2;
    };
    se_InventoryConfiguration = (input, context) => {
      const bn2 = new XmlNode(_IC);
      if (input[_Des] != null) {
        bn2.c(se_InventoryDestination(input[_Des], context).n(_Des));
      }
      if (input[_IE] != null) {
        bn2.c(XmlNode.of(_IE, String(input[_IE])).n(_IE));
      }
      if (input[_F] != null) {
        bn2.c(se_InventoryFilter(input[_F], context).n(_F));
      }
      if (input[_I] != null) {
        bn2.c(XmlNode.of(_II, input[_I]).n(_I));
      }
      if (input[_IOV] != null) {
        bn2.c(XmlNode.of(_IIOV, input[_IOV]).n(_IOV));
      }
      bn2.lc(input, "OptionalFields", "OptionalFields", () => se_InventoryOptionalFields(input[_OF], context));
      if (input[_Sc] != null) {
        bn2.c(se_InventorySchedule(input[_Sc], context).n(_Sc));
      }
      return bn2;
    };
    se_InventoryDestination = (input, context) => {
      const bn2 = new XmlNode(_IDn);
      if (input[_SBD] != null) {
        bn2.c(se_InventoryS3BucketDestination(input[_SBD], context).n(_SBD));
      }
      return bn2;
    };
    se_InventoryEncryption = (input, context) => {
      const bn2 = new XmlNode(_IEn);
      if (input[_SSES] != null) {
        bn2.c(se_SSES3(input[_SSES], context).n(_SS));
      }
      if (input[_SSEKMS] != null) {
        bn2.c(se_SSEKMS(input[_SSEKMS], context).n(_SK));
      }
      return bn2;
    };
    se_InventoryFilter = (input, context) => {
      const bn2 = new XmlNode(_IF);
      bn2.cc(input, _P);
      return bn2;
    };
    se_InventoryOptionalFields = (input, context) => {
      return input.filter((e2) => e2 != null).map((entry) => {
        const n2 = XmlNode.of(_IOF, entry);
        return n2.n(_Fi);
      });
    };
    se_InventoryS3BucketDestination = (input, context) => {
      const bn2 = new XmlNode(_ISBD);
      bn2.cc(input, _AIc);
      if (input[_B] != null) {
        bn2.c(XmlNode.of(_BN, input[_B]).n(_B));
      }
      if (input[_Fo] != null) {
        bn2.c(XmlNode.of(_IFn, input[_Fo]).n(_Fo));
      }
      bn2.cc(input, _P);
      if (input[_En] != null) {
        bn2.c(se_InventoryEncryption(input[_En], context).n(_En));
      }
      return bn2;
    };
    se_InventorySchedule = (input, context) => {
      const bn2 = new XmlNode(_ISn);
      if (input[_Fr] != null) {
        bn2.c(XmlNode.of(_IFnv, input[_Fr]).n(_Fr));
      }
      return bn2;
    };
    se_InventoryTableConfiguration = (input, context) => {
      const bn2 = new XmlNode(_ITCn);
      if (input[_CSo] != null) {
        bn2.c(XmlNode.of(_ICS, input[_CSo]).n(_CSo));
      }
      if (input[_ECn] != null) {
        bn2.c(se_MetadataTableEncryptionConfiguration(input[_ECn], context).n(_ECn));
      }
      return bn2;
    };
    se_InventoryTableConfigurationUpdates = (input, context) => {
      const bn2 = new XmlNode(_ITCU);
      if (input[_CSo] != null) {
        bn2.c(XmlNode.of(_ICS, input[_CSo]).n(_CSo));
      }
      if (input[_ECn] != null) {
        bn2.c(se_MetadataTableEncryptionConfiguration(input[_ECn], context).n(_ECn));
      }
      return bn2;
    };
    se_JournalTableConfiguration = (input, context) => {
      const bn2 = new XmlNode(_JTC);
      if (input[_REe] != null) {
        bn2.c(se_RecordExpiration(input[_REe], context).n(_REe));
      }
      if (input[_ECn] != null) {
        bn2.c(se_MetadataTableEncryptionConfiguration(input[_ECn], context).n(_ECn));
      }
      return bn2;
    };
    se_JournalTableConfigurationUpdates = (input, context) => {
      const bn2 = new XmlNode(_JTCU);
      if (input[_REe] != null) {
        bn2.c(se_RecordExpiration(input[_REe], context).n(_REe));
      }
      return bn2;
    };
    se_JSONInput = (input, context) => {
      const bn2 = new XmlNode(_JSONI);
      if (input[_Ty] != null) {
        bn2.c(XmlNode.of(_JSONT, input[_Ty]).n(_Ty));
      }
      return bn2;
    };
    se_JSONOutput = (input, context) => {
      const bn2 = new XmlNode(_JSONO);
      bn2.cc(input, _RD);
      return bn2;
    };
    se_LambdaFunctionConfiguration = (input, context) => {
      const bn2 = new XmlNode(_LFCa);
      if (input[_I] != null) {
        bn2.c(XmlNode.of(_NI, input[_I]).n(_I));
      }
      if (input[_LFA] != null) {
        bn2.c(XmlNode.of(_LFA, input[_LFA]).n(_CF));
      }
      bn2.l(input, "Events", "Event", () => se_EventList(input[_Eve], context));
      if (input[_F] != null) {
        bn2.c(se_NotificationConfigurationFilter(input[_F], context).n(_F));
      }
      return bn2;
    };
    se_LambdaFunctionConfigurationList = (input, context) => {
      return input.filter((e2) => e2 != null).map((entry) => {
        const n2 = se_LambdaFunctionConfiguration(entry, context);
        return n2.n(_me);
      });
    };
    se_LifecycleExpiration = (input, context) => {
      const bn2 = new XmlNode(_LEi);
      if (input[_Dat] != null) {
        bn2.c(XmlNode.of(_Dat, serializeDateTime(input[_Dat]).toString()).n(_Dat));
      }
      if (input[_Da] != null) {
        bn2.c(XmlNode.of(_Da, String(input[_Da])).n(_Da));
      }
      if (input[_EODM] != null) {
        bn2.c(XmlNode.of(_EODM, String(input[_EODM])).n(_EODM));
      }
      return bn2;
    };
    se_LifecycleRule = (input, context) => {
      const bn2 = new XmlNode(_LR);
      if (input[_Exp] != null) {
        bn2.c(se_LifecycleExpiration(input[_Exp], context).n(_Exp));
      }
      bn2.cc(input, _ID_);
      bn2.cc(input, _P);
      if (input[_F] != null) {
        bn2.c(se_LifecycleRuleFilter(input[_F], context).n(_F));
      }
      if (input[_S] != null) {
        bn2.c(XmlNode.of(_ESx, input[_S]).n(_S));
      }
      bn2.l(input, "Transitions", "Transition", () => se_TransitionList(input[_Tr], context));
      bn2.l(input, "NoncurrentVersionTransitions", "NoncurrentVersionTransition", () => se_NoncurrentVersionTransitionList(input[_NVT], context));
      if (input[_NVE] != null) {
        bn2.c(se_NoncurrentVersionExpiration(input[_NVE], context).n(_NVE));
      }
      if (input[_AIMU] != null) {
        bn2.c(se_AbortIncompleteMultipartUpload(input[_AIMU], context).n(_AIMU));
      }
      return bn2;
    };
    se_LifecycleRuleAndOperator = (input, context) => {
      const bn2 = new XmlNode(_LRAO);
      bn2.cc(input, _P);
      bn2.l(input, "Tags", "Tag", () => se_TagSet(input[_Tag], context));
      if (input[_OSGT] != null) {
        bn2.c(XmlNode.of(_OSGTB, String(input[_OSGT])).n(_OSGT));
      }
      if (input[_OSLT] != null) {
        bn2.c(XmlNode.of(_OSLTB, String(input[_OSLT])).n(_OSLT));
      }
      return bn2;
    };
    se_LifecycleRuleFilter = (input, context) => {
      const bn2 = new XmlNode(_LRF);
      bn2.cc(input, _P);
      if (input[_Ta] != null) {
        bn2.c(se_Tag(input[_Ta], context).n(_Ta));
      }
      if (input[_OSGT] != null) {
        bn2.c(XmlNode.of(_OSGTB, String(input[_OSGT])).n(_OSGT));
      }
      if (input[_OSLT] != null) {
        bn2.c(XmlNode.of(_OSLTB, String(input[_OSLT])).n(_OSLT));
      }
      if (input[_A] != null) {
        bn2.c(se_LifecycleRuleAndOperator(input[_A], context).n(_A));
      }
      return bn2;
    };
    se_LifecycleRules = (input, context) => {
      return input.filter((e2) => e2 != null).map((entry) => {
        const n2 = se_LifecycleRule(entry, context);
        return n2.n(_me);
      });
    };
    se_LocationInfo = (input, context) => {
      const bn2 = new XmlNode(_LI);
      if (input[_Ty] != null) {
        bn2.c(XmlNode.of(_LT, input[_Ty]).n(_Ty));
      }
      if (input[_N] != null) {
        bn2.c(XmlNode.of(_LNAS, input[_N]).n(_N));
      }
      return bn2;
    };
    se_LoggingEnabled = (input, context) => {
      const bn2 = new XmlNode(_LE);
      bn2.cc(input, _TB);
      bn2.lc(input, "TargetGrants", "TargetGrants", () => se_TargetGrants(input[_TG], context));
      bn2.cc(input, _TP);
      if (input[_TOKF] != null) {
        bn2.c(se_TargetObjectKeyFormat(input[_TOKF], context).n(_TOKF));
      }
      return bn2;
    };
    se_MetadataConfiguration = (input, context) => {
      const bn2 = new XmlNode(_MCe);
      if (input[_JTC] != null) {
        bn2.c(se_JournalTableConfiguration(input[_JTC], context).n(_JTC));
      }
      if (input[_ITCn] != null) {
        bn2.c(se_InventoryTableConfiguration(input[_ITCn], context).n(_ITCn));
      }
      return bn2;
    };
    se_MetadataEntry = (input, context) => {
      const bn2 = new XmlNode(_ME);
      if (input[_N] != null) {
        bn2.c(XmlNode.of(_MKe, input[_N]).n(_N));
      }
      if (input[_Va] != null) {
        bn2.c(XmlNode.of(_MV, input[_Va]).n(_Va));
      }
      return bn2;
    };
    se_MetadataTableConfiguration = (input, context) => {
      const bn2 = new XmlNode(_MTC);
      if (input[_STD] != null) {
        bn2.c(se_S3TablesDestination(input[_STD], context).n(_STD));
      }
      return bn2;
    };
    se_MetadataTableEncryptionConfiguration = (input, context) => {
      const bn2 = new XmlNode(_MTEC);
      if (input[_SAs] != null) {
        bn2.c(XmlNode.of(_TSA, input[_SAs]).n(_SAs));
      }
      bn2.cc(input, _KKA);
      return bn2;
    };
    se_Metrics = (input, context) => {
      const bn2 = new XmlNode(_Me);
      if (input[_S] != null) {
        bn2.c(XmlNode.of(_MS, input[_S]).n(_S));
      }
      if (input[_ETv] != null) {
        bn2.c(se_ReplicationTimeValue(input[_ETv], context).n(_ETv));
      }
      return bn2;
    };
    se_MetricsAndOperator = (input, context) => {
      const bn2 = new XmlNode(_MAO);
      bn2.cc(input, _P);
      bn2.l(input, "Tags", "Tag", () => se_TagSet(input[_Tag], context));
      bn2.cc(input, _APAc);
      return bn2;
    };
    se_MetricsConfiguration = (input, context) => {
      const bn2 = new XmlNode(_MC);
      if (input[_I] != null) {
        bn2.c(XmlNode.of(_MI, input[_I]).n(_I));
      }
      if (input[_F] != null) {
        bn2.c(se_MetricsFilter(input[_F], context).n(_F));
      }
      return bn2;
    };
    se_MetricsFilter = (input, context) => {
      const bn2 = new XmlNode(_MF);
      MetricsFilter.visit(input, {
        Prefix: (value) => {
          if (input[_P] != null) {
            bn2.c(XmlNode.of(_P, value).n(_P));
          }
        },
        Tag: (value) => {
          if (input[_Ta] != null) {
            bn2.c(se_Tag(value, context).n(_Ta));
          }
        },
        AccessPointArn: (value) => {
          if (input[_APAc] != null) {
            bn2.c(XmlNode.of(_APAc, value).n(_APAc));
          }
        },
        And: (value) => {
          if (input[_A] != null) {
            bn2.c(se_MetricsAndOperator(value, context).n(_A));
          }
        },
        _: (name, value) => {
          if (!(value instanceof XmlNode || value instanceof XmlText)) {
            throw new Error("Unable to serialize unknown union members in XML.");
          }
          bn2.c(new XmlNode(name).c(value));
        }
      });
      return bn2;
    };
    se_NoncurrentVersionExpiration = (input, context) => {
      const bn2 = new XmlNode(_NVE);
      if (input[_ND] != null) {
        bn2.c(XmlNode.of(_Da, String(input[_ND])).n(_ND));
      }
      if (input[_NNV] != null) {
        bn2.c(XmlNode.of(_VC, String(input[_NNV])).n(_NNV));
      }
      return bn2;
    };
    se_NoncurrentVersionTransition = (input, context) => {
      const bn2 = new XmlNode(_NVTo);
      if (input[_ND] != null) {
        bn2.c(XmlNode.of(_Da, String(input[_ND])).n(_ND));
      }
      if (input[_SC] != null) {
        bn2.c(XmlNode.of(_TSC, input[_SC]).n(_SC));
      }
      if (input[_NNV] != null) {
        bn2.c(XmlNode.of(_VC, String(input[_NNV])).n(_NNV));
      }
      return bn2;
    };
    se_NoncurrentVersionTransitionList = (input, context) => {
      return input.filter((e2) => e2 != null).map((entry) => {
        const n2 = se_NoncurrentVersionTransition(entry, context);
        return n2.n(_me);
      });
    };
    se_NotificationConfiguration = (input, context) => {
      const bn2 = new XmlNode(_NC);
      bn2.l(input, "TopicConfigurations", "TopicConfiguration", () => se_TopicConfigurationList(input[_TCop], context));
      bn2.l(input, "QueueConfigurations", "QueueConfiguration", () => se_QueueConfigurationList(input[_QCu], context));
      bn2.l(input, "LambdaFunctionConfigurations", "CloudFunctionConfiguration", () => se_LambdaFunctionConfigurationList(input[_LFC], context));
      if (input[_EBC] != null) {
        bn2.c(se_EventBridgeConfiguration(input[_EBC], context).n(_EBC));
      }
      return bn2;
    };
    se_NotificationConfigurationFilter = (input, context) => {
      const bn2 = new XmlNode(_NCF);
      if (input[_K] != null) {
        bn2.c(se_S3KeyFilter(input[_K], context).n(_SKe));
      }
      return bn2;
    };
    se_ObjectIdentifier = (input, context) => {
      const bn2 = new XmlNode(_OI);
      if (input[_K] != null) {
        bn2.c(XmlNode.of(_OK, input[_K]).n(_K));
      }
      if (input[_VI] != null) {
        bn2.c(XmlNode.of(_OVI, input[_VI]).n(_VI));
      }
      bn2.cc(input, _ETa);
      if (input[_LMT] != null) {
        bn2.c(XmlNode.of(_LMT, dateToUtcString(input[_LMT]).toString()).n(_LMT));
      }
      if (input[_Si] != null) {
        bn2.c(XmlNode.of(_Si, String(input[_Si])).n(_Si));
      }
      return bn2;
    };
    se_ObjectIdentifierList = (input, context) => {
      return input.filter((e2) => e2 != null).map((entry) => {
        const n2 = se_ObjectIdentifier(entry, context);
        return n2.n(_me);
      });
    };
    se_ObjectLockConfiguration = (input, context) => {
      const bn2 = new XmlNode(_OLC);
      bn2.cc(input, _OLE);
      if (input[_Ru] != null) {
        bn2.c(se_ObjectLockRule(input[_Ru], context).n(_Ru));
      }
      return bn2;
    };
    se_ObjectLockLegalHold = (input, context) => {
      const bn2 = new XmlNode(_OLLH);
      if (input[_S] != null) {
        bn2.c(XmlNode.of(_OLLHS, input[_S]).n(_S));
      }
      return bn2;
    };
    se_ObjectLockRetention = (input, context) => {
      const bn2 = new XmlNode(_OLR);
      if (input[_Mo] != null) {
        bn2.c(XmlNode.of(_OLRM, input[_Mo]).n(_Mo));
      }
      if (input[_RUD] != null) {
        bn2.c(XmlNode.of(_Dat, serializeDateTime(input[_RUD]).toString()).n(_RUD));
      }
      return bn2;
    };
    se_ObjectLockRule = (input, context) => {
      const bn2 = new XmlNode(_OLRb);
      if (input[_DRe] != null) {
        bn2.c(se_DefaultRetention(input[_DRe], context).n(_DRe));
      }
      return bn2;
    };
    se_OutputLocation = (input, context) => {
      const bn2 = new XmlNode(_OL);
      if (input[_S_] != null) {
        bn2.c(se_S3Location(input[_S_], context).n(_S_));
      }
      return bn2;
    };
    se_OutputSerialization = (input, context) => {
      const bn2 = new XmlNode(_OS);
      if (input[_CSV] != null) {
        bn2.c(se_CSVOutput(input[_CSV], context).n(_CSV));
      }
      if (input[_JSON] != null) {
        bn2.c(se_JSONOutput(input[_JSON], context).n(_JSON));
      }
      return bn2;
    };
    se_Owner = (input, context) => {
      const bn2 = new XmlNode(_O);
      bn2.cc(input, _DN);
      bn2.cc(input, _ID_);
      return bn2;
    };
    se_OwnershipControls = (input, context) => {
      const bn2 = new XmlNode(_OC);
      bn2.l(input, "Rules", "Rule", () => se_OwnershipControlsRules(input[_Rul], context));
      return bn2;
    };
    se_OwnershipControlsRule = (input, context) => {
      const bn2 = new XmlNode(_OCR);
      bn2.cc(input, _OO);
      return bn2;
    };
    se_OwnershipControlsRules = (input, context) => {
      return input.filter((e2) => e2 != null).map((entry) => {
        const n2 = se_OwnershipControlsRule(entry, context);
        return n2.n(_me);
      });
    };
    se_ParquetInput = (input, context) => {
      const bn2 = new XmlNode(_PI);
      return bn2;
    };
    se_PartitionedPrefix = (input, context) => {
      const bn2 = new XmlNode(_PP);
      bn2.cc(input, _PDS);
      return bn2;
    };
    se_PublicAccessBlockConfiguration = (input, context) => {
      const bn2 = new XmlNode(_PABC);
      if (input[_BPA] != null) {
        bn2.c(XmlNode.of(_Se, String(input[_BPA])).n(_BPA));
      }
      if (input[_IPA] != null) {
        bn2.c(XmlNode.of(_Se, String(input[_IPA])).n(_IPA));
      }
      if (input[_BPP] != null) {
        bn2.c(XmlNode.of(_Se, String(input[_BPP])).n(_BPP));
      }
      if (input[_RPB] != null) {
        bn2.c(XmlNode.of(_Se, String(input[_RPB])).n(_RPB));
      }
      return bn2;
    };
    se_QueueConfiguration = (input, context) => {
      const bn2 = new XmlNode(_QC);
      if (input[_I] != null) {
        bn2.c(XmlNode.of(_NI, input[_I]).n(_I));
      }
      if (input[_QA] != null) {
        bn2.c(XmlNode.of(_QA, input[_QA]).n(_Qu));
      }
      bn2.l(input, "Events", "Event", () => se_EventList(input[_Eve], context));
      if (input[_F] != null) {
        bn2.c(se_NotificationConfigurationFilter(input[_F], context).n(_F));
      }
      return bn2;
    };
    se_QueueConfigurationList = (input, context) => {
      return input.filter((e2) => e2 != null).map((entry) => {
        const n2 = se_QueueConfiguration(entry, context);
        return n2.n(_me);
      });
    };
    se_RecordExpiration = (input, context) => {
      const bn2 = new XmlNode(_REe);
      if (input[_Exp] != null) {
        bn2.c(XmlNode.of(_ESxp, input[_Exp]).n(_Exp));
      }
      if (input[_Da] != null) {
        bn2.c(XmlNode.of(_RED, String(input[_Da])).n(_Da));
      }
      return bn2;
    };
    se_Redirect = (input, context) => {
      const bn2 = new XmlNode(_Red);
      bn2.cc(input, _HN);
      bn2.cc(input, _HRC);
      bn2.cc(input, _Pr);
      bn2.cc(input, _RKPW);
      bn2.cc(input, _RKW);
      return bn2;
    };
    se_RedirectAllRequestsTo = (input, context) => {
      const bn2 = new XmlNode(_RART);
      bn2.cc(input, _HN);
      bn2.cc(input, _Pr);
      return bn2;
    };
    se_ReplicaModifications = (input, context) => {
      const bn2 = new XmlNode(_RM);
      if (input[_S] != null) {
        bn2.c(XmlNode.of(_RMS, input[_S]).n(_S));
      }
      return bn2;
    };
    se_ReplicationConfiguration = (input, context) => {
      const bn2 = new XmlNode(_RCe);
      bn2.cc(input, _Ro);
      bn2.l(input, "Rules", "Rule", () => se_ReplicationRules(input[_Rul], context));
      return bn2;
    };
    se_ReplicationRule = (input, context) => {
      const bn2 = new XmlNode(_RRe);
      bn2.cc(input, _ID_);
      if (input[_Pri] != null) {
        bn2.c(XmlNode.of(_Pri, String(input[_Pri])).n(_Pri));
      }
      bn2.cc(input, _P);
      if (input[_F] != null) {
        bn2.c(se_ReplicationRuleFilter(input[_F], context).n(_F));
      }
      if (input[_S] != null) {
        bn2.c(XmlNode.of(_RRS, input[_S]).n(_S));
      }
      if (input[_SSC] != null) {
        bn2.c(se_SourceSelectionCriteria(input[_SSC], context).n(_SSC));
      }
      if (input[_EOR] != null) {
        bn2.c(se_ExistingObjectReplication(input[_EOR], context).n(_EOR));
      }
      if (input[_Des] != null) {
        bn2.c(se_Destination(input[_Des], context).n(_Des));
      }
      if (input[_DMR] != null) {
        bn2.c(se_DeleteMarkerReplication(input[_DMR], context).n(_DMR));
      }
      return bn2;
    };
    se_ReplicationRuleAndOperator = (input, context) => {
      const bn2 = new XmlNode(_RRAO);
      bn2.cc(input, _P);
      bn2.l(input, "Tags", "Tag", () => se_TagSet(input[_Tag], context));
      return bn2;
    };
    se_ReplicationRuleFilter = (input, context) => {
      const bn2 = new XmlNode(_RRF);
      bn2.cc(input, _P);
      if (input[_Ta] != null) {
        bn2.c(se_Tag(input[_Ta], context).n(_Ta));
      }
      if (input[_A] != null) {
        bn2.c(se_ReplicationRuleAndOperator(input[_A], context).n(_A));
      }
      return bn2;
    };
    se_ReplicationRules = (input, context) => {
      return input.filter((e2) => e2 != null).map((entry) => {
        const n2 = se_ReplicationRule(entry, context);
        return n2.n(_me);
      });
    };
    se_ReplicationTime = (input, context) => {
      const bn2 = new XmlNode(_RTe);
      if (input[_S] != null) {
        bn2.c(XmlNode.of(_RTS, input[_S]).n(_S));
      }
      if (input[_Tim] != null) {
        bn2.c(se_ReplicationTimeValue(input[_Tim], context).n(_Tim));
      }
      return bn2;
    };
    se_ReplicationTimeValue = (input, context) => {
      const bn2 = new XmlNode(_RTV);
      if (input[_Mi] != null) {
        bn2.c(XmlNode.of(_Mi, String(input[_Mi])).n(_Mi));
      }
      return bn2;
    };
    se_RequestPaymentConfiguration = (input, context) => {
      const bn2 = new XmlNode(_RPC);
      bn2.cc(input, _Pa);
      return bn2;
    };
    se_RequestProgress = (input, context) => {
      const bn2 = new XmlNode(_RPe);
      if (input[_Ena] != null) {
        bn2.c(XmlNode.of(_ERP, String(input[_Ena])).n(_Ena));
      }
      return bn2;
    };
    se_RestoreRequest = (input, context) => {
      const bn2 = new XmlNode(_RRes);
      if (input[_Da] != null) {
        bn2.c(XmlNode.of(_Da, String(input[_Da])).n(_Da));
      }
      if (input[_GJP] != null) {
        bn2.c(se_GlacierJobParameters(input[_GJP], context).n(_GJP));
      }
      if (input[_Ty] != null) {
        bn2.c(XmlNode.of(_RRT, input[_Ty]).n(_Ty));
      }
      bn2.cc(input, _Ti);
      bn2.cc(input, _Desc);
      if (input[_SP] != null) {
        bn2.c(se_SelectParameters(input[_SP], context).n(_SP));
      }
      if (input[_OL] != null) {
        bn2.c(se_OutputLocation(input[_OL], context).n(_OL));
      }
      return bn2;
    };
    se_RoutingRule = (input, context) => {
      const bn2 = new XmlNode(_RRou);
      if (input[_Con] != null) {
        bn2.c(se_Condition(input[_Con], context).n(_Con));
      }
      if (input[_Red] != null) {
        bn2.c(se_Redirect(input[_Red], context).n(_Red));
      }
      return bn2;
    };
    se_RoutingRules = (input, context) => {
      return input.filter((e2) => e2 != null).map((entry) => {
        const n2 = se_RoutingRule(entry, context);
        return n2.n(_RRou);
      });
    };
    se_S3KeyFilter = (input, context) => {
      const bn2 = new XmlNode(_SKF);
      bn2.l(input, "FilterRules", "FilterRule", () => se_FilterRuleList(input[_FRi], context));
      return bn2;
    };
    se_S3Location = (input, context) => {
      const bn2 = new XmlNode(_SL);
      bn2.cc(input, _BN);
      if (input[_P] != null) {
        bn2.c(XmlNode.of(_LP, input[_P]).n(_P));
      }
      if (input[_En] != null) {
        bn2.c(se_Encryption(input[_En], context).n(_En));
      }
      if (input[_CACL] != null) {
        bn2.c(XmlNode.of(_OCACL, input[_CACL]).n(_CACL));
      }
      bn2.lc(input, "AccessControlList", "AccessControlList", () => se_Grants(input[_ACLc], context));
      if (input[_T] != null) {
        bn2.c(se_Tagging(input[_T], context).n(_T));
      }
      bn2.lc(input, "UserMetadata", "UserMetadata", () => se_UserMetadata(input[_UM], context));
      bn2.cc(input, _SC);
      return bn2;
    };
    se_S3TablesDestination = (input, context) => {
      const bn2 = new XmlNode(_STD);
      if (input[_TBA] != null) {
        bn2.c(XmlNode.of(_STBA, input[_TBA]).n(_TBA));
      }
      if (input[_TN] != null) {
        bn2.c(XmlNode.of(_STN, input[_TN]).n(_TN));
      }
      return bn2;
    };
    se_ScanRange = (input, context) => {
      const bn2 = new XmlNode(_SR);
      if (input[_St] != null) {
        bn2.c(XmlNode.of(_St, String(input[_St])).n(_St));
      }
      if (input[_End] != null) {
        bn2.c(XmlNode.of(_End, String(input[_End])).n(_End));
      }
      return bn2;
    };
    se_SelectParameters = (input, context) => {
      const bn2 = new XmlNode(_SP);
      if (input[_IS] != null) {
        bn2.c(se_InputSerialization(input[_IS], context).n(_IS));
      }
      bn2.cc(input, _ETx);
      bn2.cc(input, _Ex);
      if (input[_OS] != null) {
        bn2.c(se_OutputSerialization(input[_OS], context).n(_OS));
      }
      return bn2;
    };
    se_ServerSideEncryptionByDefault = (input, context) => {
      const bn2 = new XmlNode(_SSEBD);
      if (input[_SSEA] != null) {
        bn2.c(XmlNode.of(_SSE, input[_SSEA]).n(_SSEA));
      }
      if (input[_KMSMKID] != null) {
        bn2.c(XmlNode.of(_SSEKMSKI, input[_KMSMKID]).n(_KMSMKID));
      }
      return bn2;
    };
    se_ServerSideEncryptionConfiguration = (input, context) => {
      const bn2 = new XmlNode(_SSEC);
      bn2.l(input, "Rules", "Rule", () => se_ServerSideEncryptionRules(input[_Rul], context));
      return bn2;
    };
    se_ServerSideEncryptionRule = (input, context) => {
      const bn2 = new XmlNode(_SSER);
      if (input[_ASSEBD] != null) {
        bn2.c(se_ServerSideEncryptionByDefault(input[_ASSEBD], context).n(_ASSEBD));
      }
      if (input[_BKE] != null) {
        bn2.c(XmlNode.of(_BKE, String(input[_BKE])).n(_BKE));
      }
      return bn2;
    };
    se_ServerSideEncryptionRules = (input, context) => {
      return input.filter((e2) => e2 != null).map((entry) => {
        const n2 = se_ServerSideEncryptionRule(entry, context);
        return n2.n(_me);
      });
    };
    se_SimplePrefix = (input, context) => {
      const bn2 = new XmlNode(_SPi);
      return bn2;
    };
    se_SourceSelectionCriteria = (input, context) => {
      const bn2 = new XmlNode(_SSC);
      if (input[_SKEO] != null) {
        bn2.c(se_SseKmsEncryptedObjects(input[_SKEO], context).n(_SKEO));
      }
      if (input[_RM] != null) {
        bn2.c(se_ReplicaModifications(input[_RM], context).n(_RM));
      }
      return bn2;
    };
    se_SSEKMS = (input, context) => {
      const bn2 = new XmlNode(_SK);
      if (input[_KI] != null) {
        bn2.c(XmlNode.of(_SSEKMSKI, input[_KI]).n(_KI));
      }
      return bn2;
    };
    se_SseKmsEncryptedObjects = (input, context) => {
      const bn2 = new XmlNode(_SKEO);
      if (input[_S] != null) {
        bn2.c(XmlNode.of(_SKEOS, input[_S]).n(_S));
      }
      return bn2;
    };
    se_SSES3 = (input, context) => {
      const bn2 = new XmlNode(_SS);
      return bn2;
    };
    se_StorageClassAnalysis = (input, context) => {
      const bn2 = new XmlNode(_SCA);
      if (input[_DE] != null) {
        bn2.c(se_StorageClassAnalysisDataExport(input[_DE], context).n(_DE));
      }
      return bn2;
    };
    se_StorageClassAnalysisDataExport = (input, context) => {
      const bn2 = new XmlNode(_SCADE);
      if (input[_OSV] != null) {
        bn2.c(XmlNode.of(_SCASV, input[_OSV]).n(_OSV));
      }
      if (input[_Des] != null) {
        bn2.c(se_AnalyticsExportDestination(input[_Des], context).n(_Des));
      }
      return bn2;
    };
    se_Tag = (input, context) => {
      const bn2 = new XmlNode(_Ta);
      if (input[_K] != null) {
        bn2.c(XmlNode.of(_OK, input[_K]).n(_K));
      }
      bn2.cc(input, _Va);
      return bn2;
    };
    se_Tagging = (input, context) => {
      const bn2 = new XmlNode(_T);
      bn2.lc(input, "TagSet", "TagSet", () => se_TagSet(input[_TS], context));
      return bn2;
    };
    se_TagSet = (input, context) => {
      return input.filter((e2) => e2 != null).map((entry) => {
        const n2 = se_Tag(entry, context);
        return n2.n(_Ta);
      });
    };
    se_TargetGrant = (input, context) => {
      const bn2 = new XmlNode(_TGa);
      if (input[_Gra] != null) {
        const n2 = se_Grantee(input[_Gra], context).n(_Gra);
        n2.a("xmlns:xsi", "http://www.w3.org/2001/XMLSchema-instance");
        bn2.c(n2);
      }
      if (input[_Pe] != null) {
        bn2.c(XmlNode.of(_BLP, input[_Pe]).n(_Pe));
      }
      return bn2;
    };
    se_TargetGrants = (input, context) => {
      return input.filter((e2) => e2 != null).map((entry) => {
        const n2 = se_TargetGrant(entry, context);
        return n2.n(_G);
      });
    };
    se_TargetObjectKeyFormat = (input, context) => {
      const bn2 = new XmlNode(_TOKF);
      if (input[_SPi] != null) {
        bn2.c(se_SimplePrefix(input[_SPi], context).n(_SPi));
      }
      if (input[_PP] != null) {
        bn2.c(se_PartitionedPrefix(input[_PP], context).n(_PP));
      }
      return bn2;
    };
    se_Tiering = (input, context) => {
      const bn2 = new XmlNode(_Tier);
      if (input[_Da] != null) {
        bn2.c(XmlNode.of(_ITD, String(input[_Da])).n(_Da));
      }
      if (input[_AT] != null) {
        bn2.c(XmlNode.of(_ITAT, input[_AT]).n(_AT));
      }
      return bn2;
    };
    se_TieringList = (input, context) => {
      return input.filter((e2) => e2 != null).map((entry) => {
        const n2 = se_Tiering(entry, context);
        return n2.n(_me);
      });
    };
    se_TopicConfiguration = (input, context) => {
      const bn2 = new XmlNode(_TCo);
      if (input[_I] != null) {
        bn2.c(XmlNode.of(_NI, input[_I]).n(_I));
      }
      if (input[_TA] != null) {
        bn2.c(XmlNode.of(_TA, input[_TA]).n(_Top));
      }
      bn2.l(input, "Events", "Event", () => se_EventList(input[_Eve], context));
      if (input[_F] != null) {
        bn2.c(se_NotificationConfigurationFilter(input[_F], context).n(_F));
      }
      return bn2;
    };
    se_TopicConfigurationList = (input, context) => {
      return input.filter((e2) => e2 != null).map((entry) => {
        const n2 = se_TopicConfiguration(entry, context);
        return n2.n(_me);
      });
    };
    se_Transition = (input, context) => {
      const bn2 = new XmlNode(_Tra);
      if (input[_Dat] != null) {
        bn2.c(XmlNode.of(_Dat, serializeDateTime(input[_Dat]).toString()).n(_Dat));
      }
      if (input[_Da] != null) {
        bn2.c(XmlNode.of(_Da, String(input[_Da])).n(_Da));
      }
      if (input[_SC] != null) {
        bn2.c(XmlNode.of(_TSC, input[_SC]).n(_SC));
      }
      return bn2;
    };
    se_TransitionList = (input, context) => {
      return input.filter((e2) => e2 != null).map((entry) => {
        const n2 = se_Transition(entry, context);
        return n2.n(_me);
      });
    };
    se_UserMetadata = (input, context) => {
      return input.filter((e2) => e2 != null).map((entry) => {
        const n2 = se_MetadataEntry(entry, context);
        return n2.n(_ME);
      });
    };
    se_VersioningConfiguration = (input, context) => {
      const bn2 = new XmlNode(_VCe);
      if (input[_MFAD] != null) {
        bn2.c(XmlNode.of(_MFAD, input[_MFAD]).n(_MDf));
      }
      if (input[_S] != null) {
        bn2.c(XmlNode.of(_BVS, input[_S]).n(_S));
      }
      return bn2;
    };
    se_WebsiteConfiguration = (input, context) => {
      const bn2 = new XmlNode(_WC);
      if (input[_ED] != null) {
        bn2.c(se_ErrorDocument(input[_ED], context).n(_ED));
      }
      if (input[_ID] != null) {
        bn2.c(se_IndexDocument(input[_ID], context).n(_ID));
      }
      if (input[_RART] != null) {
        bn2.c(se_RedirectAllRequestsTo(input[_RART], context).n(_RART));
      }
      bn2.lc(input, "RoutingRules", "RoutingRules", () => se_RoutingRules(input[_RRo], context));
      return bn2;
    };
    de_AbortIncompleteMultipartUpload = (output, context) => {
      const contents = {};
      if (output[_DAI] != null) {
        contents[_DAI] = strictParseInt32(output[_DAI]);
      }
      return contents;
    };
    de_AccessControlTranslation = (output, context) => {
      const contents = {};
      if (output[_O] != null) {
        contents[_O] = expectString(output[_O]);
      }
      return contents;
    };
    de_AllowedHeaders = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return expectString(entry);
      });
    };
    de_AllowedMethods = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return expectString(entry);
      });
    };
    de_AllowedOrigins = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return expectString(entry);
      });
    };
    de_AnalyticsAndOperator = (output, context) => {
      const contents = {};
      if (output[_P] != null) {
        contents[_P] = expectString(output[_P]);
      }
      if (String(output.Tag).trim() === "") {
        contents[_Tag] = [];
      } else if (output[_Ta] != null) {
        contents[_Tag] = de_TagSet(getArrayIfSingleItem(output[_Ta]), context);
      }
      return contents;
    };
    de_AnalyticsConfiguration = (output, context) => {
      const contents = {};
      if (output[_I] != null) {
        contents[_I] = expectString(output[_I]);
      }
      if (String(output.Filter).trim() === "") {
      } else if (output[_F] != null) {
        contents[_F] = de_AnalyticsFilter(expectUnion(output[_F]), context);
      }
      if (output[_SCA] != null) {
        contents[_SCA] = de_StorageClassAnalysis(output[_SCA], context);
      }
      return contents;
    };
    de_AnalyticsConfigurationList = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de_AnalyticsConfiguration(entry, context);
      });
    };
    de_AnalyticsExportDestination = (output, context) => {
      const contents = {};
      if (output[_SBD] != null) {
        contents[_SBD] = de_AnalyticsS3BucketDestination(output[_SBD], context);
      }
      return contents;
    };
    de_AnalyticsFilter = (output, context) => {
      if (output[_P] != null) {
        return {
          Prefix: expectString(output[_P])
        };
      }
      if (output[_Ta] != null) {
        return {
          Tag: de_Tag(output[_Ta], context)
        };
      }
      if (output[_A] != null) {
        return {
          And: de_AnalyticsAndOperator(output[_A], context)
        };
      }
      return { $unknown: Object.entries(output)[0] };
    };
    de_AnalyticsS3BucketDestination = (output, context) => {
      const contents = {};
      if (output[_Fo] != null) {
        contents[_Fo] = expectString(output[_Fo]);
      }
      if (output[_BAI] != null) {
        contents[_BAI] = expectString(output[_BAI]);
      }
      if (output[_B] != null) {
        contents[_B] = expectString(output[_B]);
      }
      if (output[_P] != null) {
        contents[_P] = expectString(output[_P]);
      }
      return contents;
    };
    de_Bucket = (output, context) => {
      const contents = {};
      if (output[_N] != null) {
        contents[_N] = expectString(output[_N]);
      }
      if (output[_CDr] != null) {
        contents[_CDr] = expectNonNull(parseRfc3339DateTimeWithOffset(output[_CDr]));
      }
      if (output[_BR] != null) {
        contents[_BR] = expectString(output[_BR]);
      }
      if (output[_BA] != null) {
        contents[_BA] = expectString(output[_BA]);
      }
      return contents;
    };
    de_Buckets = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de_Bucket(entry, context);
      });
    };
    de_Checksum = (output, context) => {
      const contents = {};
      if (output[_CCRC] != null) {
        contents[_CCRC] = expectString(output[_CCRC]);
      }
      if (output[_CCRCC] != null) {
        contents[_CCRCC] = expectString(output[_CCRCC]);
      }
      if (output[_CCRCNVME] != null) {
        contents[_CCRCNVME] = expectString(output[_CCRCNVME]);
      }
      if (output[_CSHA] != null) {
        contents[_CSHA] = expectString(output[_CSHA]);
      }
      if (output[_CSHAh] != null) {
        contents[_CSHAh] = expectString(output[_CSHAh]);
      }
      if (output[_CT] != null) {
        contents[_CT] = expectString(output[_CT]);
      }
      return contents;
    };
    de_ChecksumAlgorithmList = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return expectString(entry);
      });
    };
    de_CommonPrefix = (output, context) => {
      const contents = {};
      if (output[_P] != null) {
        contents[_P] = expectString(output[_P]);
      }
      return contents;
    };
    de_CommonPrefixList = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de_CommonPrefix(entry, context);
      });
    };
    de_Condition = (output, context) => {
      const contents = {};
      if (output[_HECRE] != null) {
        contents[_HECRE] = expectString(output[_HECRE]);
      }
      if (output[_KPE] != null) {
        contents[_KPE] = expectString(output[_KPE]);
      }
      return contents;
    };
    de_ContinuationEvent = (output, context) => {
      const contents = {};
      return contents;
    };
    de_CopyObjectResult = (output, context) => {
      const contents = {};
      if (output[_ETa] != null) {
        contents[_ETa] = expectString(output[_ETa]);
      }
      if (output[_LM] != null) {
        contents[_LM] = expectNonNull(parseRfc3339DateTimeWithOffset(output[_LM]));
      }
      if (output[_CT] != null) {
        contents[_CT] = expectString(output[_CT]);
      }
      if (output[_CCRC] != null) {
        contents[_CCRC] = expectString(output[_CCRC]);
      }
      if (output[_CCRCC] != null) {
        contents[_CCRCC] = expectString(output[_CCRCC]);
      }
      if (output[_CCRCNVME] != null) {
        contents[_CCRCNVME] = expectString(output[_CCRCNVME]);
      }
      if (output[_CSHA] != null) {
        contents[_CSHA] = expectString(output[_CSHA]);
      }
      if (output[_CSHAh] != null) {
        contents[_CSHAh] = expectString(output[_CSHAh]);
      }
      return contents;
    };
    de_CopyPartResult = (output, context) => {
      const contents = {};
      if (output[_ETa] != null) {
        contents[_ETa] = expectString(output[_ETa]);
      }
      if (output[_LM] != null) {
        contents[_LM] = expectNonNull(parseRfc3339DateTimeWithOffset(output[_LM]));
      }
      if (output[_CCRC] != null) {
        contents[_CCRC] = expectString(output[_CCRC]);
      }
      if (output[_CCRCC] != null) {
        contents[_CCRCC] = expectString(output[_CCRCC]);
      }
      if (output[_CCRCNVME] != null) {
        contents[_CCRCNVME] = expectString(output[_CCRCNVME]);
      }
      if (output[_CSHA] != null) {
        contents[_CSHA] = expectString(output[_CSHA]);
      }
      if (output[_CSHAh] != null) {
        contents[_CSHAh] = expectString(output[_CSHAh]);
      }
      return contents;
    };
    de_CORSRule = (output, context) => {
      const contents = {};
      if (output[_ID_] != null) {
        contents[_ID_] = expectString(output[_ID_]);
      }
      if (String(output.AllowedHeader).trim() === "") {
        contents[_AHl] = [];
      } else if (output[_AH] != null) {
        contents[_AHl] = de_AllowedHeaders(getArrayIfSingleItem(output[_AH]), context);
      }
      if (String(output.AllowedMethod).trim() === "") {
        contents[_AMl] = [];
      } else if (output[_AM] != null) {
        contents[_AMl] = de_AllowedMethods(getArrayIfSingleItem(output[_AM]), context);
      }
      if (String(output.AllowedOrigin).trim() === "") {
        contents[_AOl] = [];
      } else if (output[_AO] != null) {
        contents[_AOl] = de_AllowedOrigins(getArrayIfSingleItem(output[_AO]), context);
      }
      if (String(output.ExposeHeader).trim() === "") {
        contents[_EH] = [];
      } else if (output[_EHx] != null) {
        contents[_EH] = de_ExposeHeaders(getArrayIfSingleItem(output[_EHx]), context);
      }
      if (output[_MAS] != null) {
        contents[_MAS] = strictParseInt32(output[_MAS]);
      }
      return contents;
    };
    de_CORSRules = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de_CORSRule(entry, context);
      });
    };
    de_DefaultRetention = (output, context) => {
      const contents = {};
      if (output[_Mo] != null) {
        contents[_Mo] = expectString(output[_Mo]);
      }
      if (output[_Da] != null) {
        contents[_Da] = strictParseInt32(output[_Da]);
      }
      if (output[_Y] != null) {
        contents[_Y] = strictParseInt32(output[_Y]);
      }
      return contents;
    };
    de_DeletedObject = (output, context) => {
      const contents = {};
      if (output[_K] != null) {
        contents[_K] = expectString(output[_K]);
      }
      if (output[_VI] != null) {
        contents[_VI] = expectString(output[_VI]);
      }
      if (output[_DM] != null) {
        contents[_DM] = parseBoolean(output[_DM]);
      }
      if (output[_DMVI] != null) {
        contents[_DMVI] = expectString(output[_DMVI]);
      }
      return contents;
    };
    de_DeletedObjects = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de_DeletedObject(entry, context);
      });
    };
    de_DeleteMarkerEntry = (output, context) => {
      const contents = {};
      if (output[_O] != null) {
        contents[_O] = de_Owner(output[_O], context);
      }
      if (output[_K] != null) {
        contents[_K] = expectString(output[_K]);
      }
      if (output[_VI] != null) {
        contents[_VI] = expectString(output[_VI]);
      }
      if (output[_IL] != null) {
        contents[_IL] = parseBoolean(output[_IL]);
      }
      if (output[_LM] != null) {
        contents[_LM] = expectNonNull(parseRfc3339DateTimeWithOffset(output[_LM]));
      }
      return contents;
    };
    de_DeleteMarkerReplication = (output, context) => {
      const contents = {};
      if (output[_S] != null) {
        contents[_S] = expectString(output[_S]);
      }
      return contents;
    };
    de_DeleteMarkers = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de_DeleteMarkerEntry(entry, context);
      });
    };
    de_Destination = (output, context) => {
      const contents = {};
      if (output[_B] != null) {
        contents[_B] = expectString(output[_B]);
      }
      if (output[_Ac] != null) {
        contents[_Ac] = expectString(output[_Ac]);
      }
      if (output[_SC] != null) {
        contents[_SC] = expectString(output[_SC]);
      }
      if (output[_ACT] != null) {
        contents[_ACT] = de_AccessControlTranslation(output[_ACT], context);
      }
      if (output[_ECn] != null) {
        contents[_ECn] = de_EncryptionConfiguration(output[_ECn], context);
      }
      if (output[_RTe] != null) {
        contents[_RTe] = de_ReplicationTime(output[_RTe], context);
      }
      if (output[_Me] != null) {
        contents[_Me] = de_Metrics(output[_Me], context);
      }
      return contents;
    };
    de_DestinationResult = (output, context) => {
      const contents = {};
      if (output[_TBT] != null) {
        contents[_TBT] = expectString(output[_TBT]);
      }
      if (output[_TBA] != null) {
        contents[_TBA] = expectString(output[_TBA]);
      }
      if (output[_TNa] != null) {
        contents[_TNa] = expectString(output[_TNa]);
      }
      return contents;
    };
    de_EncryptionConfiguration = (output, context) => {
      const contents = {};
      if (output[_RKKID] != null) {
        contents[_RKKID] = expectString(output[_RKKID]);
      }
      return contents;
    };
    de_EndEvent = (output, context) => {
      const contents = {};
      return contents;
    };
    de__Error = (output, context) => {
      const contents = {};
      if (output[_K] != null) {
        contents[_K] = expectString(output[_K]);
      }
      if (output[_VI] != null) {
        contents[_VI] = expectString(output[_VI]);
      }
      if (output[_Cod] != null) {
        contents[_Cod] = expectString(output[_Cod]);
      }
      if (output[_Mes] != null) {
        contents[_Mes] = expectString(output[_Mes]);
      }
      return contents;
    };
    de_ErrorDetails = (output, context) => {
      const contents = {};
      if (output[_EC] != null) {
        contents[_EC] = expectString(output[_EC]);
      }
      if (output[_EM] != null) {
        contents[_EM] = expectString(output[_EM]);
      }
      return contents;
    };
    de_ErrorDocument = (output, context) => {
      const contents = {};
      if (output[_K] != null) {
        contents[_K] = expectString(output[_K]);
      }
      return contents;
    };
    de_Errors = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de__Error(entry, context);
      });
    };
    de_EventBridgeConfiguration = (output, context) => {
      const contents = {};
      return contents;
    };
    de_EventList = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return expectString(entry);
      });
    };
    de_ExistingObjectReplication = (output, context) => {
      const contents = {};
      if (output[_S] != null) {
        contents[_S] = expectString(output[_S]);
      }
      return contents;
    };
    de_ExposeHeaders = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return expectString(entry);
      });
    };
    de_FilterRule = (output, context) => {
      const contents = {};
      if (output[_N] != null) {
        contents[_N] = expectString(output[_N]);
      }
      if (output[_Va] != null) {
        contents[_Va] = expectString(output[_Va]);
      }
      return contents;
    };
    de_FilterRuleList = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de_FilterRule(entry, context);
      });
    };
    de_GetBucketMetadataConfigurationResult = (output, context) => {
      const contents = {};
      if (output[_MCR] != null) {
        contents[_MCR] = de_MetadataConfigurationResult(output[_MCR], context);
      }
      return contents;
    };
    de_GetBucketMetadataTableConfigurationResult = (output, context) => {
      const contents = {};
      if (output[_MTCR] != null) {
        contents[_MTCR] = de_MetadataTableConfigurationResult(output[_MTCR], context);
      }
      if (output[_S] != null) {
        contents[_S] = expectString(output[_S]);
      }
      if (output[_Er] != null) {
        contents[_Er] = de_ErrorDetails(output[_Er], context);
      }
      return contents;
    };
    de_GetObjectAttributesParts = (output, context) => {
      const contents = {};
      if (output[_PC] != null) {
        contents[_TPC] = strictParseInt32(output[_PC]);
      }
      if (output[_PNM] != null) {
        contents[_PNM] = expectString(output[_PNM]);
      }
      if (output[_NPNM] != null) {
        contents[_NPNM] = expectString(output[_NPNM]);
      }
      if (output[_MP] != null) {
        contents[_MP] = strictParseInt32(output[_MP]);
      }
      if (output[_IT] != null) {
        contents[_IT] = parseBoolean(output[_IT]);
      }
      if (String(output.Part).trim() === "") {
        contents[_Part] = [];
      } else if (output[_Par] != null) {
        contents[_Part] = de_PartsList(getArrayIfSingleItem(output[_Par]), context);
      }
      return contents;
    };
    de_Grant = (output, context) => {
      const contents = {};
      if (output[_Gra] != null) {
        contents[_Gra] = de_Grantee(output[_Gra], context);
      }
      if (output[_Pe] != null) {
        contents[_Pe] = expectString(output[_Pe]);
      }
      return contents;
    };
    de_Grantee = (output, context) => {
      const contents = {};
      if (output[_DN] != null) {
        contents[_DN] = expectString(output[_DN]);
      }
      if (output[_EA] != null) {
        contents[_EA] = expectString(output[_EA]);
      }
      if (output[_ID_] != null) {
        contents[_ID_] = expectString(output[_ID_]);
      }
      if (output[_URI] != null) {
        contents[_URI] = expectString(output[_URI]);
      }
      if (output[_x] != null) {
        contents[_Ty] = expectString(output[_x]);
      }
      return contents;
    };
    de_Grants = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de_Grant(entry, context);
      });
    };
    de_IndexDocument = (output, context) => {
      const contents = {};
      if (output[_Su] != null) {
        contents[_Su] = expectString(output[_Su]);
      }
      return contents;
    };
    de_Initiator = (output, context) => {
      const contents = {};
      if (output[_ID_] != null) {
        contents[_ID_] = expectString(output[_ID_]);
      }
      if (output[_DN] != null) {
        contents[_DN] = expectString(output[_DN]);
      }
      return contents;
    };
    de_IntelligentTieringAndOperator = (output, context) => {
      const contents = {};
      if (output[_P] != null) {
        contents[_P] = expectString(output[_P]);
      }
      if (String(output.Tag).trim() === "") {
        contents[_Tag] = [];
      } else if (output[_Ta] != null) {
        contents[_Tag] = de_TagSet(getArrayIfSingleItem(output[_Ta]), context);
      }
      return contents;
    };
    de_IntelligentTieringConfiguration = (output, context) => {
      const contents = {};
      if (output[_I] != null) {
        contents[_I] = expectString(output[_I]);
      }
      if (output[_F] != null) {
        contents[_F] = de_IntelligentTieringFilter(output[_F], context);
      }
      if (output[_S] != null) {
        contents[_S] = expectString(output[_S]);
      }
      if (String(output.Tiering).trim() === "") {
        contents[_Tie] = [];
      } else if (output[_Tier] != null) {
        contents[_Tie] = de_TieringList(getArrayIfSingleItem(output[_Tier]), context);
      }
      return contents;
    };
    de_IntelligentTieringConfigurationList = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de_IntelligentTieringConfiguration(entry, context);
      });
    };
    de_IntelligentTieringFilter = (output, context) => {
      const contents = {};
      if (output[_P] != null) {
        contents[_P] = expectString(output[_P]);
      }
      if (output[_Ta] != null) {
        contents[_Ta] = de_Tag(output[_Ta], context);
      }
      if (output[_A] != null) {
        contents[_A] = de_IntelligentTieringAndOperator(output[_A], context);
      }
      return contents;
    };
    de_InventoryConfiguration = (output, context) => {
      const contents = {};
      if (output[_Des] != null) {
        contents[_Des] = de_InventoryDestination(output[_Des], context);
      }
      if (output[_IE] != null) {
        contents[_IE] = parseBoolean(output[_IE]);
      }
      if (output[_F] != null) {
        contents[_F] = de_InventoryFilter(output[_F], context);
      }
      if (output[_I] != null) {
        contents[_I] = expectString(output[_I]);
      }
      if (output[_IOV] != null) {
        contents[_IOV] = expectString(output[_IOV]);
      }
      if (String(output.OptionalFields).trim() === "") {
        contents[_OF] = [];
      } else if (output[_OF] != null && output[_OF][_Fi] != null) {
        contents[_OF] = de_InventoryOptionalFields(getArrayIfSingleItem(output[_OF][_Fi]), context);
      }
      if (output[_Sc] != null) {
        contents[_Sc] = de_InventorySchedule(output[_Sc], context);
      }
      return contents;
    };
    de_InventoryConfigurationList = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de_InventoryConfiguration(entry, context);
      });
    };
    de_InventoryDestination = (output, context) => {
      const contents = {};
      if (output[_SBD] != null) {
        contents[_SBD] = de_InventoryS3BucketDestination(output[_SBD], context);
      }
      return contents;
    };
    de_InventoryEncryption = (output, context) => {
      const contents = {};
      if (output[_SS] != null) {
        contents[_SSES] = de_SSES3(output[_SS], context);
      }
      if (output[_SK] != null) {
        contents[_SSEKMS] = de_SSEKMS(output[_SK], context);
      }
      return contents;
    };
    de_InventoryFilter = (output, context) => {
      const contents = {};
      if (output[_P] != null) {
        contents[_P] = expectString(output[_P]);
      }
      return contents;
    };
    de_InventoryOptionalFields = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return expectString(entry);
      });
    };
    de_InventoryS3BucketDestination = (output, context) => {
      const contents = {};
      if (output[_AIc] != null) {
        contents[_AIc] = expectString(output[_AIc]);
      }
      if (output[_B] != null) {
        contents[_B] = expectString(output[_B]);
      }
      if (output[_Fo] != null) {
        contents[_Fo] = expectString(output[_Fo]);
      }
      if (output[_P] != null) {
        contents[_P] = expectString(output[_P]);
      }
      if (output[_En] != null) {
        contents[_En] = de_InventoryEncryption(output[_En], context);
      }
      return contents;
    };
    de_InventorySchedule = (output, context) => {
      const contents = {};
      if (output[_Fr] != null) {
        contents[_Fr] = expectString(output[_Fr]);
      }
      return contents;
    };
    de_InventoryTableConfigurationResult = (output, context) => {
      const contents = {};
      if (output[_CSo] != null) {
        contents[_CSo] = expectString(output[_CSo]);
      }
      if (output[_TSa] != null) {
        contents[_TSa] = expectString(output[_TSa]);
      }
      if (output[_Er] != null) {
        contents[_Er] = de_ErrorDetails(output[_Er], context);
      }
      if (output[_TN] != null) {
        contents[_TN] = expectString(output[_TN]);
      }
      if (output[_TAa] != null) {
        contents[_TAa] = expectString(output[_TAa]);
      }
      return contents;
    };
    de_JournalTableConfigurationResult = (output, context) => {
      const contents = {};
      if (output[_TSa] != null) {
        contents[_TSa] = expectString(output[_TSa]);
      }
      if (output[_Er] != null) {
        contents[_Er] = de_ErrorDetails(output[_Er], context);
      }
      if (output[_TN] != null) {
        contents[_TN] = expectString(output[_TN]);
      }
      if (output[_TAa] != null) {
        contents[_TAa] = expectString(output[_TAa]);
      }
      if (output[_REe] != null) {
        contents[_REe] = de_RecordExpiration(output[_REe], context);
      }
      return contents;
    };
    de_LambdaFunctionConfiguration = (output, context) => {
      const contents = {};
      if (output[_I] != null) {
        contents[_I] = expectString(output[_I]);
      }
      if (output[_CF] != null) {
        contents[_LFA] = expectString(output[_CF]);
      }
      if (String(output.Event).trim() === "") {
        contents[_Eve] = [];
      } else if (output[_Ev] != null) {
        contents[_Eve] = de_EventList(getArrayIfSingleItem(output[_Ev]), context);
      }
      if (output[_F] != null) {
        contents[_F] = de_NotificationConfigurationFilter(output[_F], context);
      }
      return contents;
    };
    de_LambdaFunctionConfigurationList = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de_LambdaFunctionConfiguration(entry, context);
      });
    };
    de_LifecycleExpiration = (output, context) => {
      const contents = {};
      if (output[_Dat] != null) {
        contents[_Dat] = expectNonNull(parseRfc3339DateTimeWithOffset(output[_Dat]));
      }
      if (output[_Da] != null) {
        contents[_Da] = strictParseInt32(output[_Da]);
      }
      if (output[_EODM] != null) {
        contents[_EODM] = parseBoolean(output[_EODM]);
      }
      return contents;
    };
    de_LifecycleRule = (output, context) => {
      const contents = {};
      if (output[_Exp] != null) {
        contents[_Exp] = de_LifecycleExpiration(output[_Exp], context);
      }
      if (output[_ID_] != null) {
        contents[_ID_] = expectString(output[_ID_]);
      }
      if (output[_P] != null) {
        contents[_P] = expectString(output[_P]);
      }
      if (output[_F] != null) {
        contents[_F] = de_LifecycleRuleFilter(output[_F], context);
      }
      if (output[_S] != null) {
        contents[_S] = expectString(output[_S]);
      }
      if (String(output.Transition).trim() === "") {
        contents[_Tr] = [];
      } else if (output[_Tra] != null) {
        contents[_Tr] = de_TransitionList(getArrayIfSingleItem(output[_Tra]), context);
      }
      if (String(output.NoncurrentVersionTransition).trim() === "") {
        contents[_NVT] = [];
      } else if (output[_NVTo] != null) {
        contents[_NVT] = de_NoncurrentVersionTransitionList(getArrayIfSingleItem(output[_NVTo]), context);
      }
      if (output[_NVE] != null) {
        contents[_NVE] = de_NoncurrentVersionExpiration(output[_NVE], context);
      }
      if (output[_AIMU] != null) {
        contents[_AIMU] = de_AbortIncompleteMultipartUpload(output[_AIMU], context);
      }
      return contents;
    };
    de_LifecycleRuleAndOperator = (output, context) => {
      const contents = {};
      if (output[_P] != null) {
        contents[_P] = expectString(output[_P]);
      }
      if (String(output.Tag).trim() === "") {
        contents[_Tag] = [];
      } else if (output[_Ta] != null) {
        contents[_Tag] = de_TagSet(getArrayIfSingleItem(output[_Ta]), context);
      }
      if (output[_OSGT] != null) {
        contents[_OSGT] = strictParseLong(output[_OSGT]);
      }
      if (output[_OSLT] != null) {
        contents[_OSLT] = strictParseLong(output[_OSLT]);
      }
      return contents;
    };
    de_LifecycleRuleFilter = (output, context) => {
      const contents = {};
      if (output[_P] != null) {
        contents[_P] = expectString(output[_P]);
      }
      if (output[_Ta] != null) {
        contents[_Ta] = de_Tag(output[_Ta], context);
      }
      if (output[_OSGT] != null) {
        contents[_OSGT] = strictParseLong(output[_OSGT]);
      }
      if (output[_OSLT] != null) {
        contents[_OSLT] = strictParseLong(output[_OSLT]);
      }
      if (output[_A] != null) {
        contents[_A] = de_LifecycleRuleAndOperator(output[_A], context);
      }
      return contents;
    };
    de_LifecycleRules = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de_LifecycleRule(entry, context);
      });
    };
    de_LoggingEnabled = (output, context) => {
      const contents = {};
      if (output[_TB] != null) {
        contents[_TB] = expectString(output[_TB]);
      }
      if (String(output.TargetGrants).trim() === "") {
        contents[_TG] = [];
      } else if (output[_TG] != null && output[_TG][_G] != null) {
        contents[_TG] = de_TargetGrants(getArrayIfSingleItem(output[_TG][_G]), context);
      }
      if (output[_TP] != null) {
        contents[_TP] = expectString(output[_TP]);
      }
      if (output[_TOKF] != null) {
        contents[_TOKF] = de_TargetObjectKeyFormat(output[_TOKF], context);
      }
      return contents;
    };
    de_MetadataConfigurationResult = (output, context) => {
      const contents = {};
      if (output[_DRes] != null) {
        contents[_DRes] = de_DestinationResult(output[_DRes], context);
      }
      if (output[_JTCR] != null) {
        contents[_JTCR] = de_JournalTableConfigurationResult(output[_JTCR], context);
      }
      if (output[_ITCR] != null) {
        contents[_ITCR] = de_InventoryTableConfigurationResult(output[_ITCR], context);
      }
      return contents;
    };
    de_MetadataTableConfigurationResult = (output, context) => {
      const contents = {};
      if (output[_STDR] != null) {
        contents[_STDR] = de_S3TablesDestinationResult(output[_STDR], context);
      }
      return contents;
    };
    de_Metrics = (output, context) => {
      const contents = {};
      if (output[_S] != null) {
        contents[_S] = expectString(output[_S]);
      }
      if (output[_ETv] != null) {
        contents[_ETv] = de_ReplicationTimeValue(output[_ETv], context);
      }
      return contents;
    };
    de_MetricsAndOperator = (output, context) => {
      const contents = {};
      if (output[_P] != null) {
        contents[_P] = expectString(output[_P]);
      }
      if (String(output.Tag).trim() === "") {
        contents[_Tag] = [];
      } else if (output[_Ta] != null) {
        contents[_Tag] = de_TagSet(getArrayIfSingleItem(output[_Ta]), context);
      }
      if (output[_APAc] != null) {
        contents[_APAc] = expectString(output[_APAc]);
      }
      return contents;
    };
    de_MetricsConfiguration = (output, context) => {
      const contents = {};
      if (output[_I] != null) {
        contents[_I] = expectString(output[_I]);
      }
      if (String(output.Filter).trim() === "") {
      } else if (output[_F] != null) {
        contents[_F] = de_MetricsFilter(expectUnion(output[_F]), context);
      }
      return contents;
    };
    de_MetricsConfigurationList = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de_MetricsConfiguration(entry, context);
      });
    };
    de_MetricsFilter = (output, context) => {
      if (output[_P] != null) {
        return {
          Prefix: expectString(output[_P])
        };
      }
      if (output[_Ta] != null) {
        return {
          Tag: de_Tag(output[_Ta], context)
        };
      }
      if (output[_APAc] != null) {
        return {
          AccessPointArn: expectString(output[_APAc])
        };
      }
      if (output[_A] != null) {
        return {
          And: de_MetricsAndOperator(output[_A], context)
        };
      }
      return { $unknown: Object.entries(output)[0] };
    };
    de_MultipartUpload = (output, context) => {
      const contents = {};
      if (output[_UI] != null) {
        contents[_UI] = expectString(output[_UI]);
      }
      if (output[_K] != null) {
        contents[_K] = expectString(output[_K]);
      }
      if (output[_Ini] != null) {
        contents[_Ini] = expectNonNull(parseRfc3339DateTimeWithOffset(output[_Ini]));
      }
      if (output[_SC] != null) {
        contents[_SC] = expectString(output[_SC]);
      }
      if (output[_O] != null) {
        contents[_O] = de_Owner(output[_O], context);
      }
      if (output[_In] != null) {
        contents[_In] = de_Initiator(output[_In], context);
      }
      if (output[_CA] != null) {
        contents[_CA] = expectString(output[_CA]);
      }
      if (output[_CT] != null) {
        contents[_CT] = expectString(output[_CT]);
      }
      return contents;
    };
    de_MultipartUploadList = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de_MultipartUpload(entry, context);
      });
    };
    de_NoncurrentVersionExpiration = (output, context) => {
      const contents = {};
      if (output[_ND] != null) {
        contents[_ND] = strictParseInt32(output[_ND]);
      }
      if (output[_NNV] != null) {
        contents[_NNV] = strictParseInt32(output[_NNV]);
      }
      return contents;
    };
    de_NoncurrentVersionTransition = (output, context) => {
      const contents = {};
      if (output[_ND] != null) {
        contents[_ND] = strictParseInt32(output[_ND]);
      }
      if (output[_SC] != null) {
        contents[_SC] = expectString(output[_SC]);
      }
      if (output[_NNV] != null) {
        contents[_NNV] = strictParseInt32(output[_NNV]);
      }
      return contents;
    };
    de_NoncurrentVersionTransitionList = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de_NoncurrentVersionTransition(entry, context);
      });
    };
    de_NotificationConfigurationFilter = (output, context) => {
      const contents = {};
      if (output[_SKe] != null) {
        contents[_K] = de_S3KeyFilter(output[_SKe], context);
      }
      return contents;
    };
    de__Object = (output, context) => {
      const contents = {};
      if (output[_K] != null) {
        contents[_K] = expectString(output[_K]);
      }
      if (output[_LM] != null) {
        contents[_LM] = expectNonNull(parseRfc3339DateTimeWithOffset(output[_LM]));
      }
      if (output[_ETa] != null) {
        contents[_ETa] = expectString(output[_ETa]);
      }
      if (String(output.ChecksumAlgorithm).trim() === "") {
        contents[_CA] = [];
      } else if (output[_CA] != null) {
        contents[_CA] = de_ChecksumAlgorithmList(getArrayIfSingleItem(output[_CA]), context);
      }
      if (output[_CT] != null) {
        contents[_CT] = expectString(output[_CT]);
      }
      if (output[_Si] != null) {
        contents[_Si] = strictParseLong(output[_Si]);
      }
      if (output[_SC] != null) {
        contents[_SC] = expectString(output[_SC]);
      }
      if (output[_O] != null) {
        contents[_O] = de_Owner(output[_O], context);
      }
      if (output[_RSes] != null) {
        contents[_RSes] = de_RestoreStatus(output[_RSes], context);
      }
      return contents;
    };
    de_ObjectList = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de__Object(entry, context);
      });
    };
    de_ObjectLockConfiguration = (output, context) => {
      const contents = {};
      if (output[_OLE] != null) {
        contents[_OLE] = expectString(output[_OLE]);
      }
      if (output[_Ru] != null) {
        contents[_Ru] = de_ObjectLockRule(output[_Ru], context);
      }
      return contents;
    };
    de_ObjectLockLegalHold = (output, context) => {
      const contents = {};
      if (output[_S] != null) {
        contents[_S] = expectString(output[_S]);
      }
      return contents;
    };
    de_ObjectLockRetention = (output, context) => {
      const contents = {};
      if (output[_Mo] != null) {
        contents[_Mo] = expectString(output[_Mo]);
      }
      if (output[_RUD] != null) {
        contents[_RUD] = expectNonNull(parseRfc3339DateTimeWithOffset(output[_RUD]));
      }
      return contents;
    };
    de_ObjectLockRule = (output, context) => {
      const contents = {};
      if (output[_DRe] != null) {
        contents[_DRe] = de_DefaultRetention(output[_DRe], context);
      }
      return contents;
    };
    de_ObjectPart = (output, context) => {
      const contents = {};
      if (output[_PN] != null) {
        contents[_PN] = strictParseInt32(output[_PN]);
      }
      if (output[_Si] != null) {
        contents[_Si] = strictParseLong(output[_Si]);
      }
      if (output[_CCRC] != null) {
        contents[_CCRC] = expectString(output[_CCRC]);
      }
      if (output[_CCRCC] != null) {
        contents[_CCRCC] = expectString(output[_CCRCC]);
      }
      if (output[_CCRCNVME] != null) {
        contents[_CCRCNVME] = expectString(output[_CCRCNVME]);
      }
      if (output[_CSHA] != null) {
        contents[_CSHA] = expectString(output[_CSHA]);
      }
      if (output[_CSHAh] != null) {
        contents[_CSHAh] = expectString(output[_CSHAh]);
      }
      return contents;
    };
    de_ObjectVersion = (output, context) => {
      const contents = {};
      if (output[_ETa] != null) {
        contents[_ETa] = expectString(output[_ETa]);
      }
      if (String(output.ChecksumAlgorithm).trim() === "") {
        contents[_CA] = [];
      } else if (output[_CA] != null) {
        contents[_CA] = de_ChecksumAlgorithmList(getArrayIfSingleItem(output[_CA]), context);
      }
      if (output[_CT] != null) {
        contents[_CT] = expectString(output[_CT]);
      }
      if (output[_Si] != null) {
        contents[_Si] = strictParseLong(output[_Si]);
      }
      if (output[_SC] != null) {
        contents[_SC] = expectString(output[_SC]);
      }
      if (output[_K] != null) {
        contents[_K] = expectString(output[_K]);
      }
      if (output[_VI] != null) {
        contents[_VI] = expectString(output[_VI]);
      }
      if (output[_IL] != null) {
        contents[_IL] = parseBoolean(output[_IL]);
      }
      if (output[_LM] != null) {
        contents[_LM] = expectNonNull(parseRfc3339DateTimeWithOffset(output[_LM]));
      }
      if (output[_O] != null) {
        contents[_O] = de_Owner(output[_O], context);
      }
      if (output[_RSes] != null) {
        contents[_RSes] = de_RestoreStatus(output[_RSes], context);
      }
      return contents;
    };
    de_ObjectVersionList = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de_ObjectVersion(entry, context);
      });
    };
    de_Owner = (output, context) => {
      const contents = {};
      if (output[_DN] != null) {
        contents[_DN] = expectString(output[_DN]);
      }
      if (output[_ID_] != null) {
        contents[_ID_] = expectString(output[_ID_]);
      }
      return contents;
    };
    de_OwnershipControls = (output, context) => {
      const contents = {};
      if (String(output.Rule).trim() === "") {
        contents[_Rul] = [];
      } else if (output[_Ru] != null) {
        contents[_Rul] = de_OwnershipControlsRules(getArrayIfSingleItem(output[_Ru]), context);
      }
      return contents;
    };
    de_OwnershipControlsRule = (output, context) => {
      const contents = {};
      if (output[_OO] != null) {
        contents[_OO] = expectString(output[_OO]);
      }
      return contents;
    };
    de_OwnershipControlsRules = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de_OwnershipControlsRule(entry, context);
      });
    };
    de_Part = (output, context) => {
      const contents = {};
      if (output[_PN] != null) {
        contents[_PN] = strictParseInt32(output[_PN]);
      }
      if (output[_LM] != null) {
        contents[_LM] = expectNonNull(parseRfc3339DateTimeWithOffset(output[_LM]));
      }
      if (output[_ETa] != null) {
        contents[_ETa] = expectString(output[_ETa]);
      }
      if (output[_Si] != null) {
        contents[_Si] = strictParseLong(output[_Si]);
      }
      if (output[_CCRC] != null) {
        contents[_CCRC] = expectString(output[_CCRC]);
      }
      if (output[_CCRCC] != null) {
        contents[_CCRCC] = expectString(output[_CCRCC]);
      }
      if (output[_CCRCNVME] != null) {
        contents[_CCRCNVME] = expectString(output[_CCRCNVME]);
      }
      if (output[_CSHA] != null) {
        contents[_CSHA] = expectString(output[_CSHA]);
      }
      if (output[_CSHAh] != null) {
        contents[_CSHAh] = expectString(output[_CSHAh]);
      }
      return contents;
    };
    de_PartitionedPrefix = (output, context) => {
      const contents = {};
      if (output[_PDS] != null) {
        contents[_PDS] = expectString(output[_PDS]);
      }
      return contents;
    };
    de_Parts = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de_Part(entry, context);
      });
    };
    de_PartsList = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de_ObjectPart(entry, context);
      });
    };
    de_PolicyStatus = (output, context) => {
      const contents = {};
      if (output[_IP] != null) {
        contents[_IP] = parseBoolean(output[_IP]);
      }
      return contents;
    };
    de_Progress = (output, context) => {
      const contents = {};
      if (output[_BS] != null) {
        contents[_BS] = strictParseLong(output[_BS]);
      }
      if (output[_BP] != null) {
        contents[_BP] = strictParseLong(output[_BP]);
      }
      if (output[_BRy] != null) {
        contents[_BRy] = strictParseLong(output[_BRy]);
      }
      return contents;
    };
    de_PublicAccessBlockConfiguration = (output, context) => {
      const contents = {};
      if (output[_BPA] != null) {
        contents[_BPA] = parseBoolean(output[_BPA]);
      }
      if (output[_IPA] != null) {
        contents[_IPA] = parseBoolean(output[_IPA]);
      }
      if (output[_BPP] != null) {
        contents[_BPP] = parseBoolean(output[_BPP]);
      }
      if (output[_RPB] != null) {
        contents[_RPB] = parseBoolean(output[_RPB]);
      }
      return contents;
    };
    de_QueueConfiguration = (output, context) => {
      const contents = {};
      if (output[_I] != null) {
        contents[_I] = expectString(output[_I]);
      }
      if (output[_Qu] != null) {
        contents[_QA] = expectString(output[_Qu]);
      }
      if (String(output.Event).trim() === "") {
        contents[_Eve] = [];
      } else if (output[_Ev] != null) {
        contents[_Eve] = de_EventList(getArrayIfSingleItem(output[_Ev]), context);
      }
      if (output[_F] != null) {
        contents[_F] = de_NotificationConfigurationFilter(output[_F], context);
      }
      return contents;
    };
    de_QueueConfigurationList = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de_QueueConfiguration(entry, context);
      });
    };
    de_RecordExpiration = (output, context) => {
      const contents = {};
      if (output[_Exp] != null) {
        contents[_Exp] = expectString(output[_Exp]);
      }
      if (output[_Da] != null) {
        contents[_Da] = strictParseInt32(output[_Da]);
      }
      return contents;
    };
    de_Redirect = (output, context) => {
      const contents = {};
      if (output[_HN] != null) {
        contents[_HN] = expectString(output[_HN]);
      }
      if (output[_HRC] != null) {
        contents[_HRC] = expectString(output[_HRC]);
      }
      if (output[_Pr] != null) {
        contents[_Pr] = expectString(output[_Pr]);
      }
      if (output[_RKPW] != null) {
        contents[_RKPW] = expectString(output[_RKPW]);
      }
      if (output[_RKW] != null) {
        contents[_RKW] = expectString(output[_RKW]);
      }
      return contents;
    };
    de_RedirectAllRequestsTo = (output, context) => {
      const contents = {};
      if (output[_HN] != null) {
        contents[_HN] = expectString(output[_HN]);
      }
      if (output[_Pr] != null) {
        contents[_Pr] = expectString(output[_Pr]);
      }
      return contents;
    };
    de_ReplicaModifications = (output, context) => {
      const contents = {};
      if (output[_S] != null) {
        contents[_S] = expectString(output[_S]);
      }
      return contents;
    };
    de_ReplicationConfiguration = (output, context) => {
      const contents = {};
      if (output[_Ro] != null) {
        contents[_Ro] = expectString(output[_Ro]);
      }
      if (String(output.Rule).trim() === "") {
        contents[_Rul] = [];
      } else if (output[_Ru] != null) {
        contents[_Rul] = de_ReplicationRules(getArrayIfSingleItem(output[_Ru]), context);
      }
      return contents;
    };
    de_ReplicationRule = (output, context) => {
      const contents = {};
      if (output[_ID_] != null) {
        contents[_ID_] = expectString(output[_ID_]);
      }
      if (output[_Pri] != null) {
        contents[_Pri] = strictParseInt32(output[_Pri]);
      }
      if (output[_P] != null) {
        contents[_P] = expectString(output[_P]);
      }
      if (output[_F] != null) {
        contents[_F] = de_ReplicationRuleFilter(output[_F], context);
      }
      if (output[_S] != null) {
        contents[_S] = expectString(output[_S]);
      }
      if (output[_SSC] != null) {
        contents[_SSC] = de_SourceSelectionCriteria(output[_SSC], context);
      }
      if (output[_EOR] != null) {
        contents[_EOR] = de_ExistingObjectReplication(output[_EOR], context);
      }
      if (output[_Des] != null) {
        contents[_Des] = de_Destination(output[_Des], context);
      }
      if (output[_DMR] != null) {
        contents[_DMR] = de_DeleteMarkerReplication(output[_DMR], context);
      }
      return contents;
    };
    de_ReplicationRuleAndOperator = (output, context) => {
      const contents = {};
      if (output[_P] != null) {
        contents[_P] = expectString(output[_P]);
      }
      if (String(output.Tag).trim() === "") {
        contents[_Tag] = [];
      } else if (output[_Ta] != null) {
        contents[_Tag] = de_TagSet(getArrayIfSingleItem(output[_Ta]), context);
      }
      return contents;
    };
    de_ReplicationRuleFilter = (output, context) => {
      const contents = {};
      if (output[_P] != null) {
        contents[_P] = expectString(output[_P]);
      }
      if (output[_Ta] != null) {
        contents[_Ta] = de_Tag(output[_Ta], context);
      }
      if (output[_A] != null) {
        contents[_A] = de_ReplicationRuleAndOperator(output[_A], context);
      }
      return contents;
    };
    de_ReplicationRules = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de_ReplicationRule(entry, context);
      });
    };
    de_ReplicationTime = (output, context) => {
      const contents = {};
      if (output[_S] != null) {
        contents[_S] = expectString(output[_S]);
      }
      if (output[_Tim] != null) {
        contents[_Tim] = de_ReplicationTimeValue(output[_Tim], context);
      }
      return contents;
    };
    de_ReplicationTimeValue = (output, context) => {
      const contents = {};
      if (output[_Mi] != null) {
        contents[_Mi] = strictParseInt32(output[_Mi]);
      }
      return contents;
    };
    de_RestoreStatus = (output, context) => {
      const contents = {};
      if (output[_IRIP] != null) {
        contents[_IRIP] = parseBoolean(output[_IRIP]);
      }
      if (output[_REDe] != null) {
        contents[_REDe] = expectNonNull(parseRfc3339DateTimeWithOffset(output[_REDe]));
      }
      return contents;
    };
    de_RoutingRule = (output, context) => {
      const contents = {};
      if (output[_Con] != null) {
        contents[_Con] = de_Condition(output[_Con], context);
      }
      if (output[_Red] != null) {
        contents[_Red] = de_Redirect(output[_Red], context);
      }
      return contents;
    };
    de_RoutingRules = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de_RoutingRule(entry, context);
      });
    };
    de_S3KeyFilter = (output, context) => {
      const contents = {};
      if (String(output.FilterRule).trim() === "") {
        contents[_FRi] = [];
      } else if (output[_FR] != null) {
        contents[_FRi] = de_FilterRuleList(getArrayIfSingleItem(output[_FR]), context);
      }
      return contents;
    };
    de_S3TablesDestinationResult = (output, context) => {
      const contents = {};
      if (output[_TBA] != null) {
        contents[_TBA] = expectString(output[_TBA]);
      }
      if (output[_TN] != null) {
        contents[_TN] = expectString(output[_TN]);
      }
      if (output[_TAa] != null) {
        contents[_TAa] = expectString(output[_TAa]);
      }
      if (output[_TNa] != null) {
        contents[_TNa] = expectString(output[_TNa]);
      }
      return contents;
    };
    de_ServerSideEncryptionByDefault = (output, context) => {
      const contents = {};
      if (output[_SSEA] != null) {
        contents[_SSEA] = expectString(output[_SSEA]);
      }
      if (output[_KMSMKID] != null) {
        contents[_KMSMKID] = expectString(output[_KMSMKID]);
      }
      return contents;
    };
    de_ServerSideEncryptionConfiguration = (output, context) => {
      const contents = {};
      if (String(output.Rule).trim() === "") {
        contents[_Rul] = [];
      } else if (output[_Ru] != null) {
        contents[_Rul] = de_ServerSideEncryptionRules(getArrayIfSingleItem(output[_Ru]), context);
      }
      return contents;
    };
    de_ServerSideEncryptionRule = (output, context) => {
      const contents = {};
      if (output[_ASSEBD] != null) {
        contents[_ASSEBD] = de_ServerSideEncryptionByDefault(output[_ASSEBD], context);
      }
      if (output[_BKE] != null) {
        contents[_BKE] = parseBoolean(output[_BKE]);
      }
      return contents;
    };
    de_ServerSideEncryptionRules = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de_ServerSideEncryptionRule(entry, context);
      });
    };
    de_SessionCredentials = (output, context) => {
      const contents = {};
      if (output[_AKI] != null) {
        contents[_AKI] = expectString(output[_AKI]);
      }
      if (output[_SAK] != null) {
        contents[_SAK] = expectString(output[_SAK]);
      }
      if (output[_ST] != null) {
        contents[_ST] = expectString(output[_ST]);
      }
      if (output[_Exp] != null) {
        contents[_Exp] = expectNonNull(parseRfc3339DateTimeWithOffset(output[_Exp]));
      }
      return contents;
    };
    de_SimplePrefix = (output, context) => {
      const contents = {};
      return contents;
    };
    de_SourceSelectionCriteria = (output, context) => {
      const contents = {};
      if (output[_SKEO] != null) {
        contents[_SKEO] = de_SseKmsEncryptedObjects(output[_SKEO], context);
      }
      if (output[_RM] != null) {
        contents[_RM] = de_ReplicaModifications(output[_RM], context);
      }
      return contents;
    };
    de_SSEKMS = (output, context) => {
      const contents = {};
      if (output[_KI] != null) {
        contents[_KI] = expectString(output[_KI]);
      }
      return contents;
    };
    de_SseKmsEncryptedObjects = (output, context) => {
      const contents = {};
      if (output[_S] != null) {
        contents[_S] = expectString(output[_S]);
      }
      return contents;
    };
    de_SSES3 = (output, context) => {
      const contents = {};
      return contents;
    };
    de_Stats = (output, context) => {
      const contents = {};
      if (output[_BS] != null) {
        contents[_BS] = strictParseLong(output[_BS]);
      }
      if (output[_BP] != null) {
        contents[_BP] = strictParseLong(output[_BP]);
      }
      if (output[_BRy] != null) {
        contents[_BRy] = strictParseLong(output[_BRy]);
      }
      return contents;
    };
    de_StorageClassAnalysis = (output, context) => {
      const contents = {};
      if (output[_DE] != null) {
        contents[_DE] = de_StorageClassAnalysisDataExport(output[_DE], context);
      }
      return contents;
    };
    de_StorageClassAnalysisDataExport = (output, context) => {
      const contents = {};
      if (output[_OSV] != null) {
        contents[_OSV] = expectString(output[_OSV]);
      }
      if (output[_Des] != null) {
        contents[_Des] = de_AnalyticsExportDestination(output[_Des], context);
      }
      return contents;
    };
    de_Tag = (output, context) => {
      const contents = {};
      if (output[_K] != null) {
        contents[_K] = expectString(output[_K]);
      }
      if (output[_Va] != null) {
        contents[_Va] = expectString(output[_Va]);
      }
      return contents;
    };
    de_TagSet = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de_Tag(entry, context);
      });
    };
    de_TargetGrant = (output, context) => {
      const contents = {};
      if (output[_Gra] != null) {
        contents[_Gra] = de_Grantee(output[_Gra], context);
      }
      if (output[_Pe] != null) {
        contents[_Pe] = expectString(output[_Pe]);
      }
      return contents;
    };
    de_TargetGrants = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de_TargetGrant(entry, context);
      });
    };
    de_TargetObjectKeyFormat = (output, context) => {
      const contents = {};
      if (output[_SPi] != null) {
        contents[_SPi] = de_SimplePrefix(output[_SPi], context);
      }
      if (output[_PP] != null) {
        contents[_PP] = de_PartitionedPrefix(output[_PP], context);
      }
      return contents;
    };
    de_Tiering = (output, context) => {
      const contents = {};
      if (output[_Da] != null) {
        contents[_Da] = strictParseInt32(output[_Da]);
      }
      if (output[_AT] != null) {
        contents[_AT] = expectString(output[_AT]);
      }
      return contents;
    };
    de_TieringList = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de_Tiering(entry, context);
      });
    };
    de_TopicConfiguration = (output, context) => {
      const contents = {};
      if (output[_I] != null) {
        contents[_I] = expectString(output[_I]);
      }
      if (output[_Top] != null) {
        contents[_TA] = expectString(output[_Top]);
      }
      if (String(output.Event).trim() === "") {
        contents[_Eve] = [];
      } else if (output[_Ev] != null) {
        contents[_Eve] = de_EventList(getArrayIfSingleItem(output[_Ev]), context);
      }
      if (output[_F] != null) {
        contents[_F] = de_NotificationConfigurationFilter(output[_F], context);
      }
      return contents;
    };
    de_TopicConfigurationList = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de_TopicConfiguration(entry, context);
      });
    };
    de_Transition = (output, context) => {
      const contents = {};
      if (output[_Dat] != null) {
        contents[_Dat] = expectNonNull(parseRfc3339DateTimeWithOffset(output[_Dat]));
      }
      if (output[_Da] != null) {
        contents[_Da] = strictParseInt32(output[_Da]);
      }
      if (output[_SC] != null) {
        contents[_SC] = expectString(output[_SC]);
      }
      return contents;
    };
    de_TransitionList = (output, context) => {
      return (output || []).filter((e2) => e2 != null).map((entry) => {
        return de_Transition(entry, context);
      });
    };
    deserializeMetadata2 = (output) => ({
      httpStatusCode: output.statusCode,
      requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
      extendedRequestId: output.headers["x-amz-id-2"],
      cfId: output.headers["x-amz-cf-id"]
    });
    collectBodyString2 = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
    _A = "And";
    _AAO = "AnalyticsAndOperator";
    _AC = "AnalyticsConfiguration";
    _ACL = "ACL";
    _ACLc = "AccessControlList";
    _ACLn = "AnalyticsConfigurationList";
    _ACP = "AccessControlPolicy";
    _ACT = "AccessControlTranslation";
    _ACc = "AccelerateConfiguration";
    _AD = "AbortDate";
    _AED = "AnalyticsExportDestination";
    _AF = "AnalyticsFilter";
    _AH = "AllowedHeader";
    _AHl = "AllowedHeaders";
    _AI = "AnalyticsId";
    _AIMU = "AbortIncompleteMultipartUpload";
    _AIc = "AccountId";
    _AKI = "AccessKeyId";
    _AM = "AllowedMethod";
    _AMl = "AllowedMethods";
    _AO = "AllowedOrigin";
    _AOl = "AllowedOrigins";
    _APA = "AccessPointAlias";
    _APAc = "AccessPointArn";
    _AQRD = "AllowQuotedRecordDelimiter";
    _AR = "AcceptRanges";
    _ARI = "AbortRuleId";
    _AS = "ArchiveStatus";
    _ASBD = "AnalyticsS3BucketDestination";
    _ASEFF = "AnalyticsS3ExportFileFormat";
    _ASSEBD = "ApplyServerSideEncryptionByDefault";
    _AT = "AccessTier";
    _Ac = "Account";
    _B = "Bucket";
    _BA = "BucketArn";
    _BAI = "BucketAccountId";
    _BAS = "BucketAccelerateStatus";
    _BGR = "BypassGovernanceRetention";
    _BI = "BucketInfo";
    _BKE = "BucketKeyEnabled";
    _BLC = "BucketLifecycleConfiguration";
    _BLCu = "BucketLocationConstraint";
    _BLN = "BucketLocationName";
    _BLP = "BucketLogsPermission";
    _BLS = "BucketLoggingStatus";
    _BLT = "BucketLocationType";
    _BN = "BucketName";
    _BP = "BytesProcessed";
    _BPA = "BlockPublicAcls";
    _BPP = "BlockPublicPolicy";
    _BR = "BucketRegion";
    _BRy = "BytesReturned";
    _BS = "BytesScanned";
    _BT = "BucketType";
    _BVS = "BucketVersioningStatus";
    _Bu = "Buckets";
    _C = "Credentials";
    _CA = "ChecksumAlgorithm";
    _CACL = "CannedACL";
    _CBC = "CreateBucketConfiguration";
    _CC = "CacheControl";
    _CCRC = "ChecksumCRC32";
    _CCRCC = "ChecksumCRC32C";
    _CCRCNVME = "ChecksumCRC64NVME";
    _CD = "ContentDisposition";
    _CDr = "CreationDate";
    _CE = "ContentEncoding";
    _CF = "CloudFunction";
    _CFC = "CloudFunctionConfiguration";
    _CL = "ContentLanguage";
    _CLo = "ContentLength";
    _CM = "ChecksumMode";
    _CMD = "ContentMD5";
    _CMU = "CompletedMultipartUpload";
    _CORSC = "CORSConfiguration";
    _CORSR = "CORSRule";
    _CORSRu = "CORSRules";
    _CP = "CommonPrefixes";
    _CPo = "CompletedPart";
    _CR = "ContentRange";
    _CRSBA = "ConfirmRemoveSelfBucketAccess";
    _CS = "CopySource";
    _CSHA = "ChecksumSHA1";
    _CSHAh = "ChecksumSHA256";
    _CSIM = "CopySourceIfMatch";
    _CSIMS = "CopySourceIfModifiedSince";
    _CSINM = "CopySourceIfNoneMatch";
    _CSIUS = "CopySourceIfUnmodifiedSince";
    _CSR = "CopySourceRange";
    _CSSSECA = "CopySourceSSECustomerAlgorithm";
    _CSSSECK = "CopySourceSSECustomerKey";
    _CSSSECKMD = "CopySourceSSECustomerKeyMD5";
    _CSV = "CSV";
    _CSVI = "CopySourceVersionId";
    _CSVIn = "CSVInput";
    _CSVO = "CSVOutput";
    _CSo = "ConfigurationState";
    _CT = "ChecksumType";
    _CTl = "ClientToken";
    _CTo = "ContentType";
    _CTom = "CompressionType";
    _CTon = "ContinuationToken";
    _Ch = "Checksum";
    _Co = "Contents";
    _Cod = "Code";
    _Com = "Comments";
    _Con = "Condition";
    _D = "Delimiter";
    _DAI = "DaysAfterInitiation";
    _DE = "DataExport";
    _DIM = "DestinationIfMatch";
    _DIMS = "DestinationIfModifiedSince";
    _DINM = "DestinationIfNoneMatch";
    _DIUS = "DestinationIfUnmodifiedSince";
    _DM = "DeleteMarker";
    _DMR = "DeleteMarkerReplication";
    _DMRS = "DeleteMarkerReplicationStatus";
    _DMVI = "DeleteMarkerVersionId";
    _DMe = "DeleteMarkers";
    _DN = "DisplayName";
    _DR = "DataRedundancy";
    _DRe = "DefaultRetention";
    _DRes = "DestinationResult";
    _Da = "Days";
    _Dat = "Date";
    _De = "Deleted";
    _Del = "Delete";
    _Des = "Destination";
    _Desc = "Description";
    _E = "Expires";
    _EA = "EmailAddress";
    _EBC = "EventBridgeConfiguration";
    _EBO = "ExpectedBucketOwner";
    _EC = "ErrorCode";
    _ECn = "EncryptionConfiguration";
    _ED = "ErrorDocument";
    _EH = "ExposeHeaders";
    _EHx = "ExposeHeader";
    _EM = "ErrorMessage";
    _EODM = "ExpiredObjectDeleteMarker";
    _EOR = "ExistingObjectReplication";
    _EORS = "ExistingObjectReplicationStatus";
    _ERP = "EnableRequestProgress";
    _ES = "ExpiresString";
    _ESBO = "ExpectedSourceBucketOwner";
    _ESx = "ExpirationStatus";
    _ESxp = "ExpirationState";
    _ET = "EncodingType";
    _ETa = "ETag";
    _ETn = "EncryptionType";
    _ETv = "EventThreshold";
    _ETx = "ExpressionType";
    _En = "Encryption";
    _Ena = "Enabled";
    _End = "End";
    _Er = "Error";
    _Err = "Errors";
    _Ev = "Event";
    _Eve = "Events";
    _Ex = "Expression";
    _Exp = "Expiration";
    _F = "Filter";
    _FD = "FieldDelimiter";
    _FHI = "FileHeaderInfo";
    _FO = "FetchOwner";
    _FR = "FilterRule";
    _FRN = "FilterRuleName";
    _FRV = "FilterRuleValue";
    _FRi = "FilterRules";
    _Fi = "Field";
    _Fo = "Format";
    _Fr = "Frequency";
    _G = "Grant";
    _GFC = "GrantFullControl";
    _GJP = "GlacierJobParameters";
    _GR = "GrantRead";
    _GRACP = "GrantReadACP";
    _GW = "GrantWrite";
    _GWACP = "GrantWriteACP";
    _Gr = "Grants";
    _Gra = "Grantee";
    _HECRE = "HttpErrorCodeReturnedEquals";
    _HN = "HostName";
    _HRC = "HttpRedirectCode";
    _I = "Id";
    _IC = "InventoryConfiguration";
    _ICL = "InventoryConfigurationList";
    _ICS = "InventoryConfigurationState";
    _ID = "IndexDocument";
    _ID_ = "ID";
    _IDn = "InventoryDestination";
    _IE = "IsEnabled";
    _IEn = "InventoryEncryption";
    _IF = "InventoryFilter";
    _IFn = "InventoryFormat";
    _IFnv = "InventoryFrequency";
    _II = "InventoryId";
    _IIOV = "InventoryIncludedObjectVersions";
    _IL = "IsLatest";
    _IM = "IfMatch";
    _IMIT = "IfMatchInitiatedTime";
    _IMLMT = "IfMatchLastModifiedTime";
    _IMS = "IfMatchSize";
    _IMSf = "IfModifiedSince";
    _INM = "IfNoneMatch";
    _IOF = "InventoryOptionalField";
    _IOV = "IncludedObjectVersions";
    _IP = "IsPublic";
    _IPA = "IgnorePublicAcls";
    _IRIP = "IsRestoreInProgress";
    _IS = "InputSerialization";
    _ISBD = "InventoryS3BucketDestination";
    _ISn = "InventorySchedule";
    _IT = "IsTruncated";
    _ITAO = "IntelligentTieringAndOperator";
    _ITAT = "IntelligentTieringAccessTier";
    _ITC = "IntelligentTieringConfiguration";
    _ITCL = "IntelligentTieringConfigurationList";
    _ITCR = "InventoryTableConfigurationResult";
    _ITCU = "InventoryTableConfigurationUpdates";
    _ITCn = "InventoryTableConfiguration";
    _ITD = "IntelligentTieringDays";
    _ITF = "IntelligentTieringFilter";
    _ITI = "IntelligentTieringId";
    _ITS = "IntelligentTieringStatus";
    _IUS = "IfUnmodifiedSince";
    _In = "Initiator";
    _Ini = "Initiated";
    _JSON = "JSON";
    _JSONI = "JSONInput";
    _JSONO = "JSONOutput";
    _JSONT = "JSONType";
    _JTC = "JournalTableConfiguration";
    _JTCR = "JournalTableConfigurationResult";
    _JTCU = "JournalTableConfigurationUpdates";
    _K = "Key";
    _KC = "KeyCount";
    _KI = "KeyId";
    _KKA = "KmsKeyArn";
    _KM = "KeyMarker";
    _KMSC = "KMSContext";
    _KMSKI = "KMSKeyId";
    _KMSMKID = "KMSMasterKeyID";
    _KPE = "KeyPrefixEquals";
    _L = "Location";
    _LC = "LocationConstraint";
    _LE = "LoggingEnabled";
    _LEi = "LifecycleExpiration";
    _LFA = "LambdaFunctionArn";
    _LFC = "LambdaFunctionConfigurations";
    _LFCa = "LambdaFunctionConfiguration";
    _LI = "LocationInfo";
    _LM = "LastModified";
    _LMT = "LastModifiedTime";
    _LNAS = "LocationNameAsString";
    _LP = "LocationPrefix";
    _LR = "LifecycleRule";
    _LRAO = "LifecycleRuleAndOperator";
    _LRF = "LifecycleRuleFilter";
    _LT = "LocationType";
    _M = "Marker";
    _MAO = "MetricsAndOperator";
    _MAS = "MaxAgeSeconds";
    _MB = "MaxBuckets";
    _MC = "MetricsConfiguration";
    _MCL = "MetricsConfigurationList";
    _MCR = "MetadataConfigurationResult";
    _MCe = "MetadataConfiguration";
    _MD = "MetadataDirective";
    _MDB = "MaxDirectoryBuckets";
    _MDf = "MfaDelete";
    _ME = "MetadataEntry";
    _MF = "MetricsFilter";
    _MFA = "MFA";
    _MFAD = "MFADelete";
    _MI = "MetricsId";
    _MK = "MaxKeys";
    _MKe = "MetadataKey";
    _MM = "MissingMeta";
    _MOS = "MpuObjectSize";
    _MP = "MaxParts";
    _MS = "MetricsStatus";
    _MTC = "MetadataTableConfiguration";
    _MTCR = "MetadataTableConfigurationResult";
    _MTEC = "MetadataTableEncryptionConfiguration";
    _MU = "MaxUploads";
    _MV = "MetadataValue";
    _Me = "Metrics";
    _Mes = "Message";
    _Mi = "Minutes";
    _Mo = "Mode";
    _N = "Name";
    _NC = "NotificationConfiguration";
    _NCF = "NotificationConfigurationFilter";
    _NCT = "NextContinuationToken";
    _ND = "NoncurrentDays";
    _NI = "NotificationId";
    _NKM = "NextKeyMarker";
    _NM = "NextMarker";
    _NNV = "NewerNoncurrentVersions";
    _NPNM = "NextPartNumberMarker";
    _NUIM = "NextUploadIdMarker";
    _NVE = "NoncurrentVersionExpiration";
    _NVIM = "NextVersionIdMarker";
    _NVT = "NoncurrentVersionTransitions";
    _NVTo = "NoncurrentVersionTransition";
    _O = "Owner";
    _OA = "ObjectAttributes";
    _OC = "OwnershipControls";
    _OCACL = "ObjectCannedACL";
    _OCR = "OwnershipControlsRule";
    _OF = "OptionalFields";
    _OI = "ObjectIdentifier";
    _OK = "ObjectKey";
    _OL = "OutputLocation";
    _OLC = "ObjectLockConfiguration";
    _OLE = "ObjectLockEnabled";
    _OLEFB = "ObjectLockEnabledForBucket";
    _OLLH = "ObjectLockLegalHold";
    _OLLHS = "ObjectLockLegalHoldStatus";
    _OLM = "ObjectLockMode";
    _OLR = "ObjectLockRetention";
    _OLRM = "ObjectLockRetentionMode";
    _OLRUD = "ObjectLockRetainUntilDate";
    _OLRb = "ObjectLockRule";
    _OO = "ObjectOwnership";
    _OOA = "OptionalObjectAttributes";
    _OOw = "OwnerOverride";
    _OP = "ObjectParts";
    _OS = "OutputSerialization";
    _OSGT = "ObjectSizeGreaterThan";
    _OSGTB = "ObjectSizeGreaterThanBytes";
    _OSLT = "ObjectSizeLessThan";
    _OSLTB = "ObjectSizeLessThanBytes";
    _OSV = "OutputSchemaVersion";
    _OSb = "ObjectSize";
    _OVI = "ObjectVersionId";
    _Ob = "Objects";
    _P = "Prefix";
    _PABC = "PublicAccessBlockConfiguration";
    _PC = "PartsCount";
    _PDS = "PartitionDateSource";
    _PI = "ParquetInput";
    _PN = "PartNumber";
    _PNM = "PartNumberMarker";
    _PP = "PartitionedPrefix";
    _Pa = "Payer";
    _Par = "Part";
    _Parq = "Parquet";
    _Part = "Parts";
    _Pe = "Permission";
    _Pr = "Protocol";
    _Pri = "Priority";
    _Q = "Quiet";
    _QA = "QueueArn";
    _QC = "QueueConfiguration";
    _QCu = "QueueConfigurations";
    _QCuo = "QuoteCharacter";
    _QEC = "QuoteEscapeCharacter";
    _QF = "QuoteFields";
    _Qu = "Queue";
    _R = "Range";
    _RART = "RedirectAllRequestsTo";
    _RC = "RequestCharged";
    _RCC = "ResponseCacheControl";
    _RCD = "ResponseContentDisposition";
    _RCE = "ResponseContentEncoding";
    _RCL = "ResponseContentLanguage";
    _RCT = "ResponseContentType";
    _RCe = "ReplicationConfiguration";
    _RD = "RecordDelimiter";
    _RE = "ResponseExpires";
    _RED = "RecordExpirationDays";
    _REDe = "RestoreExpiryDate";
    _REe = "RecordExpiration";
    _RKKID = "ReplicaKmsKeyID";
    _RKPW = "ReplaceKeyPrefixWith";
    _RKW = "ReplaceKeyWith";
    _RM = "ReplicaModifications";
    _RMS = "ReplicaModificationsStatus";
    _ROP = "RestoreOutputPath";
    _RP = "RequestPayer";
    _RPB = "RestrictPublicBuckets";
    _RPC = "RequestPaymentConfiguration";
    _RPe = "RequestProgress";
    _RR = "RequestRoute";
    _RRAO = "ReplicationRuleAndOperator";
    _RRF = "ReplicationRuleFilter";
    _RRS = "ReplicationRuleStatus";
    _RRT = "RestoreRequestType";
    _RRe = "ReplicationRule";
    _RRes = "RestoreRequest";
    _RRo = "RoutingRules";
    _RRou = "RoutingRule";
    _RS = "RenameSource";
    _RSe = "ReplicationStatus";
    _RSes = "RestoreStatus";
    _RT = "RequestToken";
    _RTS = "ReplicationTimeStatus";
    _RTV = "ReplicationTimeValue";
    _RTe = "ReplicationTime";
    _RUD = "RetainUntilDate";
    _Re = "Restore";
    _Red = "Redirect";
    _Ro = "Role";
    _Ru = "Rule";
    _Rul = "Rules";
    _S = "Status";
    _SA = "StartAfter";
    _SAK = "SecretAccessKey";
    _SAs = "SseAlgorithm";
    _SBD = "S3BucketDestination";
    _SC = "StorageClass";
    _SCA = "StorageClassAnalysis";
    _SCADE = "StorageClassAnalysisDataExport";
    _SCASV = "StorageClassAnalysisSchemaVersion";
    _SCt = "StatusCode";
    _SDV = "SkipDestinationValidation";
    _SIM = "SourceIfMatch";
    _SIMS = "SourceIfModifiedSince";
    _SINM = "SourceIfNoneMatch";
    _SIUS = "SourceIfUnmodifiedSince";
    _SK = "SSE-KMS";
    _SKEO = "SseKmsEncryptedObjects";
    _SKEOS = "SseKmsEncryptedObjectsStatus";
    _SKF = "S3KeyFilter";
    _SKe = "S3Key";
    _SL = "S3Location";
    _SM = "SessionMode";
    _SOCR = "SelectObjectContentRequest";
    _SP = "SelectParameters";
    _SPi = "SimplePrefix";
    _SR = "ScanRange";
    _SS = "SSE-S3";
    _SSC = "SourceSelectionCriteria";
    _SSE = "ServerSideEncryption";
    _SSEA = "SSEAlgorithm";
    _SSEBD = "ServerSideEncryptionByDefault";
    _SSEC = "ServerSideEncryptionConfiguration";
    _SSECA = "SSECustomerAlgorithm";
    _SSECK = "SSECustomerKey";
    _SSECKMD = "SSECustomerKeyMD5";
    _SSEKMS = "SSEKMS";
    _SSEKMSEC = "SSEKMSEncryptionContext";
    _SSEKMSKI = "SSEKMSKeyId";
    _SSER = "ServerSideEncryptionRule";
    _SSES = "SSES3";
    _ST = "SessionToken";
    _STBA = "S3TablesBucketArn";
    _STD = "S3TablesDestination";
    _STDR = "S3TablesDestinationResult";
    _STN = "S3TablesName";
    _S_ = "S3";
    _Sc = "Schedule";
    _Se = "Setting";
    _Si = "Size";
    _St = "Start";
    _Su = "Suffix";
    _T = "Tagging";
    _TA = "TopicArn";
    _TAa = "TableArn";
    _TB = "TargetBucket";
    _TBA = "TableBucketArn";
    _TBT = "TableBucketType";
    _TC = "TagCount";
    _TCo = "TopicConfiguration";
    _TCop = "TopicConfigurations";
    _TD = "TaggingDirective";
    _TDMOS = "TransitionDefaultMinimumObjectSize";
    _TG = "TargetGrants";
    _TGa = "TargetGrant";
    _TN = "TableName";
    _TNa = "TableNamespace";
    _TOKF = "TargetObjectKeyFormat";
    _TP = "TargetPrefix";
    _TPC = "TotalPartsCount";
    _TS = "TagSet";
    _TSA = "TableSseAlgorithm";
    _TSC = "TransitionStorageClass";
    _TSa = "TableStatus";
    _Ta = "Tag";
    _Tag = "Tags";
    _Ti = "Tier";
    _Tie = "Tierings";
    _Tier = "Tiering";
    _Tim = "Time";
    _To = "Token";
    _Top = "Topic";
    _Tr = "Transitions";
    _Tra = "Transition";
    _Ty = "Type";
    _U = "Upload";
    _UI = "UploadId";
    _UIM = "UploadIdMarker";
    _UM = "UserMetadata";
    _URI = "URI";
    _Up = "Uploads";
    _V = "Version";
    _VC = "VersionCount";
    _VCe = "VersioningConfiguration";
    _VI = "VersionId";
    _VIM = "VersionIdMarker";
    _Va = "Value";
    _Ve = "Versions";
    _WC = "WebsiteConfiguration";
    _WOB = "WriteOffsetBytes";
    _WRL = "WebsiteRedirectLocation";
    _Y = "Years";
    _a = "analytics";
    _ac = "accelerate";
    _acl = "acl";
    _ar = "accept-ranges";
    _at = "attributes";
    _br = "bucket-region";
    _c = "cors";
    _cc = "cache-control";
    _cd = "content-disposition";
    _ce = "content-encoding";
    _cl = "content-language";
    _cl_ = "content-length";
    _cm = "content-md5";
    _cr = "content-range";
    _ct = "content-type";
    _ct_ = "continuation-token";
    _d = "delete";
    _de = "delimiter";
    _e = "expires";
    _en = "encryption";
    _et = "encoding-type";
    _eta = "etag";
    _ex = "expiresstring";
    _fo = "fetch-owner";
    _i = "id";
    _im = "if-match";
    _ims = "if-modified-since";
    _in = "inventory";
    _inm = "if-none-match";
    _it = "intelligent-tiering";
    _ius = "if-unmodified-since";
    _km = "key-marker";
    _l = "lifecycle";
    _lh = "legal-hold";
    _lm = "last-modified";
    _lo = "location";
    _log = "logging";
    _lt = "list-type";
    _m = "metrics";
    _mC = "metadataConfiguration";
    _mIT = "metadataInventoryTable";
    _mJT = "metadataJournalTable";
    _mT = "metadataTable";
    _ma = "marker";
    _mb = "max-buckets";
    _mdb = "max-directory-buckets";
    _me = "member";
    _mk = "max-keys";
    _mp = "max-parts";
    _mu = "max-uploads";
    _n = "notification";
    _oC = "ownershipControls";
    _ol = "object-lock";
    _p = "policy";
    _pAB = "publicAccessBlock";
    _pN = "partNumber";
    _pS = "policyStatus";
    _pnm = "part-number-marker";
    _pr = "prefix";
    _r = "replication";
    _rO = "renameObject";
    _rP = "requestPayment";
    _ra = "range";
    _rcc = "response-cache-control";
    _rcd = "response-content-disposition";
    _rce = "response-content-encoding";
    _rcl = "response-content-language";
    _rct = "response-content-type";
    _re = "response-expires";
    _res = "restore";
    _ret = "retention";
    _s = "session";
    _sa = "start-after";
    _se = "select";
    _st = "select-type";
    _t = "tagging";
    _to = "torrent";
    _u = "uploads";
    _uI = "uploadId";
    _uim = "upload-id-marker";
    _v = "versioning";
    _vI = "versionId";
    _ve = '<?xml version="1.0" encoding="UTF-8"?>';
    _ver = "versions";
    _vim = "version-id-marker";
    _w = "website";
    _x = "xsi:type";
    _xaa = "x-amz-acl";
    _xaad = "x-amz-abort-date";
    _xaapa = "x-amz-access-point-alias";
    _xaari = "x-amz-abort-rule-id";
    _xaas = "x-amz-archive-status";
    _xaba = "x-amz-bucket-arn";
    _xabgr = "x-amz-bypass-governance-retention";
    _xabln = "x-amz-bucket-location-name";
    _xablt = "x-amz-bucket-location-type";
    _xabole = "x-amz-bucket-object-lock-enabled";
    _xabolt = "x-amz-bucket-object-lock-token";
    _xabr = "x-amz-bucket-region";
    _xaca = "x-amz-checksum-algorithm";
    _xacc = "x-amz-checksum-crc32";
    _xacc_ = "x-amz-checksum-crc32c";
    _xacc__ = "x-amz-checksum-crc64nvme";
    _xacm = "x-amz-checksum-mode";
    _xacrsba = "x-amz-confirm-remove-self-bucket-access";
    _xacs = "x-amz-checksum-sha1";
    _xacs_ = "x-amz-checksum-sha256";
    _xacs__ = "x-amz-copy-source";
    _xacsim = "x-amz-copy-source-if-match";
    _xacsims = "x-amz-copy-source-if-modified-since";
    _xacsinm = "x-amz-copy-source-if-none-match";
    _xacsius = "x-amz-copy-source-if-unmodified-since";
    _xacsm = "x-amz-create-session-mode";
    _xacsr = "x-amz-copy-source-range";
    _xacssseca = "x-amz-copy-source-server-side-encryption-customer-algorithm";
    _xacssseck = "x-amz-copy-source-server-side-encryption-customer-key";
    _xacssseckm = "x-amz-copy-source-server-side-encryption-customer-key-md5";
    _xacsvi = "x-amz-copy-source-version-id";
    _xact = "x-amz-checksum-type";
    _xact_ = "x-amz-client-token";
    _xadm = "x-amz-delete-marker";
    _xae = "x-amz-expiration";
    _xaebo = "x-amz-expected-bucket-owner";
    _xafec = "x-amz-fwd-error-code";
    _xafem = "x-amz-fwd-error-message";
    _xafhar = "x-amz-fwd-header-accept-ranges";
    _xafhcc = "x-amz-fwd-header-cache-control";
    _xafhcd = "x-amz-fwd-header-content-disposition";
    _xafhce = "x-amz-fwd-header-content-encoding";
    _xafhcl = "x-amz-fwd-header-content-language";
    _xafhcr = "x-amz-fwd-header-content-range";
    _xafhct = "x-amz-fwd-header-content-type";
    _xafhe = "x-amz-fwd-header-etag";
    _xafhe_ = "x-amz-fwd-header-expires";
    _xafhlm = "x-amz-fwd-header-last-modified";
    _xafhxacc = "x-amz-fwd-header-x-amz-checksum-crc32";
    _xafhxacc_ = "x-amz-fwd-header-x-amz-checksum-crc32c";
    _xafhxacc__ = "x-amz-fwd-header-x-amz-checksum-crc64nvme";
    _xafhxacs = "x-amz-fwd-header-x-amz-checksum-sha1";
    _xafhxacs_ = "x-amz-fwd-header-x-amz-checksum-sha256";
    _xafhxadm = "x-amz-fwd-header-x-amz-delete-marker";
    _xafhxae = "x-amz-fwd-header-x-amz-expiration";
    _xafhxamm = "x-amz-fwd-header-x-amz-missing-meta";
    _xafhxampc = "x-amz-fwd-header-x-amz-mp-parts-count";
    _xafhxaollh = "x-amz-fwd-header-x-amz-object-lock-legal-hold";
    _xafhxaolm = "x-amz-fwd-header-x-amz-object-lock-mode";
    _xafhxaolrud = "x-amz-fwd-header-x-amz-object-lock-retain-until-date";
    _xafhxar = "x-amz-fwd-header-x-amz-restore";
    _xafhxarc = "x-amz-fwd-header-x-amz-request-charged";
    _xafhxars = "x-amz-fwd-header-x-amz-replication-status";
    _xafhxasc = "x-amz-fwd-header-x-amz-storage-class";
    _xafhxasse = "x-amz-fwd-header-x-amz-server-side-encryption";
    _xafhxasseakki = "x-amz-fwd-header-x-amz-server-side-encryption-aws-kms-key-id";
    _xafhxassebke = "x-amz-fwd-header-x-amz-server-side-encryption-bucket-key-enabled";
    _xafhxasseca = "x-amz-fwd-header-x-amz-server-side-encryption-customer-algorithm";
    _xafhxasseckm = "x-amz-fwd-header-x-amz-server-side-encryption-customer-key-md5";
    _xafhxatc = "x-amz-fwd-header-x-amz-tagging-count";
    _xafhxavi = "x-amz-fwd-header-x-amz-version-id";
    _xafs = "x-amz-fwd-status";
    _xagfc = "x-amz-grant-full-control";
    _xagr = "x-amz-grant-read";
    _xagra = "x-amz-grant-read-acp";
    _xagw = "x-amz-grant-write";
    _xagwa = "x-amz-grant-write-acp";
    _xaimit = "x-amz-if-match-initiated-time";
    _xaimlmt = "x-amz-if-match-last-modified-time";
    _xaims = "x-amz-if-match-size";
    _xam = "x-amz-mfa";
    _xamd = "x-amz-metadata-directive";
    _xamm = "x-amz-missing-meta";
    _xamos = "x-amz-mp-object-size";
    _xamp = "x-amz-max-parts";
    _xampc = "x-amz-mp-parts-count";
    _xaoa = "x-amz-object-attributes";
    _xaollh = "x-amz-object-lock-legal-hold";
    _xaolm = "x-amz-object-lock-mode";
    _xaolrud = "x-amz-object-lock-retain-until-date";
    _xaoo = "x-amz-object-ownership";
    _xaooa = "x-amz-optional-object-attributes";
    _xaos = "x-amz-object-size";
    _xapnm = "x-amz-part-number-marker";
    _xar = "x-amz-restore";
    _xarc = "x-amz-request-charged";
    _xarop = "x-amz-restore-output-path";
    _xarp = "x-amz-request-payer";
    _xarr = "x-amz-request-route";
    _xars = "x-amz-rename-source";
    _xars_ = "x-amz-replication-status";
    _xarsim = "x-amz-rename-source-if-match";
    _xarsims = "x-amz-rename-source-if-modified-since";
    _xarsinm = "x-amz-rename-source-if-none-match";
    _xarsius = "x-amz-rename-source-if-unmodified-since";
    _xart = "x-amz-request-token";
    _xasc = "x-amz-storage-class";
    _xasca = "x-amz-sdk-checksum-algorithm";
    _xasdv = "x-amz-skip-destination-validation";
    _xasebo = "x-amz-source-expected-bucket-owner";
    _xasse = "x-amz-server-side-encryption";
    _xasseakki = "x-amz-server-side-encryption-aws-kms-key-id";
    _xassebke = "x-amz-server-side-encryption-bucket-key-enabled";
    _xassec = "x-amz-server-side-encryption-context";
    _xasseca = "x-amz-server-side-encryption-customer-algorithm";
    _xasseck = "x-amz-server-side-encryption-customer-key";
    _xasseckm = "x-amz-server-side-encryption-customer-key-md5";
    _xat = "x-amz-tagging";
    _xatc = "x-amz-tagging-count";
    _xatd = "x-amz-tagging-directive";
    _xatdmos = "x-amz-transition-default-minimum-object-size";
    _xavi = "x-amz-version-id";
    _xawob = "x-amz-write-offset-bytes";
    _xawrl = "x-amz-website-redirect-location";
    _xi = "x-id";
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/CreateSessionCommand.js
var CreateSessionCommand;
var init_CreateSessionCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/CreateSessionCommand.js"() {
    "use strict";
    init_dist_es29();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_models_0();
    init_Aws_restXml();
    CreateSessionCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      DisableS3ExpressSessionAuth: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "CreateSession", {}).n("S3Client", "CreateSessionCommand").f(CreateSessionRequestFilterSensitiveLog, CreateSessionOutputFilterSensitiveLog).ser(se_CreateSessionCommand).de(de_CreateSessionCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/package.json
var package_default;
var init_package = __esm({
  "node_modules/@aws-sdk/client-s3/package.json"() {
    package_default = {
      name: "@aws-sdk/client-s3",
      description: "AWS SDK for JavaScript S3 Client for Node.js, Browser and React Native",
      version: "3.927.0",
      scripts: {
        build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
        "build:cjs": "node ../../scripts/compilation/inline client-s3",
        "build:es": "tsc -p tsconfig.es.json",
        "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
        "build:types": "tsc -p tsconfig.types.json",
        "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
        clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
        "extract:docs": "api-extractor run --local",
        "generate:client": "node ../../scripts/generate-clients/single-service --solo s3",
        test: "yarn g:vitest run",
        "test:browser": "node ./test/browser-build/esbuild && yarn g:vitest run -c vitest.config.browser.mts",
        "test:browser:watch": "node ./test/browser-build/esbuild && yarn g:vitest watch -c vitest.config.browser.mts",
        "test:e2e": "yarn g:vitest run -c vitest.config.e2e.mts && yarn test:browser",
        "test:e2e:watch": "yarn g:vitest watch -c vitest.config.e2e.mts",
        "test:integration": "yarn g:vitest run -c vitest.config.integ.mts",
        "test:integration:watch": "yarn g:vitest watch -c vitest.config.integ.mts",
        "test:watch": "yarn g:vitest watch"
      },
      main: "./dist-cjs/index.js",
      types: "./dist-types/index.d.ts",
      module: "./dist-es/index.js",
      sideEffects: false,
      dependencies: {
        "@aws-crypto/sha1-browser": "5.2.0",
        "@aws-crypto/sha256-browser": "5.2.0",
        "@aws-crypto/sha256-js": "5.2.0",
        "@aws-sdk/core": "3.927.0",
        "@aws-sdk/credential-provider-node": "3.927.0",
        "@aws-sdk/middleware-bucket-endpoint": "3.922.0",
        "@aws-sdk/middleware-expect-continue": "3.922.0",
        "@aws-sdk/middleware-flexible-checksums": "3.927.0",
        "@aws-sdk/middleware-host-header": "3.922.0",
        "@aws-sdk/middleware-location-constraint": "3.922.0",
        "@aws-sdk/middleware-logger": "3.922.0",
        "@aws-sdk/middleware-recursion-detection": "3.922.0",
        "@aws-sdk/middleware-sdk-s3": "3.927.0",
        "@aws-sdk/middleware-ssec": "3.922.0",
        "@aws-sdk/middleware-user-agent": "3.927.0",
        "@aws-sdk/region-config-resolver": "3.925.0",
        "@aws-sdk/signature-v4-multi-region": "3.927.0",
        "@aws-sdk/types": "3.922.0",
        "@aws-sdk/util-endpoints": "3.922.0",
        "@aws-sdk/util-user-agent-browser": "3.922.0",
        "@aws-sdk/util-user-agent-node": "3.927.0",
        "@aws-sdk/xml-builder": "3.921.0",
        "@smithy/config-resolver": "^4.4.2",
        "@smithy/core": "^3.17.2",
        "@smithy/eventstream-serde-browser": "^4.2.4",
        "@smithy/eventstream-serde-config-resolver": "^4.3.4",
        "@smithy/eventstream-serde-node": "^4.2.4",
        "@smithy/fetch-http-handler": "^5.3.5",
        "@smithy/hash-blob-browser": "^4.2.5",
        "@smithy/hash-node": "^4.2.4",
        "@smithy/hash-stream-node": "^4.2.4",
        "@smithy/invalid-dependency": "^4.2.4",
        "@smithy/md5-js": "^4.2.4",
        "@smithy/middleware-content-length": "^4.2.4",
        "@smithy/middleware-endpoint": "^4.3.6",
        "@smithy/middleware-retry": "^4.4.6",
        "@smithy/middleware-serde": "^4.2.4",
        "@smithy/middleware-stack": "^4.2.4",
        "@smithy/node-config-provider": "^4.3.4",
        "@smithy/node-http-handler": "^4.4.4",
        "@smithy/protocol-http": "^5.3.4",
        "@smithy/smithy-client": "^4.9.2",
        "@smithy/types": "^4.8.1",
        "@smithy/url-parser": "^4.2.4",
        "@smithy/util-base64": "^4.3.0",
        "@smithy/util-body-length-browser": "^4.2.0",
        "@smithy/util-body-length-node": "^4.2.1",
        "@smithy/util-defaults-mode-browser": "^4.3.5",
        "@smithy/util-defaults-mode-node": "^4.2.8",
        "@smithy/util-endpoints": "^3.2.4",
        "@smithy/util-middleware": "^4.2.4",
        "@smithy/util-retry": "^4.2.4",
        "@smithy/util-stream": "^4.5.5",
        "@smithy/util-utf8": "^4.2.0",
        "@smithy/util-waiter": "^4.2.4",
        "@smithy/uuid": "^1.1.0",
        tslib: "^2.6.2"
      },
      devDependencies: {
        "@aws-sdk/signature-v4-crt": "3.927.0",
        "@tsconfig/node18": "18.2.4",
        "@types/node": "^18.19.69",
        concurrently: "7.0.0",
        "downlevel-dts": "0.10.1",
        rimraf: "3.0.2",
        typescript: "~5.8.3"
      },
      engines: {
        node: ">=18.0.0"
      },
      typesVersions: {
        "<4.0": {
          "dist-types/*": [
            "dist-types/ts3.4/*"
          ]
        }
      },
      files: [
        "dist-*/**"
      ],
      author: {
        name: "AWS SDK for JavaScript Team",
        url: "https://aws.amazon.com/javascript/"
      },
      license: "Apache-2.0",
      browser: {
        "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
      },
      "react-native": {
        "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
      },
      homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-s3",
      repository: {
        type: "git",
        url: "https://github.com/aws/aws-sdk-js-v3.git",
        directory: "clients/client-s3"
      }
    };
  }
});

// node_modules/@aws-crypto/sha1-browser/node_modules/@smithy/util-utf8/dist-es/fromUtf8.browser.js
var fromUtf84;
var init_fromUtf8_browser3 = __esm({
  "node_modules/@aws-crypto/sha1-browser/node_modules/@smithy/util-utf8/dist-es/fromUtf8.browser.js"() {
    "use strict";
    fromUtf84 = (input) => new TextEncoder().encode(input);
  }
});

// node_modules/@aws-crypto/sha1-browser/node_modules/@smithy/util-utf8/dist-es/toUint8Array.js
var init_toUint8Array3 = __esm({
  "node_modules/@aws-crypto/sha1-browser/node_modules/@smithy/util-utf8/dist-es/toUint8Array.js"() {
    "use strict";
    init_fromUtf8_browser3();
  }
});

// node_modules/@aws-crypto/sha1-browser/node_modules/@smithy/util-utf8/dist-es/toUtf8.browser.js
var init_toUtf8_browser3 = __esm({
  "node_modules/@aws-crypto/sha1-browser/node_modules/@smithy/util-utf8/dist-es/toUtf8.browser.js"() {
    "use strict";
  }
});

// node_modules/@aws-crypto/sha1-browser/node_modules/@smithy/util-utf8/dist-es/index.js
var init_dist_es43 = __esm({
  "node_modules/@aws-crypto/sha1-browser/node_modules/@smithy/util-utf8/dist-es/index.js"() {
    "use strict";
    init_fromUtf8_browser3();
    init_toUint8Array3();
    init_toUtf8_browser3();
  }
});

// node_modules/@aws-crypto/sha1-browser/build/module/isEmptyData.js
function isEmptyData2(data) {
  if (typeof data === "string") {
    return data.length === 0;
  }
  return data.byteLength === 0;
}
var init_isEmptyData2 = __esm({
  "node_modules/@aws-crypto/sha1-browser/build/module/isEmptyData.js"() {
    "use strict";
  }
});

// node_modules/@aws-crypto/sha1-browser/build/module/constants.js
var SHA_1_HASH, SHA_1_HMAC_ALGO, EMPTY_DATA_SHA_1;
var init_constants8 = __esm({
  "node_modules/@aws-crypto/sha1-browser/build/module/constants.js"() {
    "use strict";
    SHA_1_HASH = { name: "SHA-1" };
    SHA_1_HMAC_ALGO = {
      name: "HMAC",
      hash: SHA_1_HASH
    };
    EMPTY_DATA_SHA_1 = new Uint8Array([
      218,
      57,
      163,
      238,
      94,
      107,
      75,
      13,
      50,
      85,
      191,
      239,
      149,
      96,
      24,
      144,
      175,
      216,
      7,
      9
    ]);
  }
});

// node_modules/@aws-sdk/util-locate-window/dist-es/index.js
function locateWindow() {
  if (typeof window !== "undefined") {
    return window;
  } else if (typeof self !== "undefined") {
    return self;
  }
  return fallbackWindow;
}
var fallbackWindow;
var init_dist_es44 = __esm({
  "node_modules/@aws-sdk/util-locate-window/dist-es/index.js"() {
    "use strict";
    fallbackWindow = {};
  }
});

// node_modules/@aws-crypto/sha1-browser/build/module/webCryptoSha1.js
function convertToBuffer2(data) {
  if (typeof data === "string") {
    return fromUtf84(data);
  }
  if (ArrayBuffer.isView(data)) {
    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
  }
  return new Uint8Array(data);
}
var Sha1;
var init_webCryptoSha1 = __esm({
  "node_modules/@aws-crypto/sha1-browser/build/module/webCryptoSha1.js"() {
    "use strict";
    init_dist_es43();
    init_isEmptyData2();
    init_constants8();
    init_dist_es44();
    Sha1 = /** @class */
    function() {
      function Sha13(secret) {
        this.toHash = new Uint8Array(0);
        if (secret !== void 0) {
          this.key = new Promise(function(resolve, reject) {
            locateWindow().crypto.subtle.importKey("raw", convertToBuffer2(secret), SHA_1_HMAC_ALGO, false, ["sign"]).then(resolve, reject);
          });
          this.key.catch(function() {
          });
        }
      }
      Sha13.prototype.update = function(data) {
        if (isEmptyData2(data)) {
          return;
        }
        var update = convertToBuffer2(data);
        var typedArray = new Uint8Array(this.toHash.byteLength + update.byteLength);
        typedArray.set(this.toHash, 0);
        typedArray.set(update, this.toHash.byteLength);
        this.toHash = typedArray;
      };
      Sha13.prototype.digest = function() {
        var _this = this;
        if (this.key) {
          return this.key.then(function(key) {
            return locateWindow().crypto.subtle.sign(SHA_1_HMAC_ALGO, key, _this.toHash).then(function(data) {
              return new Uint8Array(data);
            });
          });
        }
        if (isEmptyData2(this.toHash)) {
          return Promise.resolve(EMPTY_DATA_SHA_1);
        }
        return Promise.resolve().then(function() {
          return locateWindow().crypto.subtle.digest(SHA_1_HASH, _this.toHash);
        }).then(function(data) {
          return Promise.resolve(new Uint8Array(data));
        });
      };
      Sha13.prototype.reset = function() {
        this.toHash = new Uint8Array(0);
      };
      return Sha13;
    }();
  }
});

// node_modules/@aws-crypto/supports-web-crypto/build/module/supportsWebCrypto.js
function supportsWebCrypto(window2) {
  if (supportsSecureRandom(window2) && typeof window2.crypto.subtle === "object") {
    var subtle = window2.crypto.subtle;
    return supportsSubtleCrypto(subtle);
  }
  return false;
}
function supportsSecureRandom(window2) {
  if (typeof window2 === "object" && typeof window2.crypto === "object") {
    var getRandomValues = window2.crypto.getRandomValues;
    return typeof getRandomValues === "function";
  }
  return false;
}
function supportsSubtleCrypto(subtle) {
  return subtle && subtleCryptoMethods.every(function(methodName) {
    return typeof subtle[methodName] === "function";
  });
}
var subtleCryptoMethods;
var init_supportsWebCrypto = __esm({
  "node_modules/@aws-crypto/supports-web-crypto/build/module/supportsWebCrypto.js"() {
    "use strict";
    subtleCryptoMethods = [
      "decrypt",
      "digest",
      "encrypt",
      "exportKey",
      "generateKey",
      "importKey",
      "sign",
      "verify"
    ];
  }
});

// node_modules/@aws-crypto/supports-web-crypto/build/module/index.js
var init_module4 = __esm({
  "node_modules/@aws-crypto/supports-web-crypto/build/module/index.js"() {
    "use strict";
    init_supportsWebCrypto();
  }
});

// node_modules/@aws-crypto/sha1-browser/build/module/crossPlatformSha1.js
var Sha12;
var init_crossPlatformSha1 = __esm({
  "node_modules/@aws-crypto/sha1-browser/build/module/crossPlatformSha1.js"() {
    "use strict";
    init_webCryptoSha1();
    init_module4();
    init_dist_es44();
    init_module();
    Sha12 = /** @class */
    function() {
      function Sha13(secret) {
        if (supportsWebCrypto(locateWindow())) {
          this.hash = new Sha1(secret);
        } else {
          throw new Error("SHA1 not supported");
        }
      }
      Sha13.prototype.update = function(data, encoding) {
        this.hash.update(convertToBuffer(data));
      };
      Sha13.prototype.digest = function() {
        return this.hash.digest();
      };
      Sha13.prototype.reset = function() {
        this.hash.reset();
      };
      return Sha13;
    }();
  }
});

// node_modules/@aws-crypto/sha1-browser/build/module/index.js
var init_module5 = __esm({
  "node_modules/@aws-crypto/sha1-browser/build/module/index.js"() {
    "use strict";
    init_crossPlatformSha1();
    init_webCryptoSha1();
  }
});

// node_modules/@aws-crypto/sha256-browser/build/module/constants.js
var SHA_256_HASH, SHA_256_HMAC_ALGO, EMPTY_DATA_SHA_256;
var init_constants9 = __esm({
  "node_modules/@aws-crypto/sha256-browser/build/module/constants.js"() {
    "use strict";
    SHA_256_HASH = { name: "SHA-256" };
    SHA_256_HMAC_ALGO = {
      name: "HMAC",
      hash: SHA_256_HASH
    };
    EMPTY_DATA_SHA_256 = new Uint8Array([
      227,
      176,
      196,
      66,
      152,
      252,
      28,
      20,
      154,
      251,
      244,
      200,
      153,
      111,
      185,
      36,
      39,
      174,
      65,
      228,
      100,
      155,
      147,
      76,
      164,
      149,
      153,
      27,
      120,
      82,
      184,
      85
    ]);
  }
});

// node_modules/@aws-crypto/sha256-browser/build/module/webCryptoSha256.js
var Sha256;
var init_webCryptoSha256 = __esm({
  "node_modules/@aws-crypto/sha256-browser/build/module/webCryptoSha256.js"() {
    "use strict";
    init_module();
    init_constants9();
    init_dist_es44();
    Sha256 = /** @class */
    function() {
      function Sha2564(secret) {
        this.toHash = new Uint8Array(0);
        this.secret = secret;
        this.reset();
      }
      Sha2564.prototype.update = function(data) {
        if (isEmptyData(data)) {
          return;
        }
        var update = convertToBuffer(data);
        var typedArray = new Uint8Array(this.toHash.byteLength + update.byteLength);
        typedArray.set(this.toHash, 0);
        typedArray.set(update, this.toHash.byteLength);
        this.toHash = typedArray;
      };
      Sha2564.prototype.digest = function() {
        var _this = this;
        if (this.key) {
          return this.key.then(function(key) {
            return locateWindow().crypto.subtle.sign(SHA_256_HMAC_ALGO, key, _this.toHash).then(function(data) {
              return new Uint8Array(data);
            });
          });
        }
        if (isEmptyData(this.toHash)) {
          return Promise.resolve(EMPTY_DATA_SHA_256);
        }
        return Promise.resolve().then(function() {
          return locateWindow().crypto.subtle.digest(SHA_256_HASH, _this.toHash);
        }).then(function(data) {
          return Promise.resolve(new Uint8Array(data));
        });
      };
      Sha2564.prototype.reset = function() {
        var _this = this;
        this.toHash = new Uint8Array(0);
        if (this.secret && this.secret !== void 0) {
          this.key = new Promise(function(resolve, reject) {
            locateWindow().crypto.subtle.importKey("raw", convertToBuffer(_this.secret), SHA_256_HMAC_ALGO, false, ["sign"]).then(resolve, reject);
          });
          this.key.catch(function() {
          });
        }
      };
      return Sha2564;
    }();
  }
});

// node_modules/@aws-crypto/sha256-js/build/module/constants.js
var BLOCK_SIZE, DIGEST_LENGTH, KEY, INIT, MAX_HASHABLE_LENGTH;
var init_constants10 = __esm({
  "node_modules/@aws-crypto/sha256-js/build/module/constants.js"() {
    "use strict";
    BLOCK_SIZE = 64;
    DIGEST_LENGTH = 32;
    KEY = new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    INIT = [
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ];
    MAX_HASHABLE_LENGTH = Math.pow(2, 53) - 1;
  }
});

// node_modules/@aws-crypto/sha256-js/build/module/RawSha256.js
var RawSha256;
var init_RawSha256 = __esm({
  "node_modules/@aws-crypto/sha256-js/build/module/RawSha256.js"() {
    "use strict";
    init_constants10();
    RawSha256 = /** @class */
    function() {
      function RawSha2562() {
        this.state = Int32Array.from(INIT);
        this.temp = new Int32Array(64);
        this.buffer = new Uint8Array(64);
        this.bufferLength = 0;
        this.bytesHashed = 0;
        this.finished = false;
      }
      RawSha2562.prototype.update = function(data) {
        if (this.finished) {
          throw new Error("Attempted to update an already finished hash.");
        }
        var position = 0;
        var byteLength = data.byteLength;
        this.bytesHashed += byteLength;
        if (this.bytesHashed * 8 > MAX_HASHABLE_LENGTH) {
          throw new Error("Cannot hash more than 2^53 - 1 bits");
        }
        while (byteLength > 0) {
          this.buffer[this.bufferLength++] = data[position++];
          byteLength--;
          if (this.bufferLength === BLOCK_SIZE) {
            this.hashBuffer();
            this.bufferLength = 0;
          }
        }
      };
      RawSha2562.prototype.digest = function() {
        if (!this.finished) {
          var bitsHashed = this.bytesHashed * 8;
          var bufferView = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.buffer.byteLength);
          var undecoratedLength = this.bufferLength;
          bufferView.setUint8(this.bufferLength++, 128);
          if (undecoratedLength % BLOCK_SIZE >= BLOCK_SIZE - 8) {
            for (var i2 = this.bufferLength; i2 < BLOCK_SIZE; i2++) {
              bufferView.setUint8(i2, 0);
            }
            this.hashBuffer();
            this.bufferLength = 0;
          }
          for (var i2 = this.bufferLength; i2 < BLOCK_SIZE - 8; i2++) {
            bufferView.setUint8(i2, 0);
          }
          bufferView.setUint32(BLOCK_SIZE - 8, Math.floor(bitsHashed / 4294967296), true);
          bufferView.setUint32(BLOCK_SIZE - 4, bitsHashed);
          this.hashBuffer();
          this.finished = true;
        }
        var out = new Uint8Array(DIGEST_LENGTH);
        for (var i2 = 0; i2 < 8; i2++) {
          out[i2 * 4] = this.state[i2] >>> 24 & 255;
          out[i2 * 4 + 1] = this.state[i2] >>> 16 & 255;
          out[i2 * 4 + 2] = this.state[i2] >>> 8 & 255;
          out[i2 * 4 + 3] = this.state[i2] >>> 0 & 255;
        }
        return out;
      };
      RawSha2562.prototype.hashBuffer = function() {
        var _a2 = this, buffer = _a2.buffer, state = _a2.state;
        var state0 = state[0], state1 = state[1], state2 = state[2], state3 = state[3], state4 = state[4], state5 = state[5], state6 = state[6], state7 = state[7];
        for (var i2 = 0; i2 < BLOCK_SIZE; i2++) {
          if (i2 < 16) {
            this.temp[i2] = (buffer[i2 * 4] & 255) << 24 | (buffer[i2 * 4 + 1] & 255) << 16 | (buffer[i2 * 4 + 2] & 255) << 8 | buffer[i2 * 4 + 3] & 255;
          } else {
            var u2 = this.temp[i2 - 2];
            var t1_1 = (u2 >>> 17 | u2 << 15) ^ (u2 >>> 19 | u2 << 13) ^ u2 >>> 10;
            u2 = this.temp[i2 - 15];
            var t2_1 = (u2 >>> 7 | u2 << 25) ^ (u2 >>> 18 | u2 << 14) ^ u2 >>> 3;
            this.temp[i2] = (t1_1 + this.temp[i2 - 7] | 0) + (t2_1 + this.temp[i2 - 16] | 0);
          }
          var t1 = (((state4 >>> 6 | state4 << 26) ^ (state4 >>> 11 | state4 << 21) ^ (state4 >>> 25 | state4 << 7)) + (state4 & state5 ^ ~state4 & state6) | 0) + (state7 + (KEY[i2] + this.temp[i2] | 0) | 0) | 0;
          var t2 = ((state0 >>> 2 | state0 << 30) ^ (state0 >>> 13 | state0 << 19) ^ (state0 >>> 22 | state0 << 10)) + (state0 & state1 ^ state0 & state2 ^ state1 & state2) | 0;
          state7 = state6;
          state6 = state5;
          state5 = state4;
          state4 = state3 + t1 | 0;
          state3 = state2;
          state2 = state1;
          state1 = state0;
          state0 = t1 + t2 | 0;
        }
        state[0] += state0;
        state[1] += state1;
        state[2] += state2;
        state[3] += state3;
        state[4] += state4;
        state[5] += state5;
        state[6] += state6;
        state[7] += state7;
      };
      return RawSha2562;
    }();
  }
});

// node_modules/@aws-crypto/sha256-js/build/module/jsSha256.js
function bufferFromSecret(secret) {
  var input = convertToBuffer(secret);
  if (input.byteLength > BLOCK_SIZE) {
    var bufferHash = new RawSha256();
    bufferHash.update(input);
    input = bufferHash.digest();
  }
  var buffer = new Uint8Array(BLOCK_SIZE);
  buffer.set(input);
  return buffer;
}
var Sha2562;
var init_jsSha256 = __esm({
  "node_modules/@aws-crypto/sha256-js/build/module/jsSha256.js"() {
    "use strict";
    init_tslib_es6();
    init_constants10();
    init_RawSha256();
    init_module();
    Sha2562 = /** @class */
    function() {
      function Sha2564(secret) {
        this.secret = secret;
        this.hash = new RawSha256();
        this.reset();
      }
      Sha2564.prototype.update = function(toHash) {
        if (isEmptyData(toHash) || this.error) {
          return;
        }
        try {
          this.hash.update(convertToBuffer(toHash));
        } catch (e2) {
          this.error = e2;
        }
      };
      Sha2564.prototype.digestSync = function() {
        if (this.error) {
          throw this.error;
        }
        if (this.outer) {
          if (!this.outer.finished) {
            this.outer.update(this.hash.digest());
          }
          return this.outer.digest();
        }
        return this.hash.digest();
      };
      Sha2564.prototype.digest = function() {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a2) {
            return [2, this.digestSync()];
          });
        });
      };
      Sha2564.prototype.reset = function() {
        this.hash = new RawSha256();
        if (this.secret) {
          this.outer = new RawSha256();
          var inner = bufferFromSecret(this.secret);
          var outer = new Uint8Array(BLOCK_SIZE);
          outer.set(inner);
          for (var i2 = 0; i2 < BLOCK_SIZE; i2++) {
            inner[i2] ^= 54;
            outer[i2] ^= 92;
          }
          this.hash.update(inner);
          this.outer.update(outer);
          for (var i2 = 0; i2 < inner.byteLength; i2++) {
            inner[i2] = 0;
          }
        }
      };
      return Sha2564;
    }();
  }
});

// node_modules/@aws-crypto/sha256-js/build/module/index.js
var init_module6 = __esm({
  "node_modules/@aws-crypto/sha256-js/build/module/index.js"() {
    "use strict";
    init_jsSha256();
  }
});

// node_modules/@aws-crypto/sha256-browser/build/module/crossPlatformSha256.js
var Sha2563;
var init_crossPlatformSha256 = __esm({
  "node_modules/@aws-crypto/sha256-browser/build/module/crossPlatformSha256.js"() {
    "use strict";
    init_webCryptoSha256();
    init_module6();
    init_module4();
    init_dist_es44();
    init_module();
    Sha2563 = /** @class */
    function() {
      function Sha2564(secret) {
        if (supportsWebCrypto(locateWindow())) {
          this.hash = new Sha256(secret);
        } else {
          this.hash = new Sha2562(secret);
        }
      }
      Sha2564.prototype.update = function(data, encoding) {
        this.hash.update(convertToBuffer(data));
      };
      Sha2564.prototype.digest = function() {
        return this.hash.digest();
      };
      Sha2564.prototype.reset = function() {
        this.hash.reset();
      };
      return Sha2564;
    }();
  }
});

// node_modules/@aws-crypto/sha256-browser/build/module/index.js
var init_module7 = __esm({
  "node_modules/@aws-crypto/sha256-browser/build/module/index.js"() {
    "use strict";
    init_crossPlatformSha256();
    init_webCryptoSha256();
  }
});

// node_modules/@aws-sdk/util-user-agent-browser/dist-es/index.js
var createDefaultUserAgentProvider, fallback;
var init_dist_es45 = __esm({
  "node_modules/@aws-sdk/util-user-agent-browser/dist-es/index.js"() {
    "use strict";
    createDefaultUserAgentProvider = ({ serviceId, clientVersion }) => async (config) => {
      const navigator = typeof window !== "undefined" ? window.navigator : void 0;
      const uaString = navigator?.userAgent ?? "";
      const osName = navigator?.userAgentData?.platform ?? fallback.os(uaString) ?? "other";
      const osVersion = void 0;
      const brands = navigator?.userAgentData?.brands ?? [];
      const brand = brands[brands.length - 1];
      const browserName = brand?.brand ?? fallback.browser(uaString) ?? "unknown";
      const browserVersion = brand?.version ?? "unknown";
      const sections = [
        ["aws-sdk-js", clientVersion],
        ["ua", "2.1"],
        [`os/${osName}`, osVersion],
        ["lang/js"],
        ["md/browser", `${browserName}_${browserVersion}`]
      ];
      if (serviceId) {
        sections.push([`api/${serviceId}`, clientVersion]);
      }
      const appId = await config?.userAgentAppId?.();
      if (appId) {
        sections.push([`app/${appId}`]);
      }
      return sections;
    };
    fallback = {
      os(ua) {
        if (/iPhone|iPad|iPod/.test(ua))
          return "iOS";
        if (/Macintosh|Mac OS X/.test(ua))
          return "macOS";
        if (/Windows NT/.test(ua))
          return "Windows";
        if (/Android/.test(ua))
          return "Android";
        if (/Linux/.test(ua))
          return "Linux";
        return void 0;
      },
      browser(ua) {
        if (/EdgiOS|EdgA|Edg\//.test(ua))
          return "Microsoft Edge";
        if (/Firefox\//.test(ua))
          return "Firefox";
        if (/Chrome\//.test(ua))
          return "Chrome";
        if (/Safari\//.test(ua))
          return "Safari";
        return void 0;
      }
    };
  }
});

// node_modules/@smithy/eventstream-codec/dist-es/Int64.js
function negate2(bytes) {
  for (let i2 = 0; i2 < 8; i2++) {
    bytes[i2] ^= 255;
  }
  for (let i2 = 7; i2 > -1; i2--) {
    bytes[i2]++;
    if (bytes[i2] !== 0)
      break;
  }
}
var Int642;
var init_Int64 = __esm({
  "node_modules/@smithy/eventstream-codec/dist-es/Int64.js"() {
    "use strict";
    init_dist_es11();
    Int642 = class _Int64 {
      bytes;
      constructor(bytes) {
        this.bytes = bytes;
        if (bytes.byteLength !== 8) {
          throw new Error("Int64 buffers must be exactly 8 bytes");
        }
      }
      static fromNumber(number) {
        if (number > 9223372036854776e3 || number < -9223372036854776e3) {
          throw new Error(`${number} is too large (or, if negative, too small) to represent as an Int64`);
        }
        const bytes = new Uint8Array(8);
        for (let i2 = 7, remaining = Math.abs(Math.round(number)); i2 > -1 && remaining > 0; i2--, remaining /= 256) {
          bytes[i2] = remaining;
        }
        if (number < 0) {
          negate2(bytes);
        }
        return new _Int64(bytes);
      }
      valueOf() {
        const bytes = this.bytes.slice(0);
        const negative = bytes[0] & 128;
        if (negative) {
          negate2(bytes);
        }
        return parseInt(toHex(bytes), 16) * (negative ? -1 : 1);
      }
      toString() {
        return String(this.valueOf());
      }
    };
  }
});

// node_modules/@smithy/eventstream-codec/dist-es/HeaderMarshaller.js
var HeaderMarshaller, HEADER_VALUE_TYPE2, BOOLEAN_TAG, BYTE_TAG, SHORT_TAG, INT_TAG, LONG_TAG, BINARY_TAG, STRING_TAG, TIMESTAMP_TAG, UUID_TAG, UUID_PATTERN2;
var init_HeaderMarshaller = __esm({
  "node_modules/@smithy/eventstream-codec/dist-es/HeaderMarshaller.js"() {
    "use strict";
    init_dist_es11();
    init_Int64();
    HeaderMarshaller = class {
      toUtf8;
      fromUtf8;
      constructor(toUtf82, fromUtf85) {
        this.toUtf8 = toUtf82;
        this.fromUtf8 = fromUtf85;
      }
      format(headers) {
        const chunks = [];
        for (const headerName of Object.keys(headers)) {
          const bytes = this.fromUtf8(headerName);
          chunks.push(Uint8Array.from([bytes.byteLength]), bytes, this.formatHeaderValue(headers[headerName]));
        }
        const out = new Uint8Array(chunks.reduce((carry, bytes) => carry + bytes.byteLength, 0));
        let position = 0;
        for (const chunk of chunks) {
          out.set(chunk, position);
          position += chunk.byteLength;
        }
        return out;
      }
      formatHeaderValue(header) {
        switch (header.type) {
          case "boolean":
            return Uint8Array.from([header.value ? 0 : 1]);
          case "byte":
            return Uint8Array.from([2, header.value]);
          case "short":
            const shortView = new DataView(new ArrayBuffer(3));
            shortView.setUint8(0, 3);
            shortView.setInt16(1, header.value, false);
            return new Uint8Array(shortView.buffer);
          case "integer":
            const intView = new DataView(new ArrayBuffer(5));
            intView.setUint8(0, 4);
            intView.setInt32(1, header.value, false);
            return new Uint8Array(intView.buffer);
          case "long":
            const longBytes = new Uint8Array(9);
            longBytes[0] = 5;
            longBytes.set(header.value.bytes, 1);
            return longBytes;
          case "binary":
            const binView = new DataView(new ArrayBuffer(3 + header.value.byteLength));
            binView.setUint8(0, 6);
            binView.setUint16(1, header.value.byteLength, false);
            const binBytes = new Uint8Array(binView.buffer);
            binBytes.set(header.value, 3);
            return binBytes;
          case "string":
            const utf8Bytes = this.fromUtf8(header.value);
            const strView = new DataView(new ArrayBuffer(3 + utf8Bytes.byteLength));
            strView.setUint8(0, 7);
            strView.setUint16(1, utf8Bytes.byteLength, false);
            const strBytes = new Uint8Array(strView.buffer);
            strBytes.set(utf8Bytes, 3);
            return strBytes;
          case "timestamp":
            const tsBytes = new Uint8Array(9);
            tsBytes[0] = 8;
            tsBytes.set(Int642.fromNumber(header.value.valueOf()).bytes, 1);
            return tsBytes;
          case "uuid":
            if (!UUID_PATTERN2.test(header.value)) {
              throw new Error(`Invalid UUID received: ${header.value}`);
            }
            const uuidBytes = new Uint8Array(17);
            uuidBytes[0] = 9;
            uuidBytes.set(fromHex(header.value.replace(/\-/g, "")), 1);
            return uuidBytes;
        }
      }
      parse(headers) {
        const out = {};
        let position = 0;
        while (position < headers.byteLength) {
          const nameLength = headers.getUint8(position++);
          const name = this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, nameLength));
          position += nameLength;
          switch (headers.getUint8(position++)) {
            case 0:
              out[name] = {
                type: BOOLEAN_TAG,
                value: true
              };
              break;
            case 1:
              out[name] = {
                type: BOOLEAN_TAG,
                value: false
              };
              break;
            case 2:
              out[name] = {
                type: BYTE_TAG,
                value: headers.getInt8(position++)
              };
              break;
            case 3:
              out[name] = {
                type: SHORT_TAG,
                value: headers.getInt16(position, false)
              };
              position += 2;
              break;
            case 4:
              out[name] = {
                type: INT_TAG,
                value: headers.getInt32(position, false)
              };
              position += 4;
              break;
            case 5:
              out[name] = {
                type: LONG_TAG,
                value: new Int642(new Uint8Array(headers.buffer, headers.byteOffset + position, 8))
              };
              position += 8;
              break;
            case 6:
              const binaryLength = headers.getUint16(position, false);
              position += 2;
              out[name] = {
                type: BINARY_TAG,
                value: new Uint8Array(headers.buffer, headers.byteOffset + position, binaryLength)
              };
              position += binaryLength;
              break;
            case 7:
              const stringLength = headers.getUint16(position, false);
              position += 2;
              out[name] = {
                type: STRING_TAG,
                value: this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, stringLength))
              };
              position += stringLength;
              break;
            case 8:
              out[name] = {
                type: TIMESTAMP_TAG,
                value: new Date(new Int642(new Uint8Array(headers.buffer, headers.byteOffset + position, 8)).valueOf())
              };
              position += 8;
              break;
            case 9:
              const uuidBytes = new Uint8Array(headers.buffer, headers.byteOffset + position, 16);
              position += 16;
              out[name] = {
                type: UUID_TAG,
                value: `${toHex(uuidBytes.subarray(0, 4))}-${toHex(uuidBytes.subarray(4, 6))}-${toHex(uuidBytes.subarray(6, 8))}-${toHex(uuidBytes.subarray(8, 10))}-${toHex(uuidBytes.subarray(10))}`
              };
              break;
            default:
              throw new Error(`Unrecognized header type tag`);
          }
        }
        return out;
      }
    };
    (function(HEADER_VALUE_TYPE3) {
      HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["boolTrue"] = 0] = "boolTrue";
      HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["boolFalse"] = 1] = "boolFalse";
      HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["byte"] = 2] = "byte";
      HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["short"] = 3] = "short";
      HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["integer"] = 4] = "integer";
      HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["long"] = 5] = "long";
      HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["byteArray"] = 6] = "byteArray";
      HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["string"] = 7] = "string";
      HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["timestamp"] = 8] = "timestamp";
      HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["uuid"] = 9] = "uuid";
    })(HEADER_VALUE_TYPE2 || (HEADER_VALUE_TYPE2 = {}));
    BOOLEAN_TAG = "boolean";
    BYTE_TAG = "byte";
    SHORT_TAG = "short";
    INT_TAG = "integer";
    LONG_TAG = "long";
    BINARY_TAG = "binary";
    STRING_TAG = "string";
    TIMESTAMP_TAG = "timestamp";
    UUID_TAG = "uuid";
    UUID_PATTERN2 = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
  }
});

// node_modules/@smithy/eventstream-codec/dist-es/splitMessage.js
function splitMessage({ byteLength, byteOffset, buffer }) {
  if (byteLength < MINIMUM_MESSAGE_LENGTH) {
    throw new Error("Provided message too short to accommodate event stream message overhead");
  }
  const view = new DataView(buffer, byteOffset, byteLength);
  const messageLength = view.getUint32(0, false);
  if (byteLength !== messageLength) {
    throw new Error("Reported message length does not match received message length");
  }
  const headerLength = view.getUint32(PRELUDE_MEMBER_LENGTH, false);
  const expectedPreludeChecksum = view.getUint32(PRELUDE_LENGTH, false);
  const expectedMessageChecksum = view.getUint32(byteLength - CHECKSUM_LENGTH, false);
  const checksummer = new Crc32().update(new Uint8Array(buffer, byteOffset, PRELUDE_LENGTH));
  if (expectedPreludeChecksum !== checksummer.digest()) {
    throw new Error(`The prelude checksum specified in the message (${expectedPreludeChecksum}) does not match the calculated CRC32 checksum (${checksummer.digest()})`);
  }
  checksummer.update(new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH, byteLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH)));
  if (expectedMessageChecksum !== checksummer.digest()) {
    throw new Error(`The message checksum (${checksummer.digest()}) did not match the expected value of ${expectedMessageChecksum}`);
  }
  return {
    headers: new DataView(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH, headerLength),
    body: new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH + headerLength, messageLength - headerLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH + CHECKSUM_LENGTH))
  };
}
var PRELUDE_MEMBER_LENGTH, PRELUDE_LENGTH, CHECKSUM_LENGTH, MINIMUM_MESSAGE_LENGTH;
var init_splitMessage = __esm({
  "node_modules/@smithy/eventstream-codec/dist-es/splitMessage.js"() {
    "use strict";
    init_module3();
    PRELUDE_MEMBER_LENGTH = 4;
    PRELUDE_LENGTH = PRELUDE_MEMBER_LENGTH * 2;
    CHECKSUM_LENGTH = 4;
    MINIMUM_MESSAGE_LENGTH = PRELUDE_LENGTH + CHECKSUM_LENGTH * 2;
  }
});

// node_modules/@smithy/eventstream-codec/dist-es/EventStreamCodec.js
var EventStreamCodec;
var init_EventStreamCodec = __esm({
  "node_modules/@smithy/eventstream-codec/dist-es/EventStreamCodec.js"() {
    "use strict";
    init_module3();
    init_HeaderMarshaller();
    init_splitMessage();
    EventStreamCodec = class {
      headerMarshaller;
      messageBuffer;
      isEndOfStream;
      constructor(toUtf82, fromUtf85) {
        this.headerMarshaller = new HeaderMarshaller(toUtf82, fromUtf85);
        this.messageBuffer = [];
        this.isEndOfStream = false;
      }
      feed(message) {
        this.messageBuffer.push(this.decode(message));
      }
      endOfStream() {
        this.isEndOfStream = true;
      }
      getMessage() {
        const message = this.messageBuffer.pop();
        const isEndOfStream = this.isEndOfStream;
        return {
          getMessage() {
            return message;
          },
          isEndOfStream() {
            return isEndOfStream;
          }
        };
      }
      getAvailableMessages() {
        const messages = this.messageBuffer;
        this.messageBuffer = [];
        const isEndOfStream = this.isEndOfStream;
        return {
          getMessages() {
            return messages;
          },
          isEndOfStream() {
            return isEndOfStream;
          }
        };
      }
      encode({ headers: rawHeaders, body }) {
        const headers = this.headerMarshaller.format(rawHeaders);
        const length = headers.byteLength + body.byteLength + 16;
        const out = new Uint8Array(length);
        const view = new DataView(out.buffer, out.byteOffset, out.byteLength);
        const checksum = new Crc32();
        view.setUint32(0, length, false);
        view.setUint32(4, headers.byteLength, false);
        view.setUint32(8, checksum.update(out.subarray(0, 8)).digest(), false);
        out.set(headers, 12);
        out.set(body, headers.byteLength + 12);
        view.setUint32(length - 4, checksum.update(out.subarray(8, length - 4)).digest(), false);
        return out;
      }
      decode(message) {
        const { headers, body } = splitMessage(message);
        return { headers: this.headerMarshaller.parse(headers), body };
      }
      formatHeaders(rawHeaders) {
        return this.headerMarshaller.format(rawHeaders);
      }
    };
  }
});

// node_modules/@smithy/eventstream-codec/dist-es/Message.js
var init_Message = __esm({
  "node_modules/@smithy/eventstream-codec/dist-es/Message.js"() {
    "use strict";
  }
});

// node_modules/@smithy/eventstream-codec/dist-es/MessageDecoderStream.js
var MessageDecoderStream;
var init_MessageDecoderStream = __esm({
  "node_modules/@smithy/eventstream-codec/dist-es/MessageDecoderStream.js"() {
    "use strict";
    MessageDecoderStream = class {
      options;
      constructor(options) {
        this.options = options;
      }
      [Symbol.asyncIterator]() {
        return this.asyncIterator();
      }
      async *asyncIterator() {
        for await (const bytes of this.options.inputStream) {
          const decoded = this.options.decoder.decode(bytes);
          yield decoded;
        }
      }
    };
  }
});

// node_modules/@smithy/eventstream-codec/dist-es/MessageEncoderStream.js
var MessageEncoderStream;
var init_MessageEncoderStream = __esm({
  "node_modules/@smithy/eventstream-codec/dist-es/MessageEncoderStream.js"() {
    "use strict";
    MessageEncoderStream = class {
      options;
      constructor(options) {
        this.options = options;
      }
      [Symbol.asyncIterator]() {
        return this.asyncIterator();
      }
      async *asyncIterator() {
        for await (const msg of this.options.messageStream) {
          const encoded = this.options.encoder.encode(msg);
          yield encoded;
        }
        if (this.options.includeEndFrame) {
          yield new Uint8Array(0);
        }
      }
    };
  }
});

// node_modules/@smithy/eventstream-codec/dist-es/SmithyMessageDecoderStream.js
var SmithyMessageDecoderStream;
var init_SmithyMessageDecoderStream = __esm({
  "node_modules/@smithy/eventstream-codec/dist-es/SmithyMessageDecoderStream.js"() {
    "use strict";
    SmithyMessageDecoderStream = class {
      options;
      constructor(options) {
        this.options = options;
      }
      [Symbol.asyncIterator]() {
        return this.asyncIterator();
      }
      async *asyncIterator() {
        for await (const message of this.options.messageStream) {
          const deserialized = await this.options.deserializer(message);
          if (deserialized === void 0)
            continue;
          yield deserialized;
        }
      }
    };
  }
});

// node_modules/@smithy/eventstream-codec/dist-es/SmithyMessageEncoderStream.js
var SmithyMessageEncoderStream;
var init_SmithyMessageEncoderStream = __esm({
  "node_modules/@smithy/eventstream-codec/dist-es/SmithyMessageEncoderStream.js"() {
    "use strict";
    SmithyMessageEncoderStream = class {
      options;
      constructor(options) {
        this.options = options;
      }
      [Symbol.asyncIterator]() {
        return this.asyncIterator();
      }
      async *asyncIterator() {
        for await (const chunk of this.options.inputStream) {
          const payloadBuf = this.options.serializer(chunk);
          yield payloadBuf;
        }
      }
    };
  }
});

// node_modules/@smithy/eventstream-codec/dist-es/index.js
var init_dist_es46 = __esm({
  "node_modules/@smithy/eventstream-codec/dist-es/index.js"() {
    "use strict";
    init_EventStreamCodec();
    init_HeaderMarshaller();
    init_Int64();
    init_Message();
    init_MessageDecoderStream();
    init_MessageEncoderStream();
    init_SmithyMessageDecoderStream();
    init_SmithyMessageEncoderStream();
  }
});

// node_modules/@smithy/eventstream-serde-universal/dist-es/getChunkedStream.js
function getChunkedStream(source) {
  let currentMessageTotalLength = 0;
  let currentMessagePendingLength = 0;
  let currentMessage = null;
  let messageLengthBuffer = null;
  const allocateMessage = (size) => {
    if (typeof size !== "number") {
      throw new Error("Attempted to allocate an event message where size was not a number: " + size);
    }
    currentMessageTotalLength = size;
    currentMessagePendingLength = 4;
    currentMessage = new Uint8Array(size);
    const currentMessageView = new DataView(currentMessage.buffer);
    currentMessageView.setUint32(0, size, false);
  };
  const iterator = async function* () {
    const sourceIterator = source[Symbol.asyncIterator]();
    while (true) {
      const { value, done } = await sourceIterator.next();
      if (done) {
        if (!currentMessageTotalLength) {
          return;
        } else if (currentMessageTotalLength === currentMessagePendingLength) {
          yield currentMessage;
        } else {
          throw new Error("Truncated event message received.");
        }
        return;
      }
      const chunkLength = value.length;
      let currentOffset = 0;
      while (currentOffset < chunkLength) {
        if (!currentMessage) {
          const bytesRemaining = chunkLength - currentOffset;
          if (!messageLengthBuffer) {
            messageLengthBuffer = new Uint8Array(4);
          }
          const numBytesForTotal = Math.min(4 - currentMessagePendingLength, bytesRemaining);
          messageLengthBuffer.set(value.slice(currentOffset, currentOffset + numBytesForTotal), currentMessagePendingLength);
          currentMessagePendingLength += numBytesForTotal;
          currentOffset += numBytesForTotal;
          if (currentMessagePendingLength < 4) {
            break;
          }
          allocateMessage(new DataView(messageLengthBuffer.buffer).getUint32(0, false));
          messageLengthBuffer = null;
        }
        const numBytesToWrite = Math.min(currentMessageTotalLength - currentMessagePendingLength, chunkLength - currentOffset);
        currentMessage.set(value.slice(currentOffset, currentOffset + numBytesToWrite), currentMessagePendingLength);
        currentMessagePendingLength += numBytesToWrite;
        currentOffset += numBytesToWrite;
        if (currentMessageTotalLength && currentMessageTotalLength === currentMessagePendingLength) {
          yield currentMessage;
          currentMessage = null;
          currentMessageTotalLength = 0;
          currentMessagePendingLength = 0;
        }
      }
    }
  };
  return {
    [Symbol.asyncIterator]: iterator
  };
}
var init_getChunkedStream = __esm({
  "node_modules/@smithy/eventstream-serde-universal/dist-es/getChunkedStream.js"() {
    "use strict";
  }
});

// node_modules/@smithy/eventstream-serde-universal/dist-es/getUnmarshalledStream.js
function getMessageUnmarshaller(deserializer, toUtf82) {
  return async function(message) {
    const { value: messageType } = message.headers[":message-type"];
    if (messageType === "error") {
      const unmodeledError = new Error(message.headers[":error-message"].value || "UnknownError");
      unmodeledError.name = message.headers[":error-code"].value;
      throw unmodeledError;
    } else if (messageType === "exception") {
      const code = message.headers[":exception-type"].value;
      const exception = { [code]: message };
      const deserializedException = await deserializer(exception);
      if (deserializedException.$unknown) {
        const error = new Error(toUtf82(message.body));
        error.name = code;
        throw error;
      }
      throw deserializedException[code];
    } else if (messageType === "event") {
      const event = {
        [message.headers[":event-type"].value]: message
      };
      const deserialized = await deserializer(event);
      if (deserialized.$unknown)
        return;
      return deserialized;
    } else {
      throw Error(`Unrecognizable event type: ${message.headers[":event-type"].value}`);
    }
  };
}
var init_getUnmarshalledStream = __esm({
  "node_modules/@smithy/eventstream-serde-universal/dist-es/getUnmarshalledStream.js"() {
    "use strict";
  }
});

// node_modules/@smithy/eventstream-serde-universal/dist-es/EventStreamMarshaller.js
var EventStreamMarshaller;
var init_EventStreamMarshaller = __esm({
  "node_modules/@smithy/eventstream-serde-universal/dist-es/EventStreamMarshaller.js"() {
    "use strict";
    init_dist_es46();
    init_getChunkedStream();
    init_getUnmarshalledStream();
    EventStreamMarshaller = class {
      eventStreamCodec;
      utfEncoder;
      constructor({ utf8Encoder, utf8Decoder }) {
        this.eventStreamCodec = new EventStreamCodec(utf8Encoder, utf8Decoder);
        this.utfEncoder = utf8Encoder;
      }
      deserialize(body, deserializer) {
        const inputStream = getChunkedStream(body);
        return new SmithyMessageDecoderStream({
          messageStream: new MessageDecoderStream({ inputStream, decoder: this.eventStreamCodec }),
          deserializer: getMessageUnmarshaller(deserializer, this.utfEncoder)
        });
      }
      serialize(inputStream, serializer) {
        return new MessageEncoderStream({
          messageStream: new SmithyMessageEncoderStream({ inputStream, serializer }),
          encoder: this.eventStreamCodec,
          includeEndFrame: true
        });
      }
    };
  }
});

// node_modules/@smithy/eventstream-serde-universal/dist-es/provider.js
var init_provider = __esm({
  "node_modules/@smithy/eventstream-serde-universal/dist-es/provider.js"() {
    "use strict";
  }
});

// node_modules/@smithy/eventstream-serde-universal/dist-es/index.js
var init_dist_es47 = __esm({
  "node_modules/@smithy/eventstream-serde-universal/dist-es/index.js"() {
    "use strict";
    init_EventStreamMarshaller();
    init_provider();
  }
});

// node_modules/@smithy/eventstream-serde-browser/dist-es/utils.js
var readableStreamtoIterable, iterableToReadableStream;
var init_utils3 = __esm({
  "node_modules/@smithy/eventstream-serde-browser/dist-es/utils.js"() {
    "use strict";
    readableStreamtoIterable = (readableStream) => ({
      [Symbol.asyncIterator]: async function* () {
        const reader = readableStream.getReader();
        try {
          while (true) {
            const { done, value } = await reader.read();
            if (done)
              return;
            yield value;
          }
        } finally {
          reader.releaseLock();
        }
      }
    });
    iterableToReadableStream = (asyncIterable) => {
      const iterator = asyncIterable[Symbol.asyncIterator]();
      return new ReadableStream({
        async pull(controller) {
          const { done, value } = await iterator.next();
          if (done) {
            return controller.close();
          }
          controller.enqueue(value);
        }
      });
    };
  }
});

// node_modules/@smithy/eventstream-serde-browser/dist-es/EventStreamMarshaller.js
var EventStreamMarshaller2, isReadableStream2;
var init_EventStreamMarshaller2 = __esm({
  "node_modules/@smithy/eventstream-serde-browser/dist-es/EventStreamMarshaller.js"() {
    "use strict";
    init_dist_es47();
    init_utils3();
    EventStreamMarshaller2 = class {
      universalMarshaller;
      constructor({ utf8Encoder, utf8Decoder }) {
        this.universalMarshaller = new EventStreamMarshaller({
          utf8Decoder,
          utf8Encoder
        });
      }
      deserialize(body, deserializer) {
        const bodyIterable = isReadableStream2(body) ? readableStreamtoIterable(body) : body;
        return this.universalMarshaller.deserialize(bodyIterable, deserializer);
      }
      serialize(input, serializer) {
        const serialziedIterable = this.universalMarshaller.serialize(input, serializer);
        return typeof ReadableStream === "function" ? iterableToReadableStream(serialziedIterable) : serialziedIterable;
      }
    };
    isReadableStream2 = (body) => typeof ReadableStream === "function" && body instanceof ReadableStream;
  }
});

// node_modules/@smithy/eventstream-serde-browser/dist-es/provider.js
var eventStreamSerdeProvider;
var init_provider2 = __esm({
  "node_modules/@smithy/eventstream-serde-browser/dist-es/provider.js"() {
    "use strict";
    init_EventStreamMarshaller2();
    eventStreamSerdeProvider = (options) => new EventStreamMarshaller2(options);
  }
});

// node_modules/@smithy/eventstream-serde-browser/dist-es/index.js
var init_dist_es48 = __esm({
  "node_modules/@smithy/eventstream-serde-browser/dist-es/index.js"() {
    "use strict";
    init_EventStreamMarshaller2();
    init_provider2();
    init_utils3();
  }
});

// node_modules/@smithy/chunked-blob-reader/dist-es/index.js
async function blobReader(blob, onChunk, chunkSize = 1024 * 1024) {
  const size = blob.size;
  let totalBytesRead = 0;
  while (totalBytesRead < size) {
    const slice = blob.slice(totalBytesRead, Math.min(size, totalBytesRead + chunkSize));
    onChunk(new Uint8Array(await slice.arrayBuffer()));
    totalBytesRead += slice.size;
  }
}
var init_dist_es49 = __esm({
  "node_modules/@smithy/chunked-blob-reader/dist-es/index.js"() {
    "use strict";
  }
});

// node_modules/@smithy/hash-blob-browser/dist-es/index.js
var blobHasher;
var init_dist_es50 = __esm({
  "node_modules/@smithy/hash-blob-browser/dist-es/index.js"() {
    "use strict";
    init_dist_es49();
    blobHasher = async function blobHasher2(hashCtor, blob) {
      const hash = new hashCtor();
      await blobReader(blob, (chunk) => {
        hash.update(chunk);
      });
      return hash.digest();
    };
  }
});

// node_modules/@smithy/invalid-dependency/dist-es/invalidFunction.js
var init_invalidFunction = __esm({
  "node_modules/@smithy/invalid-dependency/dist-es/invalidFunction.js"() {
    "use strict";
  }
});

// node_modules/@smithy/invalid-dependency/dist-es/invalidProvider.js
var invalidProvider;
var init_invalidProvider = __esm({
  "node_modules/@smithy/invalid-dependency/dist-es/invalidProvider.js"() {
    "use strict";
    invalidProvider = (message) => () => Promise.reject(message);
  }
});

// node_modules/@smithy/invalid-dependency/dist-es/index.js
var init_dist_es51 = __esm({
  "node_modules/@smithy/invalid-dependency/dist-es/index.js"() {
    "use strict";
    init_invalidFunction();
    init_invalidProvider();
  }
});

// node_modules/@smithy/md5-js/dist-es/constants.js
var BLOCK_SIZE2, DIGEST_LENGTH2, INIT2;
var init_constants11 = __esm({
  "node_modules/@smithy/md5-js/dist-es/constants.js"() {
    "use strict";
    BLOCK_SIZE2 = 64;
    DIGEST_LENGTH2 = 16;
    INIT2 = [1732584193, 4023233417, 2562383102, 271733878];
  }
});

// node_modules/@smithy/md5-js/dist-es/index.js
function cmn(q2, a2, b2, x2, s2, t2) {
  a2 = (a2 + q2 & 4294967295) + (x2 + t2 & 4294967295) & 4294967295;
  return (a2 << s2 | a2 >>> 32 - s2) + b2 & 4294967295;
}
function ff(a2, b2, c2, d2, x2, s2, t2) {
  return cmn(b2 & c2 | ~b2 & d2, a2, b2, x2, s2, t2);
}
function gg(a2, b2, c2, d2, x2, s2, t2) {
  return cmn(b2 & d2 | c2 & ~d2, a2, b2, x2, s2, t2);
}
function hh(a2, b2, c2, d2, x2, s2, t2) {
  return cmn(b2 ^ c2 ^ d2, a2, b2, x2, s2, t2);
}
function ii(a2, b2, c2, d2, x2, s2, t2) {
  return cmn(c2 ^ (b2 | ~d2), a2, b2, x2, s2, t2);
}
function isEmptyData3(data) {
  if (typeof data === "string") {
    return data.length === 0;
  }
  return data.byteLength === 0;
}
function convertToBuffer3(data) {
  if (typeof data === "string") {
    return fromUtf8(data);
  }
  if (ArrayBuffer.isView(data)) {
    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
  }
  return new Uint8Array(data);
}
var Md5;
var init_dist_es52 = __esm({
  "node_modules/@smithy/md5-js/dist-es/index.js"() {
    "use strict";
    init_dist_es6();
    init_constants11();
    Md5 = class {
      state;
      buffer;
      bufferLength;
      bytesHashed;
      finished;
      constructor() {
        this.reset();
      }
      update(sourceData) {
        if (isEmptyData3(sourceData)) {
          return;
        } else if (this.finished) {
          throw new Error("Attempted to update an already finished hash.");
        }
        const data = convertToBuffer3(sourceData);
        let position = 0;
        let { byteLength } = data;
        this.bytesHashed += byteLength;
        while (byteLength > 0) {
          this.buffer.setUint8(this.bufferLength++, data[position++]);
          byteLength--;
          if (this.bufferLength === BLOCK_SIZE2) {
            this.hashBuffer();
            this.bufferLength = 0;
          }
        }
      }
      async digest() {
        if (!this.finished) {
          const { buffer, bufferLength: undecoratedLength, bytesHashed } = this;
          const bitsHashed = bytesHashed * 8;
          buffer.setUint8(this.bufferLength++, 128);
          if (undecoratedLength % BLOCK_SIZE2 >= BLOCK_SIZE2 - 8) {
            for (let i2 = this.bufferLength; i2 < BLOCK_SIZE2; i2++) {
              buffer.setUint8(i2, 0);
            }
            this.hashBuffer();
            this.bufferLength = 0;
          }
          for (let i2 = this.bufferLength; i2 < BLOCK_SIZE2 - 8; i2++) {
            buffer.setUint8(i2, 0);
          }
          buffer.setUint32(BLOCK_SIZE2 - 8, bitsHashed >>> 0, true);
          buffer.setUint32(BLOCK_SIZE2 - 4, Math.floor(bitsHashed / 4294967296), true);
          this.hashBuffer();
          this.finished = true;
        }
        const out = new DataView(new ArrayBuffer(DIGEST_LENGTH2));
        for (let i2 = 0; i2 < 4; i2++) {
          out.setUint32(i2 * 4, this.state[i2], true);
        }
        return new Uint8Array(out.buffer, out.byteOffset, out.byteLength);
      }
      hashBuffer() {
        const { buffer, state } = this;
        let a2 = state[0], b2 = state[1], c2 = state[2], d2 = state[3];
        a2 = ff(a2, b2, c2, d2, buffer.getUint32(0, true), 7, 3614090360);
        d2 = ff(d2, a2, b2, c2, buffer.getUint32(4, true), 12, 3905402710);
        c2 = ff(c2, d2, a2, b2, buffer.getUint32(8, true), 17, 606105819);
        b2 = ff(b2, c2, d2, a2, buffer.getUint32(12, true), 22, 3250441966);
        a2 = ff(a2, b2, c2, d2, buffer.getUint32(16, true), 7, 4118548399);
        d2 = ff(d2, a2, b2, c2, buffer.getUint32(20, true), 12, 1200080426);
        c2 = ff(c2, d2, a2, b2, buffer.getUint32(24, true), 17, 2821735955);
        b2 = ff(b2, c2, d2, a2, buffer.getUint32(28, true), 22, 4249261313);
        a2 = ff(a2, b2, c2, d2, buffer.getUint32(32, true), 7, 1770035416);
        d2 = ff(d2, a2, b2, c2, buffer.getUint32(36, true), 12, 2336552879);
        c2 = ff(c2, d2, a2, b2, buffer.getUint32(40, true), 17, 4294925233);
        b2 = ff(b2, c2, d2, a2, buffer.getUint32(44, true), 22, 2304563134);
        a2 = ff(a2, b2, c2, d2, buffer.getUint32(48, true), 7, 1804603682);
        d2 = ff(d2, a2, b2, c2, buffer.getUint32(52, true), 12, 4254626195);
        c2 = ff(c2, d2, a2, b2, buffer.getUint32(56, true), 17, 2792965006);
        b2 = ff(b2, c2, d2, a2, buffer.getUint32(60, true), 22, 1236535329);
        a2 = gg(a2, b2, c2, d2, buffer.getUint32(4, true), 5, 4129170786);
        d2 = gg(d2, a2, b2, c2, buffer.getUint32(24, true), 9, 3225465664);
        c2 = gg(c2, d2, a2, b2, buffer.getUint32(44, true), 14, 643717713);
        b2 = gg(b2, c2, d2, a2, buffer.getUint32(0, true), 20, 3921069994);
        a2 = gg(a2, b2, c2, d2, buffer.getUint32(20, true), 5, 3593408605);
        d2 = gg(d2, a2, b2, c2, buffer.getUint32(40, true), 9, 38016083);
        c2 = gg(c2, d2, a2, b2, buffer.getUint32(60, true), 14, 3634488961);
        b2 = gg(b2, c2, d2, a2, buffer.getUint32(16, true), 20, 3889429448);
        a2 = gg(a2, b2, c2, d2, buffer.getUint32(36, true), 5, 568446438);
        d2 = gg(d2, a2, b2, c2, buffer.getUint32(56, true), 9, 3275163606);
        c2 = gg(c2, d2, a2, b2, buffer.getUint32(12, true), 14, 4107603335);
        b2 = gg(b2, c2, d2, a2, buffer.getUint32(32, true), 20, 1163531501);
        a2 = gg(a2, b2, c2, d2, buffer.getUint32(52, true), 5, 2850285829);
        d2 = gg(d2, a2, b2, c2, buffer.getUint32(8, true), 9, 4243563512);
        c2 = gg(c2, d2, a2, b2, buffer.getUint32(28, true), 14, 1735328473);
        b2 = gg(b2, c2, d2, a2, buffer.getUint32(48, true), 20, 2368359562);
        a2 = hh(a2, b2, c2, d2, buffer.getUint32(20, true), 4, 4294588738);
        d2 = hh(d2, a2, b2, c2, buffer.getUint32(32, true), 11, 2272392833);
        c2 = hh(c2, d2, a2, b2, buffer.getUint32(44, true), 16, 1839030562);
        b2 = hh(b2, c2, d2, a2, buffer.getUint32(56, true), 23, 4259657740);
        a2 = hh(a2, b2, c2, d2, buffer.getUint32(4, true), 4, 2763975236);
        d2 = hh(d2, a2, b2, c2, buffer.getUint32(16, true), 11, 1272893353);
        c2 = hh(c2, d2, a2, b2, buffer.getUint32(28, true), 16, 4139469664);
        b2 = hh(b2, c2, d2, a2, buffer.getUint32(40, true), 23, 3200236656);
        a2 = hh(a2, b2, c2, d2, buffer.getUint32(52, true), 4, 681279174);
        d2 = hh(d2, a2, b2, c2, buffer.getUint32(0, true), 11, 3936430074);
        c2 = hh(c2, d2, a2, b2, buffer.getUint32(12, true), 16, 3572445317);
        b2 = hh(b2, c2, d2, a2, buffer.getUint32(24, true), 23, 76029189);
        a2 = hh(a2, b2, c2, d2, buffer.getUint32(36, true), 4, 3654602809);
        d2 = hh(d2, a2, b2, c2, buffer.getUint32(48, true), 11, 3873151461);
        c2 = hh(c2, d2, a2, b2, buffer.getUint32(60, true), 16, 530742520);
        b2 = hh(b2, c2, d2, a2, buffer.getUint32(8, true), 23, 3299628645);
        a2 = ii(a2, b2, c2, d2, buffer.getUint32(0, true), 6, 4096336452);
        d2 = ii(d2, a2, b2, c2, buffer.getUint32(28, true), 10, 1126891415);
        c2 = ii(c2, d2, a2, b2, buffer.getUint32(56, true), 15, 2878612391);
        b2 = ii(b2, c2, d2, a2, buffer.getUint32(20, true), 21, 4237533241);
        a2 = ii(a2, b2, c2, d2, buffer.getUint32(48, true), 6, 1700485571);
        d2 = ii(d2, a2, b2, c2, buffer.getUint32(12, true), 10, 2399980690);
        c2 = ii(c2, d2, a2, b2, buffer.getUint32(40, true), 15, 4293915773);
        b2 = ii(b2, c2, d2, a2, buffer.getUint32(4, true), 21, 2240044497);
        a2 = ii(a2, b2, c2, d2, buffer.getUint32(32, true), 6, 1873313359);
        d2 = ii(d2, a2, b2, c2, buffer.getUint32(60, true), 10, 4264355552);
        c2 = ii(c2, d2, a2, b2, buffer.getUint32(24, true), 15, 2734768916);
        b2 = ii(b2, c2, d2, a2, buffer.getUint32(52, true), 21, 1309151649);
        a2 = ii(a2, b2, c2, d2, buffer.getUint32(16, true), 6, 4149444226);
        d2 = ii(d2, a2, b2, c2, buffer.getUint32(44, true), 10, 3174756917);
        c2 = ii(c2, d2, a2, b2, buffer.getUint32(8, true), 15, 718787259);
        b2 = ii(b2, c2, d2, a2, buffer.getUint32(36, true), 21, 3951481745);
        state[0] = a2 + state[0] & 4294967295;
        state[1] = b2 + state[1] & 4294967295;
        state[2] = c2 + state[2] & 4294967295;
        state[3] = d2 + state[3] & 4294967295;
      }
      reset() {
        this.state = Uint32Array.from(INIT2);
        this.buffer = new DataView(new ArrayBuffer(BLOCK_SIZE2));
        this.bufferLength = 0;
        this.bytesHashed = 0;
        this.finished = false;
      }
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/runtimeConfig.shared.js
var getRuntimeConfig;
var init_runtimeConfig_shared = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/runtimeConfig.shared.js"() {
    "use strict";
    init_dist_es22();
    init_dist_es42();
    init_dist_es20();
    init_dist_es32();
    init_dist_es7();
    init_dist_es12();
    init_dist_es6();
    init_httpAuthSchemeProvider();
    init_endpointResolver();
    getRuntimeConfig = (config) => {
      return {
        apiVersion: "2006-03-01",
        base64Decoder: config?.base64Decoder ?? fromBase64,
        base64Encoder: config?.base64Encoder ?? toBase64,
        disableHostPrefix: config?.disableHostPrefix ?? false,
        endpointProvider: config?.endpointProvider ?? defaultEndpointResolver,
        extensions: config?.extensions ?? [],
        getAwsChunkedEncodingStream: config?.getAwsChunkedEncodingStream ?? getAwsChunkedEncodingStream,
        httpAuthSchemeProvider: config?.httpAuthSchemeProvider ?? defaultS3HttpAuthSchemeProvider,
        httpAuthSchemes: config?.httpAuthSchemes ?? [
          {
            schemeId: "aws.auth#sigv4",
            identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4"),
            signer: new AwsSdkSigV4Signer()
          },
          {
            schemeId: "aws.auth#sigv4a",
            identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4a"),
            signer: new AwsSdkSigV4ASigner()
          }
        ],
        logger: config?.logger ?? new NoOpLogger(),
        sdkStreamMixin: config?.sdkStreamMixin ?? sdkStreamMixin,
        serviceId: config?.serviceId ?? "S3",
        signerConstructor: config?.signerConstructor ?? SignatureV4MultiRegion,
        signingEscapePath: config?.signingEscapePath ?? false,
        urlParser: config?.urlParser ?? parseUrl,
        useArnRegion: config?.useArnRegion ?? void 0,
        utf8Decoder: config?.utf8Decoder ?? fromUtf8,
        utf8Encoder: config?.utf8Encoder ?? toUtf8
      };
    };
  }
});

// node_modules/@smithy/util-defaults-mode-browser/dist-es/constants.js
var DEFAULTS_MODE_OPTIONS;
var init_constants12 = __esm({
  "node_modules/@smithy/util-defaults-mode-browser/dist-es/constants.js"() {
    "use strict";
    DEFAULTS_MODE_OPTIONS = ["in-region", "cross-region", "mobile", "standard", "legacy"];
  }
});

// node_modules/@smithy/util-defaults-mode-browser/dist-es/resolveDefaultsModeConfig.js
var resolveDefaultsModeConfig, useMobileConfiguration;
var init_resolveDefaultsModeConfig = __esm({
  "node_modules/@smithy/util-defaults-mode-browser/dist-es/resolveDefaultsModeConfig.js"() {
    "use strict";
    init_dist_es15();
    init_constants12();
    resolveDefaultsModeConfig = ({ defaultsMode } = {}) => memoize(async () => {
      const mode = typeof defaultsMode === "function" ? await defaultsMode() : defaultsMode;
      switch (mode?.toLowerCase()) {
        case "auto":
          return Promise.resolve(useMobileConfiguration() ? "mobile" : "standard");
        case "mobile":
        case "in-region":
        case "cross-region":
        case "standard":
        case "legacy":
          return Promise.resolve(mode?.toLocaleLowerCase());
        case void 0:
          return Promise.resolve("legacy");
        default:
          throw new Error(`Invalid parameter for "defaultsMode", expect ${DEFAULTS_MODE_OPTIONS.join(", ")}, got ${mode}`);
      }
    });
    useMobileConfiguration = () => {
      const navigator = window?.navigator;
      if (navigator?.connection) {
        const { effectiveType, rtt, downlink } = navigator?.connection;
        const slow = typeof effectiveType === "string" && effectiveType !== "4g" || Number(rtt) > 100 || Number(downlink) < 10;
        if (slow) {
          return true;
        }
      }
      return navigator?.userAgentData?.mobile || typeof navigator?.maxTouchPoints === "number" && navigator?.maxTouchPoints > 1;
    };
  }
});

// node_modules/@smithy/util-defaults-mode-browser/dist-es/index.js
var init_dist_es53 = __esm({
  "node_modules/@smithy/util-defaults-mode-browser/dist-es/index.js"() {
    "use strict";
    init_resolveDefaultsModeConfig();
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/runtimeConfig.browser.js
var getRuntimeConfig2;
var init_runtimeConfig_browser = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/runtimeConfig.browser.js"() {
    "use strict";
    init_package();
    init_module5();
    init_module7();
    init_dist_es45();
    init_dist_es35();
    init_dist_es48();
    init_dist_es10();
    init_dist_es50();
    init_dist_es51();
    init_dist_es52();
    init_dist_es18();
    init_dist_es40();
    init_runtimeConfig_shared();
    init_dist_es20();
    init_dist_es53();
    getRuntimeConfig2 = (config) => {
      const defaultsMode = resolveDefaultsModeConfig(config);
      const defaultConfigProvider = () => defaultsMode().then(loadConfigsForDefaultMode);
      const clientSharedValues = getRuntimeConfig(config);
      return {
        ...clientSharedValues,
        ...config,
        runtime: "browser",
        defaultsMode,
        bodyLengthChecker: config?.bodyLengthChecker ?? calculateBodyLength,
        credentialDefaultProvider: config?.credentialDefaultProvider ?? ((_) => () => Promise.reject(new Error("Credential is missing"))),
        defaultUserAgentProvider: config?.defaultUserAgentProvider ?? createDefaultUserAgentProvider({ serviceId: clientSharedValues.serviceId, clientVersion: package_default.version }),
        eventStreamSerdeProvider: config?.eventStreamSerdeProvider ?? eventStreamSerdeProvider,
        maxAttempts: config?.maxAttempts ?? DEFAULT_MAX_ATTEMPTS,
        md5: config?.md5 ?? Md5,
        region: config?.region ?? invalidProvider("Region is missing"),
        requestHandler: FetchHttpHandler.create(config?.requestHandler ?? defaultConfigProvider),
        retryMode: config?.retryMode ?? (async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE),
        sha1: config?.sha1 ?? Sha12,
        sha256: config?.sha256 ?? Sha2563,
        streamCollector: config?.streamCollector ?? streamCollector,
        streamHasher: config?.streamHasher ?? blobHasher,
        useDualstackEndpoint: config?.useDualstackEndpoint ?? (() => Promise.resolve(DEFAULT_USE_DUALSTACK_ENDPOINT)),
        useFipsEndpoint: config?.useFipsEndpoint ?? (() => Promise.resolve(DEFAULT_USE_FIPS_ENDPOINT))
      };
    };
  }
});

// node_modules/@aws-sdk/region-config-resolver/dist-es/extensions/index.js
var getAwsRegionExtensionConfiguration, resolveAwsRegionExtensionConfiguration;
var init_extensions4 = __esm({
  "node_modules/@aws-sdk/region-config-resolver/dist-es/extensions/index.js"() {
    "use strict";
    getAwsRegionExtensionConfiguration = (runtimeConfig) => {
      return {
        setRegion(region) {
          runtimeConfig.region = region;
        },
        region() {
          return runtimeConfig.region;
        }
      };
    };
    resolveAwsRegionExtensionConfiguration = (awsRegionExtensionConfiguration) => {
      return {
        region: awsRegionExtensionConfiguration.region()
      };
    };
  }
});

// node_modules/@aws-sdk/region-config-resolver/dist-es/regionConfig/awsRegionConfig.js
var init_awsRegionConfig = __esm({
  "node_modules/@aws-sdk/region-config-resolver/dist-es/regionConfig/awsRegionConfig.js"() {
    "use strict";
  }
});

// node_modules/@aws-sdk/region-config-resolver/dist-es/regionConfig/stsRegionDefaultResolver.browser.js
var init_stsRegionDefaultResolver_browser = __esm({
  "node_modules/@aws-sdk/region-config-resolver/dist-es/regionConfig/stsRegionDefaultResolver.browser.js"() {
    "use strict";
  }
});

// node_modules/@aws-sdk/region-config-resolver/dist-es/index.js
var init_dist_es54 = __esm({
  "node_modules/@aws-sdk/region-config-resolver/dist-es/index.js"() {
    "use strict";
    init_extensions4();
    init_awsRegionConfig();
    init_stsRegionDefaultResolver_browser();
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/auth/httpAuthExtensionConfiguration.js
var getHttpAuthExtensionConfiguration, resolveHttpAuthRuntimeConfig;
var init_httpAuthExtensionConfiguration = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/auth/httpAuthExtensionConfiguration.js"() {
    "use strict";
    getHttpAuthExtensionConfiguration = (runtimeConfig) => {
      const _httpAuthSchemes = runtimeConfig.httpAuthSchemes;
      let _httpAuthSchemeProvider = runtimeConfig.httpAuthSchemeProvider;
      let _credentials = runtimeConfig.credentials;
      return {
        setHttpAuthScheme(httpAuthScheme) {
          const index = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);
          if (index === -1) {
            _httpAuthSchemes.push(httpAuthScheme);
          } else {
            _httpAuthSchemes.splice(index, 1, httpAuthScheme);
          }
        },
        httpAuthSchemes() {
          return _httpAuthSchemes;
        },
        setHttpAuthSchemeProvider(httpAuthSchemeProvider) {
          _httpAuthSchemeProvider = httpAuthSchemeProvider;
        },
        httpAuthSchemeProvider() {
          return _httpAuthSchemeProvider;
        },
        setCredentials(credentials) {
          _credentials = credentials;
        },
        credentials() {
          return _credentials;
        }
      };
    };
    resolveHttpAuthRuntimeConfig = (config) => {
      return {
        httpAuthSchemes: config.httpAuthSchemes(),
        httpAuthSchemeProvider: config.httpAuthSchemeProvider(),
        credentials: config.credentials()
      };
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/runtimeExtensions.js
var resolveRuntimeExtensions;
var init_runtimeExtensions = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/runtimeExtensions.js"() {
    "use strict";
    init_dist_es54();
    init_dist_es2();
    init_dist_es20();
    init_httpAuthExtensionConfiguration();
    resolveRuntimeExtensions = (runtimeConfig, extensions) => {
      const extensionConfiguration = Object.assign(getAwsRegionExtensionConfiguration(runtimeConfig), getDefaultExtensionConfiguration(runtimeConfig), getHttpHandlerExtensionConfiguration(runtimeConfig), getHttpAuthExtensionConfiguration(runtimeConfig));
      extensions.forEach((extension) => extension.configure(extensionConfiguration));
      return Object.assign(runtimeConfig, resolveAwsRegionExtensionConfiguration(extensionConfiguration), resolveDefaultRuntimeConfig(extensionConfiguration), resolveHttpHandlerRuntimeConfig(extensionConfiguration), resolveHttpAuthRuntimeConfig(extensionConfiguration));
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/S3Client.js
var S3Client;
var init_S3Client = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/S3Client.js"() {
    "use strict";
    init_dist_es3();
    init_dist_es24();
    init_dist_es25();
    init_dist_es26();
    init_dist_es27();
    init_dist_es29();
    init_dist_es34();
    init_dist_es35();
    init_dist_es14();
    init_dist_es36();
    init_dist_es37();
    init_dist_es38();
    init_dist_es41();
    init_dist_es20();
    init_httpAuthSchemeProvider();
    init_CreateSessionCommand();
    init_EndpointParameters();
    init_runtimeConfig_browser();
    init_runtimeExtensions();
    S3Client = class extends Client {
      config;
      constructor(...[configuration]) {
        const _config_0 = getRuntimeConfig2(configuration || {});
        super(_config_0);
        this.initConfig = _config_0;
        const _config_1 = resolveClientEndpointParameters(_config_0);
        const _config_2 = resolveUserAgentConfig(_config_1);
        const _config_3 = resolveFlexibleChecksumsConfig(_config_2);
        const _config_4 = resolveRetryConfig(_config_3);
        const _config_5 = resolveRegionConfig(_config_4);
        const _config_6 = resolveHostHeaderConfig(_config_5);
        const _config_7 = resolveEndpointConfig(_config_6);
        const _config_8 = resolveEventStreamSerdeConfig(_config_7);
        const _config_9 = resolveHttpAuthSchemeConfig(_config_8);
        const _config_10 = resolveS3Config(_config_9, { session: [() => this, CreateSessionCommand] });
        const _config_11 = resolveRuntimeExtensions(_config_10, configuration?.extensions || []);
        this.config = _config_11;
        this.middlewareStack.use(getUserAgentPlugin(this.config));
        this.middlewareStack.use(getRetryPlugin(this.config));
        this.middlewareStack.use(getContentLengthPlugin(this.config));
        this.middlewareStack.use(getHostHeaderPlugin(this.config));
        this.middlewareStack.use(getLoggerPlugin(this.config));
        this.middlewareStack.use(getRecursionDetectionPlugin(this.config));
        this.middlewareStack.use(getHttpAuthSchemeEndpointRuleSetPlugin(this.config, {
          httpAuthSchemeParametersProvider: defaultS3HttpAuthSchemeParametersProvider,
          identityProviderConfigProvider: async (config) => new DefaultIdentityProviderConfig({
            "aws.auth#sigv4": config.credentials,
            "aws.auth#sigv4a": config.credentials
          })
        }));
        this.middlewareStack.use(getHttpSigningPlugin(this.config));
        this.middlewareStack.use(getValidateBucketNamePlugin(this.config));
        this.middlewareStack.use(getAddExpectContinuePlugin(this.config));
        this.middlewareStack.use(getRegionRedirectMiddlewarePlugin(this.config));
        this.middlewareStack.use(getS3ExpressPlugin(this.config));
        this.middlewareStack.use(getS3ExpressHttpSigningPlugin(this.config));
      }
      destroy() {
        super.destroy();
      }
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/AbortMultipartUploadCommand.js
var AbortMultipartUploadCommand;
var init_AbortMultipartUploadCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/AbortMultipartUploadCommand.js"() {
    "use strict";
    init_dist_es29();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    AbortMultipartUploadCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" },
      Key: { type: "contextParams", name: "Key" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "AbortMultipartUpload", {}).n("S3Client", "AbortMultipartUploadCommand").f(void 0, void 0).ser(se_AbortMultipartUploadCommand).de(de_AbortMultipartUploadCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/middleware-ssec/dist-es/index.js
function ssecMiddleware(options) {
  return (next) => async (args) => {
    const input = { ...args.input };
    const properties = [
      {
        target: "SSECustomerKey",
        hash: "SSECustomerKeyMD5"
      },
      {
        target: "CopySourceSSECustomerKey",
        hash: "CopySourceSSECustomerKeyMD5"
      }
    ];
    for (const prop of properties) {
      const value = input[prop.target];
      if (value) {
        let valueForHash;
        if (typeof value === "string") {
          if (isValidBase64EncodedSSECustomerKey(value, options)) {
            valueForHash = options.base64Decoder(value);
          } else {
            valueForHash = options.utf8Decoder(value);
            input[prop.target] = options.base64Encoder(valueForHash);
          }
        } else {
          valueForHash = ArrayBuffer.isView(value) ? new Uint8Array(value.buffer, value.byteOffset, value.byteLength) : new Uint8Array(value);
          input[prop.target] = options.base64Encoder(valueForHash);
        }
        const hash = new options.md5();
        hash.update(valueForHash);
        input[prop.hash] = options.base64Encoder(await hash.digest());
      }
    }
    return next({
      ...args,
      input
    });
  };
}
function isValidBase64EncodedSSECustomerKey(str, options) {
  const base64Regex = /^(?:[A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;
  if (!base64Regex.test(str))
    return false;
  try {
    const decodedBytes = options.base64Decoder(str);
    return decodedBytes.length === 32;
  } catch {
    return false;
  }
}
var ssecMiddlewareOptions, getSsecPlugin;
var init_dist_es55 = __esm({
  "node_modules/@aws-sdk/middleware-ssec/dist-es/index.js"() {
    "use strict";
    ssecMiddlewareOptions = {
      name: "ssecMiddleware",
      step: "initialize",
      tags: ["SSE"],
      override: true
    };
    getSsecPlugin = (config) => ({
      applyToStack: (clientStack) => {
        clientStack.add(ssecMiddleware(config), ssecMiddlewareOptions);
      }
    });
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/CompleteMultipartUploadCommand.js
var CompleteMultipartUploadCommand;
var init_CompleteMultipartUploadCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/CompleteMultipartUploadCommand.js"() {
    "use strict";
    init_dist_es29();
    init_dist_es55();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_models_0();
    init_Aws_restXml();
    CompleteMultipartUploadCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" },
      Key: { type: "contextParams", name: "Key" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config),
        getSsecPlugin(config)
      ];
    }).s("AmazonS3", "CompleteMultipartUpload", {}).n("S3Client", "CompleteMultipartUploadCommand").f(CompleteMultipartUploadRequestFilterSensitiveLog, CompleteMultipartUploadOutputFilterSensitiveLog).ser(se_CompleteMultipartUploadCommand).de(de_CompleteMultipartUploadCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/CopyObjectCommand.js
var CopyObjectCommand;
var init_CopyObjectCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/CopyObjectCommand.js"() {
    "use strict";
    init_dist_es29();
    init_dist_es55();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_models_0();
    init_Aws_restXml();
    CopyObjectCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      DisableS3ExpressSessionAuth: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" },
      Key: { type: "contextParams", name: "Key" },
      CopySource: { type: "contextParams", name: "CopySource" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config),
        getSsecPlugin(config)
      ];
    }).s("AmazonS3", "CopyObject", {}).n("S3Client", "CopyObjectCommand").f(CopyObjectRequestFilterSensitiveLog, CopyObjectOutputFilterSensitiveLog).ser(se_CopyObjectCommand).de(de_CopyObjectCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/middleware-location-constraint/dist-es/index.js
function locationConstraintMiddleware(options) {
  return (next) => async (args) => {
    const { CreateBucketConfiguration } = args.input;
    const region = await options.region();
    if (!CreateBucketConfiguration?.LocationConstraint && !CreateBucketConfiguration?.Location) {
      if (region !== "us-east-1") {
        args.input.CreateBucketConfiguration = args.input.CreateBucketConfiguration ?? {};
        args.input.CreateBucketConfiguration.LocationConstraint = region;
      }
    }
    return next(args);
  };
}
var locationConstraintMiddlewareOptions, getLocationConstraintPlugin;
var init_dist_es56 = __esm({
  "node_modules/@aws-sdk/middleware-location-constraint/dist-es/index.js"() {
    "use strict";
    locationConstraintMiddlewareOptions = {
      step: "initialize",
      tags: ["LOCATION_CONSTRAINT", "CREATE_BUCKET_CONFIGURATION"],
      name: "locationConstraintMiddleware",
      override: true
    };
    getLocationConstraintPlugin = (config) => ({
      applyToStack: (clientStack) => {
        clientStack.add(locationConstraintMiddleware(config), locationConstraintMiddlewareOptions);
      }
    });
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/CreateBucketCommand.js
var CreateBucketCommand;
var init_CreateBucketCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/CreateBucketCommand.js"() {
    "use strict";
    init_dist_es56();
    init_dist_es29();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    CreateBucketCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      DisableAccessPoints: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config),
        getLocationConstraintPlugin(config)
      ];
    }).s("AmazonS3", "CreateBucket", {}).n("S3Client", "CreateBucketCommand").f(void 0, void 0).ser(se_CreateBucketCommand).de(de_CreateBucketCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/CreateBucketMetadataConfigurationCommand.js
var CreateBucketMetadataConfigurationCommand;
var init_CreateBucketMetadataConfigurationCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/CreateBucketMetadataConfigurationCommand.js"() {
    "use strict";
    init_dist_es24();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    CreateBucketMetadataConfigurationCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getFlexibleChecksumsPlugin(config, {
          requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
          requestChecksumRequired: true
        })
      ];
    }).s("AmazonS3", "CreateBucketMetadataConfiguration", {}).n("S3Client", "CreateBucketMetadataConfigurationCommand").f(void 0, void 0).ser(se_CreateBucketMetadataConfigurationCommand).de(de_CreateBucketMetadataConfigurationCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/CreateBucketMetadataTableConfigurationCommand.js
var CreateBucketMetadataTableConfigurationCommand;
var init_CreateBucketMetadataTableConfigurationCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/CreateBucketMetadataTableConfigurationCommand.js"() {
    "use strict";
    init_dist_es24();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    CreateBucketMetadataTableConfigurationCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getFlexibleChecksumsPlugin(config, {
          requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
          requestChecksumRequired: true
        })
      ];
    }).s("AmazonS3", "CreateBucketMetadataTableConfiguration", {}).n("S3Client", "CreateBucketMetadataTableConfigurationCommand").f(void 0, void 0).ser(se_CreateBucketMetadataTableConfigurationCommand).de(de_CreateBucketMetadataTableConfigurationCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/CreateMultipartUploadCommand.js
var CreateMultipartUploadCommand;
var init_CreateMultipartUploadCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/CreateMultipartUploadCommand.js"() {
    "use strict";
    init_dist_es29();
    init_dist_es55();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_models_0();
    init_Aws_restXml();
    CreateMultipartUploadCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" },
      Key: { type: "contextParams", name: "Key" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config),
        getSsecPlugin(config)
      ];
    }).s("AmazonS3", "CreateMultipartUpload", {}).n("S3Client", "CreateMultipartUploadCommand").f(CreateMultipartUploadRequestFilterSensitiveLog, CreateMultipartUploadOutputFilterSensitiveLog).ser(se_CreateMultipartUploadCommand).de(de_CreateMultipartUploadCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteBucketAnalyticsConfigurationCommand.js
var DeleteBucketAnalyticsConfigurationCommand;
var init_DeleteBucketAnalyticsConfigurationCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteBucketAnalyticsConfigurationCommand.js"() {
    "use strict";
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    DeleteBucketAnalyticsConfigurationCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "DeleteBucketAnalyticsConfiguration", {}).n("S3Client", "DeleteBucketAnalyticsConfigurationCommand").f(void 0, void 0).ser(se_DeleteBucketAnalyticsConfigurationCommand).de(de_DeleteBucketAnalyticsConfigurationCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteBucketCommand.js
var DeleteBucketCommand;
var init_DeleteBucketCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteBucketCommand.js"() {
    "use strict";
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    DeleteBucketCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "DeleteBucket", {}).n("S3Client", "DeleteBucketCommand").f(void 0, void 0).ser(se_DeleteBucketCommand).de(de_DeleteBucketCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteBucketCorsCommand.js
var DeleteBucketCorsCommand;
var init_DeleteBucketCorsCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteBucketCorsCommand.js"() {
    "use strict";
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    DeleteBucketCorsCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "DeleteBucketCors", {}).n("S3Client", "DeleteBucketCorsCommand").f(void 0, void 0).ser(se_DeleteBucketCorsCommand).de(de_DeleteBucketCorsCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteBucketEncryptionCommand.js
var DeleteBucketEncryptionCommand;
var init_DeleteBucketEncryptionCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteBucketEncryptionCommand.js"() {
    "use strict";
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    DeleteBucketEncryptionCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "DeleteBucketEncryption", {}).n("S3Client", "DeleteBucketEncryptionCommand").f(void 0, void 0).ser(se_DeleteBucketEncryptionCommand).de(de_DeleteBucketEncryptionCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteBucketIntelligentTieringConfigurationCommand.js
var DeleteBucketIntelligentTieringConfigurationCommand;
var init_DeleteBucketIntelligentTieringConfigurationCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteBucketIntelligentTieringConfigurationCommand.js"() {
    "use strict";
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    DeleteBucketIntelligentTieringConfigurationCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "DeleteBucketIntelligentTieringConfiguration", {}).n("S3Client", "DeleteBucketIntelligentTieringConfigurationCommand").f(void 0, void 0).ser(se_DeleteBucketIntelligentTieringConfigurationCommand).de(de_DeleteBucketIntelligentTieringConfigurationCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteBucketInventoryConfigurationCommand.js
var DeleteBucketInventoryConfigurationCommand;
var init_DeleteBucketInventoryConfigurationCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteBucketInventoryConfigurationCommand.js"() {
    "use strict";
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    DeleteBucketInventoryConfigurationCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "DeleteBucketInventoryConfiguration", {}).n("S3Client", "DeleteBucketInventoryConfigurationCommand").f(void 0, void 0).ser(se_DeleteBucketInventoryConfigurationCommand).de(de_DeleteBucketInventoryConfigurationCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteBucketLifecycleCommand.js
var DeleteBucketLifecycleCommand;
var init_DeleteBucketLifecycleCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteBucketLifecycleCommand.js"() {
    "use strict";
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    DeleteBucketLifecycleCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "DeleteBucketLifecycle", {}).n("S3Client", "DeleteBucketLifecycleCommand").f(void 0, void 0).ser(se_DeleteBucketLifecycleCommand).de(de_DeleteBucketLifecycleCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteBucketMetadataConfigurationCommand.js
var DeleteBucketMetadataConfigurationCommand;
var init_DeleteBucketMetadataConfigurationCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteBucketMetadataConfigurationCommand.js"() {
    "use strict";
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    DeleteBucketMetadataConfigurationCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "DeleteBucketMetadataConfiguration", {}).n("S3Client", "DeleteBucketMetadataConfigurationCommand").f(void 0, void 0).ser(se_DeleteBucketMetadataConfigurationCommand).de(de_DeleteBucketMetadataConfigurationCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteBucketMetadataTableConfigurationCommand.js
var DeleteBucketMetadataTableConfigurationCommand;
var init_DeleteBucketMetadataTableConfigurationCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteBucketMetadataTableConfigurationCommand.js"() {
    "use strict";
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    DeleteBucketMetadataTableConfigurationCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "DeleteBucketMetadataTableConfiguration", {}).n("S3Client", "DeleteBucketMetadataTableConfigurationCommand").f(void 0, void 0).ser(se_DeleteBucketMetadataTableConfigurationCommand).de(de_DeleteBucketMetadataTableConfigurationCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteBucketMetricsConfigurationCommand.js
var DeleteBucketMetricsConfigurationCommand;
var init_DeleteBucketMetricsConfigurationCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteBucketMetricsConfigurationCommand.js"() {
    "use strict";
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    DeleteBucketMetricsConfigurationCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "DeleteBucketMetricsConfiguration", {}).n("S3Client", "DeleteBucketMetricsConfigurationCommand").f(void 0, void 0).ser(se_DeleteBucketMetricsConfigurationCommand).de(de_DeleteBucketMetricsConfigurationCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteBucketOwnershipControlsCommand.js
var DeleteBucketOwnershipControlsCommand;
var init_DeleteBucketOwnershipControlsCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteBucketOwnershipControlsCommand.js"() {
    "use strict";
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    DeleteBucketOwnershipControlsCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "DeleteBucketOwnershipControls", {}).n("S3Client", "DeleteBucketOwnershipControlsCommand").f(void 0, void 0).ser(se_DeleteBucketOwnershipControlsCommand).de(de_DeleteBucketOwnershipControlsCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteBucketPolicyCommand.js
var DeleteBucketPolicyCommand;
var init_DeleteBucketPolicyCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteBucketPolicyCommand.js"() {
    "use strict";
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    DeleteBucketPolicyCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "DeleteBucketPolicy", {}).n("S3Client", "DeleteBucketPolicyCommand").f(void 0, void 0).ser(se_DeleteBucketPolicyCommand).de(de_DeleteBucketPolicyCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteBucketReplicationCommand.js
var DeleteBucketReplicationCommand;
var init_DeleteBucketReplicationCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteBucketReplicationCommand.js"() {
    "use strict";
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    DeleteBucketReplicationCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "DeleteBucketReplication", {}).n("S3Client", "DeleteBucketReplicationCommand").f(void 0, void 0).ser(se_DeleteBucketReplicationCommand).de(de_DeleteBucketReplicationCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteBucketTaggingCommand.js
var DeleteBucketTaggingCommand;
var init_DeleteBucketTaggingCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteBucketTaggingCommand.js"() {
    "use strict";
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    DeleteBucketTaggingCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "DeleteBucketTagging", {}).n("S3Client", "DeleteBucketTaggingCommand").f(void 0, void 0).ser(se_DeleteBucketTaggingCommand).de(de_DeleteBucketTaggingCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteBucketWebsiteCommand.js
var DeleteBucketWebsiteCommand;
var init_DeleteBucketWebsiteCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteBucketWebsiteCommand.js"() {
    "use strict";
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    DeleteBucketWebsiteCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "DeleteBucketWebsite", {}).n("S3Client", "DeleteBucketWebsiteCommand").f(void 0, void 0).ser(se_DeleteBucketWebsiteCommand).de(de_DeleteBucketWebsiteCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteObjectCommand.js
var DeleteObjectCommand;
var init_DeleteObjectCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteObjectCommand.js"() {
    "use strict";
    init_dist_es29();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    DeleteObjectCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" },
      Key: { type: "contextParams", name: "Key" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "DeleteObject", {}).n("S3Client", "DeleteObjectCommand").f(void 0, void 0).ser(se_DeleteObjectCommand).de(de_DeleteObjectCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteObjectsCommand.js
var DeleteObjectsCommand;
var init_DeleteObjectsCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteObjectsCommand.js"() {
    "use strict";
    init_dist_es24();
    init_dist_es29();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    DeleteObjectsCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getFlexibleChecksumsPlugin(config, {
          requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
          requestChecksumRequired: true
        }),
        getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "DeleteObjects", {}).n("S3Client", "DeleteObjectsCommand").f(void 0, void 0).ser(se_DeleteObjectsCommand).de(de_DeleteObjectsCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteObjectTaggingCommand.js
var DeleteObjectTaggingCommand;
var init_DeleteObjectTaggingCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/DeleteObjectTaggingCommand.js"() {
    "use strict";
    init_dist_es29();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    DeleteObjectTaggingCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "DeleteObjectTagging", {}).n("S3Client", "DeleteObjectTaggingCommand").f(void 0, void 0).ser(se_DeleteObjectTaggingCommand).de(de_DeleteObjectTaggingCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/DeletePublicAccessBlockCommand.js
var DeletePublicAccessBlockCommand;
var init_DeletePublicAccessBlockCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/DeletePublicAccessBlockCommand.js"() {
    "use strict";
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    DeletePublicAccessBlockCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "DeletePublicAccessBlock", {}).n("S3Client", "DeletePublicAccessBlockCommand").f(void 0, void 0).ser(se_DeletePublicAccessBlockCommand).de(de_DeletePublicAccessBlockCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketAccelerateConfigurationCommand.js
var GetBucketAccelerateConfigurationCommand;
var init_GetBucketAccelerateConfigurationCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketAccelerateConfigurationCommand.js"() {
    "use strict";
    init_dist_es29();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    GetBucketAccelerateConfigurationCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetBucketAccelerateConfiguration", {}).n("S3Client", "GetBucketAccelerateConfigurationCommand").f(void 0, void 0).ser(se_GetBucketAccelerateConfigurationCommand).de(de_GetBucketAccelerateConfigurationCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketAclCommand.js
var GetBucketAclCommand;
var init_GetBucketAclCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketAclCommand.js"() {
    "use strict";
    init_dist_es29();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    GetBucketAclCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetBucketAcl", {}).n("S3Client", "GetBucketAclCommand").f(void 0, void 0).ser(se_GetBucketAclCommand).de(de_GetBucketAclCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketAnalyticsConfigurationCommand.js
var GetBucketAnalyticsConfigurationCommand;
var init_GetBucketAnalyticsConfigurationCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketAnalyticsConfigurationCommand.js"() {
    "use strict";
    init_dist_es29();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    GetBucketAnalyticsConfigurationCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetBucketAnalyticsConfiguration", {}).n("S3Client", "GetBucketAnalyticsConfigurationCommand").f(void 0, void 0).ser(se_GetBucketAnalyticsConfigurationCommand).de(de_GetBucketAnalyticsConfigurationCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketCorsCommand.js
var GetBucketCorsCommand;
var init_GetBucketCorsCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketCorsCommand.js"() {
    "use strict";
    init_dist_es29();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    GetBucketCorsCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetBucketCors", {}).n("S3Client", "GetBucketCorsCommand").f(void 0, void 0).ser(se_GetBucketCorsCommand).de(de_GetBucketCorsCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketEncryptionCommand.js
var GetBucketEncryptionCommand;
var init_GetBucketEncryptionCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketEncryptionCommand.js"() {
    "use strict";
    init_dist_es29();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_models_0();
    init_Aws_restXml();
    GetBucketEncryptionCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetBucketEncryption", {}).n("S3Client", "GetBucketEncryptionCommand").f(void 0, GetBucketEncryptionOutputFilterSensitiveLog).ser(se_GetBucketEncryptionCommand).de(de_GetBucketEncryptionCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketIntelligentTieringConfigurationCommand.js
var GetBucketIntelligentTieringConfigurationCommand;
var init_GetBucketIntelligentTieringConfigurationCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketIntelligentTieringConfigurationCommand.js"() {
    "use strict";
    init_dist_es29();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    GetBucketIntelligentTieringConfigurationCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetBucketIntelligentTieringConfiguration", {}).n("S3Client", "GetBucketIntelligentTieringConfigurationCommand").f(void 0, void 0).ser(se_GetBucketIntelligentTieringConfigurationCommand).de(de_GetBucketIntelligentTieringConfigurationCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketInventoryConfigurationCommand.js
var GetBucketInventoryConfigurationCommand;
var init_GetBucketInventoryConfigurationCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketInventoryConfigurationCommand.js"() {
    "use strict";
    init_dist_es29();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_models_0();
    init_Aws_restXml();
    GetBucketInventoryConfigurationCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetBucketInventoryConfiguration", {}).n("S3Client", "GetBucketInventoryConfigurationCommand").f(void 0, GetBucketInventoryConfigurationOutputFilterSensitiveLog).ser(se_GetBucketInventoryConfigurationCommand).de(de_GetBucketInventoryConfigurationCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketLifecycleConfigurationCommand.js
var GetBucketLifecycleConfigurationCommand;
var init_GetBucketLifecycleConfigurationCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketLifecycleConfigurationCommand.js"() {
    "use strict";
    init_dist_es29();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    GetBucketLifecycleConfigurationCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetBucketLifecycleConfiguration", {}).n("S3Client", "GetBucketLifecycleConfigurationCommand").f(void 0, void 0).ser(se_GetBucketLifecycleConfigurationCommand).de(de_GetBucketLifecycleConfigurationCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketLocationCommand.js
var GetBucketLocationCommand;
var init_GetBucketLocationCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketLocationCommand.js"() {
    "use strict";
    init_dist_es29();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    GetBucketLocationCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetBucketLocation", {}).n("S3Client", "GetBucketLocationCommand").f(void 0, void 0).ser(se_GetBucketLocationCommand).de(de_GetBucketLocationCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketLoggingCommand.js
var GetBucketLoggingCommand;
var init_GetBucketLoggingCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketLoggingCommand.js"() {
    "use strict";
    init_dist_es29();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    GetBucketLoggingCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetBucketLogging", {}).n("S3Client", "GetBucketLoggingCommand").f(void 0, void 0).ser(se_GetBucketLoggingCommand).de(de_GetBucketLoggingCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketMetadataConfigurationCommand.js
var GetBucketMetadataConfigurationCommand;
var init_GetBucketMetadataConfigurationCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketMetadataConfigurationCommand.js"() {
    "use strict";
    init_dist_es29();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    GetBucketMetadataConfigurationCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetBucketMetadataConfiguration", {}).n("S3Client", "GetBucketMetadataConfigurationCommand").f(void 0, void 0).ser(se_GetBucketMetadataConfigurationCommand).de(de_GetBucketMetadataConfigurationCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketMetadataTableConfigurationCommand.js
var GetBucketMetadataTableConfigurationCommand;
var init_GetBucketMetadataTableConfigurationCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketMetadataTableConfigurationCommand.js"() {
    "use strict";
    init_dist_es29();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    GetBucketMetadataTableConfigurationCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetBucketMetadataTableConfiguration", {}).n("S3Client", "GetBucketMetadataTableConfigurationCommand").f(void 0, void 0).ser(se_GetBucketMetadataTableConfigurationCommand).de(de_GetBucketMetadataTableConfigurationCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketMetricsConfigurationCommand.js
var GetBucketMetricsConfigurationCommand;
var init_GetBucketMetricsConfigurationCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketMetricsConfigurationCommand.js"() {
    "use strict";
    init_dist_es29();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    GetBucketMetricsConfigurationCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetBucketMetricsConfiguration", {}).n("S3Client", "GetBucketMetricsConfigurationCommand").f(void 0, void 0).ser(se_GetBucketMetricsConfigurationCommand).de(de_GetBucketMetricsConfigurationCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketNotificationConfigurationCommand.js
var GetBucketNotificationConfigurationCommand;
var init_GetBucketNotificationConfigurationCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketNotificationConfigurationCommand.js"() {
    "use strict";
    init_dist_es29();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    GetBucketNotificationConfigurationCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetBucketNotificationConfiguration", {}).n("S3Client", "GetBucketNotificationConfigurationCommand").f(void 0, void 0).ser(se_GetBucketNotificationConfigurationCommand).de(de_GetBucketNotificationConfigurationCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketOwnershipControlsCommand.js
var GetBucketOwnershipControlsCommand;
var init_GetBucketOwnershipControlsCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketOwnershipControlsCommand.js"() {
    "use strict";
    init_dist_es29();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    GetBucketOwnershipControlsCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetBucketOwnershipControls", {}).n("S3Client", "GetBucketOwnershipControlsCommand").f(void 0, void 0).ser(se_GetBucketOwnershipControlsCommand).de(de_GetBucketOwnershipControlsCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketPolicyCommand.js
var GetBucketPolicyCommand;
var init_GetBucketPolicyCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketPolicyCommand.js"() {
    "use strict";
    init_dist_es29();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    GetBucketPolicyCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetBucketPolicy", {}).n("S3Client", "GetBucketPolicyCommand").f(void 0, void 0).ser(se_GetBucketPolicyCommand).de(de_GetBucketPolicyCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketPolicyStatusCommand.js
var GetBucketPolicyStatusCommand;
var init_GetBucketPolicyStatusCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketPolicyStatusCommand.js"() {
    "use strict";
    init_dist_es29();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    GetBucketPolicyStatusCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetBucketPolicyStatus", {}).n("S3Client", "GetBucketPolicyStatusCommand").f(void 0, void 0).ser(se_GetBucketPolicyStatusCommand).de(de_GetBucketPolicyStatusCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketReplicationCommand.js
var GetBucketReplicationCommand;
var init_GetBucketReplicationCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketReplicationCommand.js"() {
    "use strict";
    init_dist_es29();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    GetBucketReplicationCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetBucketReplication", {}).n("S3Client", "GetBucketReplicationCommand").f(void 0, void 0).ser(se_GetBucketReplicationCommand).de(de_GetBucketReplicationCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketRequestPaymentCommand.js
var GetBucketRequestPaymentCommand;
var init_GetBucketRequestPaymentCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketRequestPaymentCommand.js"() {
    "use strict";
    init_dist_es29();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    GetBucketRequestPaymentCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetBucketRequestPayment", {}).n("S3Client", "GetBucketRequestPaymentCommand").f(void 0, void 0).ser(se_GetBucketRequestPaymentCommand).de(de_GetBucketRequestPaymentCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketTaggingCommand.js
var GetBucketTaggingCommand;
var init_GetBucketTaggingCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketTaggingCommand.js"() {
    "use strict";
    init_dist_es29();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    GetBucketTaggingCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetBucketTagging", {}).n("S3Client", "GetBucketTaggingCommand").f(void 0, void 0).ser(se_GetBucketTaggingCommand).de(de_GetBucketTaggingCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketVersioningCommand.js
var GetBucketVersioningCommand;
var init_GetBucketVersioningCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketVersioningCommand.js"() {
    "use strict";
    init_dist_es29();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    GetBucketVersioningCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetBucketVersioning", {}).n("S3Client", "GetBucketVersioningCommand").f(void 0, void 0).ser(se_GetBucketVersioningCommand).de(de_GetBucketVersioningCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketWebsiteCommand.js
var GetBucketWebsiteCommand;
var init_GetBucketWebsiteCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/GetBucketWebsiteCommand.js"() {
    "use strict";
    init_dist_es29();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    GetBucketWebsiteCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetBucketWebsite", {}).n("S3Client", "GetBucketWebsiteCommand").f(void 0, void 0).ser(se_GetBucketWebsiteCommand).de(de_GetBucketWebsiteCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/GetObjectAclCommand.js
var GetObjectAclCommand;
var init_GetObjectAclCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/GetObjectAclCommand.js"() {
    "use strict";
    init_dist_es29();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    GetObjectAclCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" },
      Key: { type: "contextParams", name: "Key" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetObjectAcl", {}).n("S3Client", "GetObjectAclCommand").f(void 0, void 0).ser(se_GetObjectAclCommand).de(de_GetObjectAclCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/GetObjectAttributesCommand.js
var GetObjectAttributesCommand;
var init_GetObjectAttributesCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/GetObjectAttributesCommand.js"() {
    "use strict";
    init_dist_es29();
    init_dist_es55();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_models_0();
    init_Aws_restXml();
    GetObjectAttributesCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config),
        getSsecPlugin(config)
      ];
    }).s("AmazonS3", "GetObjectAttributes", {}).n("S3Client", "GetObjectAttributesCommand").f(GetObjectAttributesRequestFilterSensitiveLog, void 0).ser(se_GetObjectAttributesCommand).de(de_GetObjectAttributesCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/GetObjectCommand.js
var GetObjectCommand;
var init_GetObjectCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/GetObjectCommand.js"() {
    "use strict";
    init_dist_es24();
    init_dist_es29();
    init_dist_es55();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_models_0();
    init_Aws_restXml();
    GetObjectCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" },
      Key: { type: "contextParams", name: "Key" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getFlexibleChecksumsPlugin(config, {
          requestChecksumRequired: false,
          requestValidationModeMember: "ChecksumMode",
          responseAlgorithms: ["CRC64NVME", "CRC32", "CRC32C", "SHA256", "SHA1"]
        }),
        getSsecPlugin(config),
        getS3ExpiresMiddlewarePlugin(config)
      ];
    }).s("AmazonS3", "GetObject", {}).n("S3Client", "GetObjectCommand").f(GetObjectRequestFilterSensitiveLog, GetObjectOutputFilterSensitiveLog).ser(se_GetObjectCommand).de(de_GetObjectCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/GetObjectLegalHoldCommand.js
var GetObjectLegalHoldCommand;
var init_GetObjectLegalHoldCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/GetObjectLegalHoldCommand.js"() {
    "use strict";
    init_dist_es29();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    GetObjectLegalHoldCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetObjectLegalHold", {}).n("S3Client", "GetObjectLegalHoldCommand").f(void 0, void 0).ser(se_GetObjectLegalHoldCommand).de(de_GetObjectLegalHoldCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/GetObjectLockConfigurationCommand.js
var GetObjectLockConfigurationCommand;
var init_GetObjectLockConfigurationCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/GetObjectLockConfigurationCommand.js"() {
    "use strict";
    init_dist_es29();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    GetObjectLockConfigurationCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetObjectLockConfiguration", {}).n("S3Client", "GetObjectLockConfigurationCommand").f(void 0, void 0).ser(se_GetObjectLockConfigurationCommand).de(de_GetObjectLockConfigurationCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/GetObjectRetentionCommand.js
var GetObjectRetentionCommand;
var init_GetObjectRetentionCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/GetObjectRetentionCommand.js"() {
    "use strict";
    init_dist_es29();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    GetObjectRetentionCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetObjectRetention", {}).n("S3Client", "GetObjectRetentionCommand").f(void 0, void 0).ser(se_GetObjectRetentionCommand).de(de_GetObjectRetentionCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/GetObjectTaggingCommand.js
var GetObjectTaggingCommand;
var init_GetObjectTaggingCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/GetObjectTaggingCommand.js"() {
    "use strict";
    init_dist_es29();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    GetObjectTaggingCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetObjectTagging", {}).n("S3Client", "GetObjectTaggingCommand").f(void 0, void 0).ser(se_GetObjectTaggingCommand).de(de_GetObjectTaggingCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/GetObjectTorrentCommand.js
var GetObjectTorrentCommand;
var init_GetObjectTorrentCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/GetObjectTorrentCommand.js"() {
    "use strict";
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_models_0();
    init_Aws_restXml();
    GetObjectTorrentCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "GetObjectTorrent", {}).n("S3Client", "GetObjectTorrentCommand").f(void 0, GetObjectTorrentOutputFilterSensitiveLog).ser(se_GetObjectTorrentCommand).de(de_GetObjectTorrentCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/GetPublicAccessBlockCommand.js
var GetPublicAccessBlockCommand;
var init_GetPublicAccessBlockCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/GetPublicAccessBlockCommand.js"() {
    "use strict";
    init_dist_es29();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    GetPublicAccessBlockCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetPublicAccessBlock", {}).n("S3Client", "GetPublicAccessBlockCommand").f(void 0, void 0).ser(se_GetPublicAccessBlockCommand).de(de_GetPublicAccessBlockCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/HeadBucketCommand.js
var HeadBucketCommand;
var init_HeadBucketCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/HeadBucketCommand.js"() {
    "use strict";
    init_dist_es29();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    HeadBucketCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "HeadBucket", {}).n("S3Client", "HeadBucketCommand").f(void 0, void 0).ser(se_HeadBucketCommand).de(de_HeadBucketCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/HeadObjectCommand.js
var HeadObjectCommand;
var init_HeadObjectCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/HeadObjectCommand.js"() {
    "use strict";
    init_dist_es29();
    init_dist_es55();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_models_0();
    init_Aws_restXml();
    HeadObjectCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" },
      Key: { type: "contextParams", name: "Key" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config),
        getSsecPlugin(config),
        getS3ExpiresMiddlewarePlugin(config)
      ];
    }).s("AmazonS3", "HeadObject", {}).n("S3Client", "HeadObjectCommand").f(HeadObjectRequestFilterSensitiveLog, HeadObjectOutputFilterSensitiveLog).ser(se_HeadObjectCommand).de(de_HeadObjectCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/ListBucketAnalyticsConfigurationsCommand.js
var ListBucketAnalyticsConfigurationsCommand;
var init_ListBucketAnalyticsConfigurationsCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/ListBucketAnalyticsConfigurationsCommand.js"() {
    "use strict";
    init_dist_es29();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    ListBucketAnalyticsConfigurationsCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "ListBucketAnalyticsConfigurations", {}).n("S3Client", "ListBucketAnalyticsConfigurationsCommand").f(void 0, void 0).ser(se_ListBucketAnalyticsConfigurationsCommand).de(de_ListBucketAnalyticsConfigurationsCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/ListBucketIntelligentTieringConfigurationsCommand.js
var ListBucketIntelligentTieringConfigurationsCommand;
var init_ListBucketIntelligentTieringConfigurationsCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/ListBucketIntelligentTieringConfigurationsCommand.js"() {
    "use strict";
    init_dist_es29();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    ListBucketIntelligentTieringConfigurationsCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "ListBucketIntelligentTieringConfigurations", {}).n("S3Client", "ListBucketIntelligentTieringConfigurationsCommand").f(void 0, void 0).ser(se_ListBucketIntelligentTieringConfigurationsCommand).de(de_ListBucketIntelligentTieringConfigurationsCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/ListBucketInventoryConfigurationsCommand.js
var ListBucketInventoryConfigurationsCommand;
var init_ListBucketInventoryConfigurationsCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/ListBucketInventoryConfigurationsCommand.js"() {
    "use strict";
    init_dist_es29();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_models_0();
    init_Aws_restXml();
    ListBucketInventoryConfigurationsCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "ListBucketInventoryConfigurations", {}).n("S3Client", "ListBucketInventoryConfigurationsCommand").f(void 0, ListBucketInventoryConfigurationsOutputFilterSensitiveLog).ser(se_ListBucketInventoryConfigurationsCommand).de(de_ListBucketInventoryConfigurationsCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/ListBucketMetricsConfigurationsCommand.js
var ListBucketMetricsConfigurationsCommand;
var init_ListBucketMetricsConfigurationsCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/ListBucketMetricsConfigurationsCommand.js"() {
    "use strict";
    init_dist_es29();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    ListBucketMetricsConfigurationsCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "ListBucketMetricsConfigurations", {}).n("S3Client", "ListBucketMetricsConfigurationsCommand").f(void 0, void 0).ser(se_ListBucketMetricsConfigurationsCommand).de(de_ListBucketMetricsConfigurationsCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/ListBucketsCommand.js
var ListBucketsCommand;
var init_ListBucketsCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/ListBucketsCommand.js"() {
    "use strict";
    init_dist_es29();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    ListBucketsCommand = class extends Command.classBuilder().ep(commonParams).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "ListBuckets", {}).n("S3Client", "ListBucketsCommand").f(void 0, void 0).ser(se_ListBucketsCommand).de(de_ListBucketsCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/ListDirectoryBucketsCommand.js
var ListDirectoryBucketsCommand;
var init_ListDirectoryBucketsCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/ListDirectoryBucketsCommand.js"() {
    "use strict";
    init_dist_es29();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    ListDirectoryBucketsCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "ListDirectoryBuckets", {}).n("S3Client", "ListDirectoryBucketsCommand").f(void 0, void 0).ser(se_ListDirectoryBucketsCommand).de(de_ListDirectoryBucketsCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/ListMultipartUploadsCommand.js
var ListMultipartUploadsCommand;
var init_ListMultipartUploadsCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/ListMultipartUploadsCommand.js"() {
    "use strict";
    init_dist_es29();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    ListMultipartUploadsCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" },
      Prefix: { type: "contextParams", name: "Prefix" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "ListMultipartUploads", {}).n("S3Client", "ListMultipartUploadsCommand").f(void 0, void 0).ser(se_ListMultipartUploadsCommand).de(de_ListMultipartUploadsCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/ListObjectsCommand.js
var ListObjectsCommand;
var init_ListObjectsCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/ListObjectsCommand.js"() {
    "use strict";
    init_dist_es29();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    ListObjectsCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" },
      Prefix: { type: "contextParams", name: "Prefix" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "ListObjects", {}).n("S3Client", "ListObjectsCommand").f(void 0, void 0).ser(se_ListObjectsCommand).de(de_ListObjectsCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/ListObjectsV2Command.js
var ListObjectsV2Command;
var init_ListObjectsV2Command = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/ListObjectsV2Command.js"() {
    "use strict";
    init_dist_es29();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    ListObjectsV2Command = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" },
      Prefix: { type: "contextParams", name: "Prefix" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "ListObjectsV2", {}).n("S3Client", "ListObjectsV2Command").f(void 0, void 0).ser(se_ListObjectsV2Command).de(de_ListObjectsV2Command).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/ListObjectVersionsCommand.js
var ListObjectVersionsCommand;
var init_ListObjectVersionsCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/ListObjectVersionsCommand.js"() {
    "use strict";
    init_dist_es29();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    ListObjectVersionsCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" },
      Prefix: { type: "contextParams", name: "Prefix" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "ListObjectVersions", {}).n("S3Client", "ListObjectVersionsCommand").f(void 0, void 0).ser(se_ListObjectVersionsCommand).de(de_ListObjectVersionsCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/ListPartsCommand.js
var ListPartsCommand;
var init_ListPartsCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/ListPartsCommand.js"() {
    "use strict";
    init_dist_es29();
    init_dist_es55();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_models_1();
    init_Aws_restXml();
    ListPartsCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" },
      Key: { type: "contextParams", name: "Key" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config),
        getSsecPlugin(config)
      ];
    }).s("AmazonS3", "ListParts", {}).n("S3Client", "ListPartsCommand").f(ListPartsRequestFilterSensitiveLog, void 0).ser(se_ListPartsCommand).de(de_ListPartsCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketAccelerateConfigurationCommand.js
var PutBucketAccelerateConfigurationCommand;
var init_PutBucketAccelerateConfigurationCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketAccelerateConfigurationCommand.js"() {
    "use strict";
    init_dist_es24();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    PutBucketAccelerateConfigurationCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getFlexibleChecksumsPlugin(config, {
          requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
          requestChecksumRequired: false
        })
      ];
    }).s("AmazonS3", "PutBucketAccelerateConfiguration", {}).n("S3Client", "PutBucketAccelerateConfigurationCommand").f(void 0, void 0).ser(se_PutBucketAccelerateConfigurationCommand).de(de_PutBucketAccelerateConfigurationCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketAclCommand.js
var PutBucketAclCommand;
var init_PutBucketAclCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketAclCommand.js"() {
    "use strict";
    init_dist_es24();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    PutBucketAclCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getFlexibleChecksumsPlugin(config, {
          requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
          requestChecksumRequired: true
        })
      ];
    }).s("AmazonS3", "PutBucketAcl", {}).n("S3Client", "PutBucketAclCommand").f(void 0, void 0).ser(se_PutBucketAclCommand).de(de_PutBucketAclCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketAnalyticsConfigurationCommand.js
var PutBucketAnalyticsConfigurationCommand;
var init_PutBucketAnalyticsConfigurationCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketAnalyticsConfigurationCommand.js"() {
    "use strict";
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    PutBucketAnalyticsConfigurationCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "PutBucketAnalyticsConfiguration", {}).n("S3Client", "PutBucketAnalyticsConfigurationCommand").f(void 0, void 0).ser(se_PutBucketAnalyticsConfigurationCommand).de(de_PutBucketAnalyticsConfigurationCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketCorsCommand.js
var PutBucketCorsCommand;
var init_PutBucketCorsCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketCorsCommand.js"() {
    "use strict";
    init_dist_es24();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    PutBucketCorsCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getFlexibleChecksumsPlugin(config, {
          requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
          requestChecksumRequired: true
        })
      ];
    }).s("AmazonS3", "PutBucketCors", {}).n("S3Client", "PutBucketCorsCommand").f(void 0, void 0).ser(se_PutBucketCorsCommand).de(de_PutBucketCorsCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketEncryptionCommand.js
var PutBucketEncryptionCommand;
var init_PutBucketEncryptionCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketEncryptionCommand.js"() {
    "use strict";
    init_dist_es24();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_models_1();
    init_Aws_restXml();
    PutBucketEncryptionCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getFlexibleChecksumsPlugin(config, {
          requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
          requestChecksumRequired: true
        })
      ];
    }).s("AmazonS3", "PutBucketEncryption", {}).n("S3Client", "PutBucketEncryptionCommand").f(PutBucketEncryptionRequestFilterSensitiveLog, void 0).ser(se_PutBucketEncryptionCommand).de(de_PutBucketEncryptionCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketIntelligentTieringConfigurationCommand.js
var PutBucketIntelligentTieringConfigurationCommand;
var init_PutBucketIntelligentTieringConfigurationCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketIntelligentTieringConfigurationCommand.js"() {
    "use strict";
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    PutBucketIntelligentTieringConfigurationCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "PutBucketIntelligentTieringConfiguration", {}).n("S3Client", "PutBucketIntelligentTieringConfigurationCommand").f(void 0, void 0).ser(se_PutBucketIntelligentTieringConfigurationCommand).de(de_PutBucketIntelligentTieringConfigurationCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketInventoryConfigurationCommand.js
var PutBucketInventoryConfigurationCommand;
var init_PutBucketInventoryConfigurationCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketInventoryConfigurationCommand.js"() {
    "use strict";
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_models_1();
    init_Aws_restXml();
    PutBucketInventoryConfigurationCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "PutBucketInventoryConfiguration", {}).n("S3Client", "PutBucketInventoryConfigurationCommand").f(PutBucketInventoryConfigurationRequestFilterSensitiveLog, void 0).ser(se_PutBucketInventoryConfigurationCommand).de(de_PutBucketInventoryConfigurationCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketLifecycleConfigurationCommand.js
var PutBucketLifecycleConfigurationCommand;
var init_PutBucketLifecycleConfigurationCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketLifecycleConfigurationCommand.js"() {
    "use strict";
    init_dist_es24();
    init_dist_es29();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    PutBucketLifecycleConfigurationCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getFlexibleChecksumsPlugin(config, {
          requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
          requestChecksumRequired: true
        }),
        getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "PutBucketLifecycleConfiguration", {}).n("S3Client", "PutBucketLifecycleConfigurationCommand").f(void 0, void 0).ser(se_PutBucketLifecycleConfigurationCommand).de(de_PutBucketLifecycleConfigurationCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketLoggingCommand.js
var PutBucketLoggingCommand;
var init_PutBucketLoggingCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketLoggingCommand.js"() {
    "use strict";
    init_dist_es24();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    PutBucketLoggingCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getFlexibleChecksumsPlugin(config, {
          requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
          requestChecksumRequired: true
        })
      ];
    }).s("AmazonS3", "PutBucketLogging", {}).n("S3Client", "PutBucketLoggingCommand").f(void 0, void 0).ser(se_PutBucketLoggingCommand).de(de_PutBucketLoggingCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketMetricsConfigurationCommand.js
var PutBucketMetricsConfigurationCommand;
var init_PutBucketMetricsConfigurationCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketMetricsConfigurationCommand.js"() {
    "use strict";
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    PutBucketMetricsConfigurationCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "PutBucketMetricsConfiguration", {}).n("S3Client", "PutBucketMetricsConfigurationCommand").f(void 0, void 0).ser(se_PutBucketMetricsConfigurationCommand).de(de_PutBucketMetricsConfigurationCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketNotificationConfigurationCommand.js
var PutBucketNotificationConfigurationCommand;
var init_PutBucketNotificationConfigurationCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketNotificationConfigurationCommand.js"() {
    "use strict";
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    PutBucketNotificationConfigurationCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "PutBucketNotificationConfiguration", {}).n("S3Client", "PutBucketNotificationConfigurationCommand").f(void 0, void 0).ser(se_PutBucketNotificationConfigurationCommand).de(de_PutBucketNotificationConfigurationCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketOwnershipControlsCommand.js
var PutBucketOwnershipControlsCommand;
var init_PutBucketOwnershipControlsCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketOwnershipControlsCommand.js"() {
    "use strict";
    init_dist_es24();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    PutBucketOwnershipControlsCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getFlexibleChecksumsPlugin(config, {
          requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
          requestChecksumRequired: true
        })
      ];
    }).s("AmazonS3", "PutBucketOwnershipControls", {}).n("S3Client", "PutBucketOwnershipControlsCommand").f(void 0, void 0).ser(se_PutBucketOwnershipControlsCommand).de(de_PutBucketOwnershipControlsCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketPolicyCommand.js
var PutBucketPolicyCommand;
var init_PutBucketPolicyCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketPolicyCommand.js"() {
    "use strict";
    init_dist_es24();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    PutBucketPolicyCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getFlexibleChecksumsPlugin(config, {
          requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
          requestChecksumRequired: true
        })
      ];
    }).s("AmazonS3", "PutBucketPolicy", {}).n("S3Client", "PutBucketPolicyCommand").f(void 0, void 0).ser(se_PutBucketPolicyCommand).de(de_PutBucketPolicyCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketReplicationCommand.js
var PutBucketReplicationCommand;
var init_PutBucketReplicationCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketReplicationCommand.js"() {
    "use strict";
    init_dist_es24();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    PutBucketReplicationCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getFlexibleChecksumsPlugin(config, {
          requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
          requestChecksumRequired: true
        })
      ];
    }).s("AmazonS3", "PutBucketReplication", {}).n("S3Client", "PutBucketReplicationCommand").f(void 0, void 0).ser(se_PutBucketReplicationCommand).de(de_PutBucketReplicationCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketRequestPaymentCommand.js
var PutBucketRequestPaymentCommand;
var init_PutBucketRequestPaymentCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketRequestPaymentCommand.js"() {
    "use strict";
    init_dist_es24();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    PutBucketRequestPaymentCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getFlexibleChecksumsPlugin(config, {
          requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
          requestChecksumRequired: true
        })
      ];
    }).s("AmazonS3", "PutBucketRequestPayment", {}).n("S3Client", "PutBucketRequestPaymentCommand").f(void 0, void 0).ser(se_PutBucketRequestPaymentCommand).de(de_PutBucketRequestPaymentCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketTaggingCommand.js
var PutBucketTaggingCommand;
var init_PutBucketTaggingCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketTaggingCommand.js"() {
    "use strict";
    init_dist_es24();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    PutBucketTaggingCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getFlexibleChecksumsPlugin(config, {
          requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
          requestChecksumRequired: true
        })
      ];
    }).s("AmazonS3", "PutBucketTagging", {}).n("S3Client", "PutBucketTaggingCommand").f(void 0, void 0).ser(se_PutBucketTaggingCommand).de(de_PutBucketTaggingCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketVersioningCommand.js
var PutBucketVersioningCommand;
var init_PutBucketVersioningCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketVersioningCommand.js"() {
    "use strict";
    init_dist_es24();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    PutBucketVersioningCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getFlexibleChecksumsPlugin(config, {
          requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
          requestChecksumRequired: true
        })
      ];
    }).s("AmazonS3", "PutBucketVersioning", {}).n("S3Client", "PutBucketVersioningCommand").f(void 0, void 0).ser(se_PutBucketVersioningCommand).de(de_PutBucketVersioningCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketWebsiteCommand.js
var PutBucketWebsiteCommand;
var init_PutBucketWebsiteCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/PutBucketWebsiteCommand.js"() {
    "use strict";
    init_dist_es24();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    PutBucketWebsiteCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getFlexibleChecksumsPlugin(config, {
          requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
          requestChecksumRequired: true
        })
      ];
    }).s("AmazonS3", "PutBucketWebsite", {}).n("S3Client", "PutBucketWebsiteCommand").f(void 0, void 0).ser(se_PutBucketWebsiteCommand).de(de_PutBucketWebsiteCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/PutObjectAclCommand.js
var PutObjectAclCommand;
var init_PutObjectAclCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/PutObjectAclCommand.js"() {
    "use strict";
    init_dist_es24();
    init_dist_es29();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    PutObjectAclCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" },
      Key: { type: "contextParams", name: "Key" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getFlexibleChecksumsPlugin(config, {
          requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
          requestChecksumRequired: true
        }),
        getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "PutObjectAcl", {}).n("S3Client", "PutObjectAclCommand").f(void 0, void 0).ser(se_PutObjectAclCommand).de(de_PutObjectAclCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/PutObjectCommand.js
var PutObjectCommand;
var init_PutObjectCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/PutObjectCommand.js"() {
    "use strict";
    init_dist_es24();
    init_dist_es29();
    init_dist_es55();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_models_1();
    init_Aws_restXml();
    PutObjectCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" },
      Key: { type: "contextParams", name: "Key" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getFlexibleChecksumsPlugin(config, {
          requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
          requestChecksumRequired: false
        }),
        getCheckContentLengthHeaderPlugin(config),
        getThrow200ExceptionsPlugin(config),
        getSsecPlugin(config)
      ];
    }).s("AmazonS3", "PutObject", {}).n("S3Client", "PutObjectCommand").f(PutObjectRequestFilterSensitiveLog, PutObjectOutputFilterSensitiveLog).ser(se_PutObjectCommand).de(de_PutObjectCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/PutObjectLegalHoldCommand.js
var PutObjectLegalHoldCommand;
var init_PutObjectLegalHoldCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/PutObjectLegalHoldCommand.js"() {
    "use strict";
    init_dist_es24();
    init_dist_es29();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    PutObjectLegalHoldCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getFlexibleChecksumsPlugin(config, {
          requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
          requestChecksumRequired: true
        }),
        getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "PutObjectLegalHold", {}).n("S3Client", "PutObjectLegalHoldCommand").f(void 0, void 0).ser(se_PutObjectLegalHoldCommand).de(de_PutObjectLegalHoldCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/PutObjectLockConfigurationCommand.js
var PutObjectLockConfigurationCommand;
var init_PutObjectLockConfigurationCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/PutObjectLockConfigurationCommand.js"() {
    "use strict";
    init_dist_es24();
    init_dist_es29();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    PutObjectLockConfigurationCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getFlexibleChecksumsPlugin(config, {
          requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
          requestChecksumRequired: true
        }),
        getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "PutObjectLockConfiguration", {}).n("S3Client", "PutObjectLockConfigurationCommand").f(void 0, void 0).ser(se_PutObjectLockConfigurationCommand).de(de_PutObjectLockConfigurationCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/PutObjectRetentionCommand.js
var PutObjectRetentionCommand;
var init_PutObjectRetentionCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/PutObjectRetentionCommand.js"() {
    "use strict";
    init_dist_es24();
    init_dist_es29();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    PutObjectRetentionCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getFlexibleChecksumsPlugin(config, {
          requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
          requestChecksumRequired: true
        }),
        getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "PutObjectRetention", {}).n("S3Client", "PutObjectRetentionCommand").f(void 0, void 0).ser(se_PutObjectRetentionCommand).de(de_PutObjectRetentionCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/PutObjectTaggingCommand.js
var PutObjectTaggingCommand;
var init_PutObjectTaggingCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/PutObjectTaggingCommand.js"() {
    "use strict";
    init_dist_es24();
    init_dist_es29();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    PutObjectTaggingCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getFlexibleChecksumsPlugin(config, {
          requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
          requestChecksumRequired: true
        }),
        getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "PutObjectTagging", {}).n("S3Client", "PutObjectTaggingCommand").f(void 0, void 0).ser(se_PutObjectTaggingCommand).de(de_PutObjectTaggingCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/PutPublicAccessBlockCommand.js
var PutPublicAccessBlockCommand;
var init_PutPublicAccessBlockCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/PutPublicAccessBlockCommand.js"() {
    "use strict";
    init_dist_es24();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    PutPublicAccessBlockCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getFlexibleChecksumsPlugin(config, {
          requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
          requestChecksumRequired: true
        })
      ];
    }).s("AmazonS3", "PutPublicAccessBlock", {}).n("S3Client", "PutPublicAccessBlockCommand").f(void 0, void 0).ser(se_PutPublicAccessBlockCommand).de(de_PutPublicAccessBlockCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/RenameObjectCommand.js
var RenameObjectCommand;
var init_RenameObjectCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/RenameObjectCommand.js"() {
    "use strict";
    init_dist_es29();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    RenameObjectCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" },
      Key: { type: "contextParams", name: "Key" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "RenameObject", {}).n("S3Client", "RenameObjectCommand").f(void 0, void 0).ser(se_RenameObjectCommand).de(de_RenameObjectCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/RestoreObjectCommand.js
var RestoreObjectCommand;
var init_RestoreObjectCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/RestoreObjectCommand.js"() {
    "use strict";
    init_dist_es24();
    init_dist_es29();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_models_1();
    init_Aws_restXml();
    RestoreObjectCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getFlexibleChecksumsPlugin(config, {
          requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
          requestChecksumRequired: false
        }),
        getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "RestoreObject", {}).n("S3Client", "RestoreObjectCommand").f(RestoreObjectRequestFilterSensitiveLog, void 0).ser(se_RestoreObjectCommand).de(de_RestoreObjectCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/SelectObjectContentCommand.js
var SelectObjectContentCommand;
var init_SelectObjectContentCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/SelectObjectContentCommand.js"() {
    "use strict";
    init_dist_es29();
    init_dist_es55();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_models_1();
    init_Aws_restXml();
    SelectObjectContentCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config),
        getSsecPlugin(config)
      ];
    }).s("AmazonS3", "SelectObjectContent", {
      eventStream: {
        output: true
      }
    }).n("S3Client", "SelectObjectContentCommand").f(SelectObjectContentRequestFilterSensitiveLog, SelectObjectContentOutputFilterSensitiveLog).ser(se_SelectObjectContentCommand).de(de_SelectObjectContentCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/UpdateBucketMetadataInventoryTableConfigurationCommand.js
var UpdateBucketMetadataInventoryTableConfigurationCommand;
var init_UpdateBucketMetadataInventoryTableConfigurationCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/UpdateBucketMetadataInventoryTableConfigurationCommand.js"() {
    "use strict";
    init_dist_es24();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    UpdateBucketMetadataInventoryTableConfigurationCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getFlexibleChecksumsPlugin(config, {
          requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
          requestChecksumRequired: true
        })
      ];
    }).s("AmazonS3", "UpdateBucketMetadataInventoryTableConfiguration", {}).n("S3Client", "UpdateBucketMetadataInventoryTableConfigurationCommand").f(void 0, void 0).ser(se_UpdateBucketMetadataInventoryTableConfigurationCommand).de(de_UpdateBucketMetadataInventoryTableConfigurationCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/UpdateBucketMetadataJournalTableConfigurationCommand.js
var UpdateBucketMetadataJournalTableConfigurationCommand;
var init_UpdateBucketMetadataJournalTableConfigurationCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/UpdateBucketMetadataJournalTableConfigurationCommand.js"() {
    "use strict";
    init_dist_es24();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_Aws_restXml();
    UpdateBucketMetadataJournalTableConfigurationCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getFlexibleChecksumsPlugin(config, {
          requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
          requestChecksumRequired: true
        })
      ];
    }).s("AmazonS3", "UpdateBucketMetadataJournalTableConfiguration", {}).n("S3Client", "UpdateBucketMetadataJournalTableConfigurationCommand").f(void 0, void 0).ser(se_UpdateBucketMetadataJournalTableConfigurationCommand).de(de_UpdateBucketMetadataJournalTableConfigurationCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/UploadPartCommand.js
var UploadPartCommand;
var init_UploadPartCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/UploadPartCommand.js"() {
    "use strict";
    init_dist_es24();
    init_dist_es29();
    init_dist_es55();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_models_1();
    init_Aws_restXml();
    UploadPartCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      Bucket: { type: "contextParams", name: "Bucket" },
      Key: { type: "contextParams", name: "Key" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getFlexibleChecksumsPlugin(config, {
          requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
          requestChecksumRequired: false
        }),
        getThrow200ExceptionsPlugin(config),
        getSsecPlugin(config)
      ];
    }).s("AmazonS3", "UploadPart", {}).n("S3Client", "UploadPartCommand").f(UploadPartRequestFilterSensitiveLog, UploadPartOutputFilterSensitiveLog).ser(se_UploadPartCommand).de(de_UploadPartCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/UploadPartCopyCommand.js
var UploadPartCopyCommand;
var init_UploadPartCopyCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/UploadPartCopyCommand.js"() {
    "use strict";
    init_dist_es29();
    init_dist_es55();
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_models_1();
    init_Aws_restXml();
    UploadPartCopyCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      DisableS3ExpressSessionAuth: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
        getThrow200ExceptionsPlugin(config),
        getSsecPlugin(config)
      ];
    }).s("AmazonS3", "UploadPartCopy", {}).n("S3Client", "UploadPartCopyCommand").f(UploadPartCopyRequestFilterSensitiveLog, UploadPartCopyOutputFilterSensitiveLog).ser(se_UploadPartCopyCommand).de(de_UploadPartCopyCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/WriteGetObjectResponseCommand.js
var WriteGetObjectResponseCommand;
var init_WriteGetObjectResponseCommand = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/WriteGetObjectResponseCommand.js"() {
    "use strict";
    init_dist_es38();
    init_dist_es5();
    init_dist_es20();
    init_EndpointParameters();
    init_models_1();
    init_Aws_restXml();
    WriteGetObjectResponseCommand = class extends Command.classBuilder().ep({
      ...commonParams,
      UseObjectLambdaEndpoint: { type: "staticContextParams", value: true }
    }).m(function(Command2, cs2, config, o2) {
      return [
        getSerdePlugin(config, this.serialize, this.deserialize),
        getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
      ];
    }).s("AmazonS3", "WriteGetObjectResponse", {}).n("S3Client", "WriteGetObjectResponseCommand").f(WriteGetObjectResponseRequestFilterSensitiveLog, void 0).ser(se_WriteGetObjectResponseCommand).de(de_WriteGetObjectResponseCommand).build() {
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/S3.js
var commands, S3;
var init_S3 = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/S3.js"() {
    "use strict";
    init_dist_es20();
    init_AbortMultipartUploadCommand();
    init_CompleteMultipartUploadCommand();
    init_CopyObjectCommand();
    init_CreateBucketCommand();
    init_CreateBucketMetadataConfigurationCommand();
    init_CreateBucketMetadataTableConfigurationCommand();
    init_CreateMultipartUploadCommand();
    init_CreateSessionCommand();
    init_DeleteBucketAnalyticsConfigurationCommand();
    init_DeleteBucketCommand();
    init_DeleteBucketCorsCommand();
    init_DeleteBucketEncryptionCommand();
    init_DeleteBucketIntelligentTieringConfigurationCommand();
    init_DeleteBucketInventoryConfigurationCommand();
    init_DeleteBucketLifecycleCommand();
    init_DeleteBucketMetadataConfigurationCommand();
    init_DeleteBucketMetadataTableConfigurationCommand();
    init_DeleteBucketMetricsConfigurationCommand();
    init_DeleteBucketOwnershipControlsCommand();
    init_DeleteBucketPolicyCommand();
    init_DeleteBucketReplicationCommand();
    init_DeleteBucketTaggingCommand();
    init_DeleteBucketWebsiteCommand();
    init_DeleteObjectCommand();
    init_DeleteObjectsCommand();
    init_DeleteObjectTaggingCommand();
    init_DeletePublicAccessBlockCommand();
    init_GetBucketAccelerateConfigurationCommand();
    init_GetBucketAclCommand();
    init_GetBucketAnalyticsConfigurationCommand();
    init_GetBucketCorsCommand();
    init_GetBucketEncryptionCommand();
    init_GetBucketIntelligentTieringConfigurationCommand();
    init_GetBucketInventoryConfigurationCommand();
    init_GetBucketLifecycleConfigurationCommand();
    init_GetBucketLocationCommand();
    init_GetBucketLoggingCommand();
    init_GetBucketMetadataConfigurationCommand();
    init_GetBucketMetadataTableConfigurationCommand();
    init_GetBucketMetricsConfigurationCommand();
    init_GetBucketNotificationConfigurationCommand();
    init_GetBucketOwnershipControlsCommand();
    init_GetBucketPolicyCommand();
    init_GetBucketPolicyStatusCommand();
    init_GetBucketReplicationCommand();
    init_GetBucketRequestPaymentCommand();
    init_GetBucketTaggingCommand();
    init_GetBucketVersioningCommand();
    init_GetBucketWebsiteCommand();
    init_GetObjectAclCommand();
    init_GetObjectAttributesCommand();
    init_GetObjectCommand();
    init_GetObjectLegalHoldCommand();
    init_GetObjectLockConfigurationCommand();
    init_GetObjectRetentionCommand();
    init_GetObjectTaggingCommand();
    init_GetObjectTorrentCommand();
    init_GetPublicAccessBlockCommand();
    init_HeadBucketCommand();
    init_HeadObjectCommand();
    init_ListBucketAnalyticsConfigurationsCommand();
    init_ListBucketIntelligentTieringConfigurationsCommand();
    init_ListBucketInventoryConfigurationsCommand();
    init_ListBucketMetricsConfigurationsCommand();
    init_ListBucketsCommand();
    init_ListDirectoryBucketsCommand();
    init_ListMultipartUploadsCommand();
    init_ListObjectsCommand();
    init_ListObjectsV2Command();
    init_ListObjectVersionsCommand();
    init_ListPartsCommand();
    init_PutBucketAccelerateConfigurationCommand();
    init_PutBucketAclCommand();
    init_PutBucketAnalyticsConfigurationCommand();
    init_PutBucketCorsCommand();
    init_PutBucketEncryptionCommand();
    init_PutBucketIntelligentTieringConfigurationCommand();
    init_PutBucketInventoryConfigurationCommand();
    init_PutBucketLifecycleConfigurationCommand();
    init_PutBucketLoggingCommand();
    init_PutBucketMetricsConfigurationCommand();
    init_PutBucketNotificationConfigurationCommand();
    init_PutBucketOwnershipControlsCommand();
    init_PutBucketPolicyCommand();
    init_PutBucketReplicationCommand();
    init_PutBucketRequestPaymentCommand();
    init_PutBucketTaggingCommand();
    init_PutBucketVersioningCommand();
    init_PutBucketWebsiteCommand();
    init_PutObjectAclCommand();
    init_PutObjectCommand();
    init_PutObjectLegalHoldCommand();
    init_PutObjectLockConfigurationCommand();
    init_PutObjectRetentionCommand();
    init_PutObjectTaggingCommand();
    init_PutPublicAccessBlockCommand();
    init_RenameObjectCommand();
    init_RestoreObjectCommand();
    init_SelectObjectContentCommand();
    init_UpdateBucketMetadataInventoryTableConfigurationCommand();
    init_UpdateBucketMetadataJournalTableConfigurationCommand();
    init_UploadPartCommand();
    init_UploadPartCopyCommand();
    init_WriteGetObjectResponseCommand();
    init_S3Client();
    commands = {
      AbortMultipartUploadCommand,
      CompleteMultipartUploadCommand,
      CopyObjectCommand,
      CreateBucketCommand,
      CreateBucketMetadataConfigurationCommand,
      CreateBucketMetadataTableConfigurationCommand,
      CreateMultipartUploadCommand,
      CreateSessionCommand,
      DeleteBucketCommand,
      DeleteBucketAnalyticsConfigurationCommand,
      DeleteBucketCorsCommand,
      DeleteBucketEncryptionCommand,
      DeleteBucketIntelligentTieringConfigurationCommand,
      DeleteBucketInventoryConfigurationCommand,
      DeleteBucketLifecycleCommand,
      DeleteBucketMetadataConfigurationCommand,
      DeleteBucketMetadataTableConfigurationCommand,
      DeleteBucketMetricsConfigurationCommand,
      DeleteBucketOwnershipControlsCommand,
      DeleteBucketPolicyCommand,
      DeleteBucketReplicationCommand,
      DeleteBucketTaggingCommand,
      DeleteBucketWebsiteCommand,
      DeleteObjectCommand,
      DeleteObjectsCommand,
      DeleteObjectTaggingCommand,
      DeletePublicAccessBlockCommand,
      GetBucketAccelerateConfigurationCommand,
      GetBucketAclCommand,
      GetBucketAnalyticsConfigurationCommand,
      GetBucketCorsCommand,
      GetBucketEncryptionCommand,
      GetBucketIntelligentTieringConfigurationCommand,
      GetBucketInventoryConfigurationCommand,
      GetBucketLifecycleConfigurationCommand,
      GetBucketLocationCommand,
      GetBucketLoggingCommand,
      GetBucketMetadataConfigurationCommand,
      GetBucketMetadataTableConfigurationCommand,
      GetBucketMetricsConfigurationCommand,
      GetBucketNotificationConfigurationCommand,
      GetBucketOwnershipControlsCommand,
      GetBucketPolicyCommand,
      GetBucketPolicyStatusCommand,
      GetBucketReplicationCommand,
      GetBucketRequestPaymentCommand,
      GetBucketTaggingCommand,
      GetBucketVersioningCommand,
      GetBucketWebsiteCommand,
      GetObjectCommand,
      GetObjectAclCommand,
      GetObjectAttributesCommand,
      GetObjectLegalHoldCommand,
      GetObjectLockConfigurationCommand,
      GetObjectRetentionCommand,
      GetObjectTaggingCommand,
      GetObjectTorrentCommand,
      GetPublicAccessBlockCommand,
      HeadBucketCommand,
      HeadObjectCommand,
      ListBucketAnalyticsConfigurationsCommand,
      ListBucketIntelligentTieringConfigurationsCommand,
      ListBucketInventoryConfigurationsCommand,
      ListBucketMetricsConfigurationsCommand,
      ListBucketsCommand,
      ListDirectoryBucketsCommand,
      ListMultipartUploadsCommand,
      ListObjectsCommand,
      ListObjectsV2Command,
      ListObjectVersionsCommand,
      ListPartsCommand,
      PutBucketAccelerateConfigurationCommand,
      PutBucketAclCommand,
      PutBucketAnalyticsConfigurationCommand,
      PutBucketCorsCommand,
      PutBucketEncryptionCommand,
      PutBucketIntelligentTieringConfigurationCommand,
      PutBucketInventoryConfigurationCommand,
      PutBucketLifecycleConfigurationCommand,
      PutBucketLoggingCommand,
      PutBucketMetricsConfigurationCommand,
      PutBucketNotificationConfigurationCommand,
      PutBucketOwnershipControlsCommand,
      PutBucketPolicyCommand,
      PutBucketReplicationCommand,
      PutBucketRequestPaymentCommand,
      PutBucketTaggingCommand,
      PutBucketVersioningCommand,
      PutBucketWebsiteCommand,
      PutObjectCommand,
      PutObjectAclCommand,
      PutObjectLegalHoldCommand,
      PutObjectLockConfigurationCommand,
      PutObjectRetentionCommand,
      PutObjectTaggingCommand,
      PutPublicAccessBlockCommand,
      RenameObjectCommand,
      RestoreObjectCommand,
      SelectObjectContentCommand,
      UpdateBucketMetadataInventoryTableConfigurationCommand,
      UpdateBucketMetadataJournalTableConfigurationCommand,
      UploadPartCommand,
      UploadPartCopyCommand,
      WriteGetObjectResponseCommand
    };
    S3 = class extends S3Client {
    };
    createAggregatedClient(commands, S3);
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/commands/index.js
var init_commands = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/commands/index.js"() {
    "use strict";
    init_AbortMultipartUploadCommand();
    init_CompleteMultipartUploadCommand();
    init_CopyObjectCommand();
    init_CreateBucketCommand();
    init_CreateBucketMetadataConfigurationCommand();
    init_CreateBucketMetadataTableConfigurationCommand();
    init_CreateMultipartUploadCommand();
    init_CreateSessionCommand();
    init_DeleteBucketAnalyticsConfigurationCommand();
    init_DeleteBucketCommand();
    init_DeleteBucketCorsCommand();
    init_DeleteBucketEncryptionCommand();
    init_DeleteBucketIntelligentTieringConfigurationCommand();
    init_DeleteBucketInventoryConfigurationCommand();
    init_DeleteBucketLifecycleCommand();
    init_DeleteBucketMetadataConfigurationCommand();
    init_DeleteBucketMetadataTableConfigurationCommand();
    init_DeleteBucketMetricsConfigurationCommand();
    init_DeleteBucketOwnershipControlsCommand();
    init_DeleteBucketPolicyCommand();
    init_DeleteBucketReplicationCommand();
    init_DeleteBucketTaggingCommand();
    init_DeleteBucketWebsiteCommand();
    init_DeleteObjectCommand();
    init_DeleteObjectTaggingCommand();
    init_DeleteObjectsCommand();
    init_DeletePublicAccessBlockCommand();
    init_GetBucketAccelerateConfigurationCommand();
    init_GetBucketAclCommand();
    init_GetBucketAnalyticsConfigurationCommand();
    init_GetBucketCorsCommand();
    init_GetBucketEncryptionCommand();
    init_GetBucketIntelligentTieringConfigurationCommand();
    init_GetBucketInventoryConfigurationCommand();
    init_GetBucketLifecycleConfigurationCommand();
    init_GetBucketLocationCommand();
    init_GetBucketLoggingCommand();
    init_GetBucketMetadataConfigurationCommand();
    init_GetBucketMetadataTableConfigurationCommand();
    init_GetBucketMetricsConfigurationCommand();
    init_GetBucketNotificationConfigurationCommand();
    init_GetBucketOwnershipControlsCommand();
    init_GetBucketPolicyCommand();
    init_GetBucketPolicyStatusCommand();
    init_GetBucketReplicationCommand();
    init_GetBucketRequestPaymentCommand();
    init_GetBucketTaggingCommand();
    init_GetBucketVersioningCommand();
    init_GetBucketWebsiteCommand();
    init_GetObjectAclCommand();
    init_GetObjectAttributesCommand();
    init_GetObjectCommand();
    init_GetObjectLegalHoldCommand();
    init_GetObjectLockConfigurationCommand();
    init_GetObjectRetentionCommand();
    init_GetObjectTaggingCommand();
    init_GetObjectTorrentCommand();
    init_GetPublicAccessBlockCommand();
    init_HeadBucketCommand();
    init_HeadObjectCommand();
    init_ListBucketAnalyticsConfigurationsCommand();
    init_ListBucketIntelligentTieringConfigurationsCommand();
    init_ListBucketInventoryConfigurationsCommand();
    init_ListBucketMetricsConfigurationsCommand();
    init_ListBucketsCommand();
    init_ListDirectoryBucketsCommand();
    init_ListMultipartUploadsCommand();
    init_ListObjectVersionsCommand();
    init_ListObjectsCommand();
    init_ListObjectsV2Command();
    init_ListPartsCommand();
    init_PutBucketAccelerateConfigurationCommand();
    init_PutBucketAclCommand();
    init_PutBucketAnalyticsConfigurationCommand();
    init_PutBucketCorsCommand();
    init_PutBucketEncryptionCommand();
    init_PutBucketIntelligentTieringConfigurationCommand();
    init_PutBucketInventoryConfigurationCommand();
    init_PutBucketLifecycleConfigurationCommand();
    init_PutBucketLoggingCommand();
    init_PutBucketMetricsConfigurationCommand();
    init_PutBucketNotificationConfigurationCommand();
    init_PutBucketOwnershipControlsCommand();
    init_PutBucketPolicyCommand();
    init_PutBucketReplicationCommand();
    init_PutBucketRequestPaymentCommand();
    init_PutBucketTaggingCommand();
    init_PutBucketVersioningCommand();
    init_PutBucketWebsiteCommand();
    init_PutObjectAclCommand();
    init_PutObjectCommand();
    init_PutObjectLegalHoldCommand();
    init_PutObjectLockConfigurationCommand();
    init_PutObjectRetentionCommand();
    init_PutObjectTaggingCommand();
    init_PutPublicAccessBlockCommand();
    init_RenameObjectCommand();
    init_RestoreObjectCommand();
    init_SelectObjectContentCommand();
    init_UpdateBucketMetadataInventoryTableConfigurationCommand();
    init_UpdateBucketMetadataJournalTableConfigurationCommand();
    init_UploadPartCommand();
    init_UploadPartCopyCommand();
    init_WriteGetObjectResponseCommand();
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/pagination/Interfaces.js
var init_Interfaces = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/pagination/Interfaces.js"() {
    "use strict";
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/pagination/ListBucketsPaginator.js
var paginateListBuckets;
var init_ListBucketsPaginator = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/pagination/ListBucketsPaginator.js"() {
    "use strict";
    init_dist_es14();
    init_ListBucketsCommand();
    init_S3Client();
    paginateListBuckets = createPaginator(S3Client, ListBucketsCommand, "ContinuationToken", "ContinuationToken", "MaxBuckets");
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/pagination/ListDirectoryBucketsPaginator.js
var paginateListDirectoryBuckets;
var init_ListDirectoryBucketsPaginator = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/pagination/ListDirectoryBucketsPaginator.js"() {
    "use strict";
    init_dist_es14();
    init_ListDirectoryBucketsCommand();
    init_S3Client();
    paginateListDirectoryBuckets = createPaginator(S3Client, ListDirectoryBucketsCommand, "ContinuationToken", "ContinuationToken", "MaxDirectoryBuckets");
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/pagination/ListObjectsV2Paginator.js
var paginateListObjectsV2;
var init_ListObjectsV2Paginator = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/pagination/ListObjectsV2Paginator.js"() {
    "use strict";
    init_dist_es14();
    init_ListObjectsV2Command();
    init_S3Client();
    paginateListObjectsV2 = createPaginator(S3Client, ListObjectsV2Command, "ContinuationToken", "NextContinuationToken", "MaxKeys");
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/pagination/ListPartsPaginator.js
var paginateListParts;
var init_ListPartsPaginator = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/pagination/ListPartsPaginator.js"() {
    "use strict";
    init_dist_es14();
    init_ListPartsCommand();
    init_S3Client();
    paginateListParts = createPaginator(S3Client, ListPartsCommand, "PartNumberMarker", "NextPartNumberMarker", "MaxParts");
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/pagination/index.js
var init_pagination2 = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/pagination/index.js"() {
    "use strict";
    init_Interfaces();
    init_ListBucketsPaginator();
    init_ListDirectoryBucketsPaginator();
    init_ListObjectsV2Paginator();
    init_ListPartsPaginator();
  }
});

// node_modules/@smithy/util-waiter/dist-es/circularReplacer.js
var getCircularReplacer;
var init_circularReplacer = __esm({
  "node_modules/@smithy/util-waiter/dist-es/circularReplacer.js"() {
    "use strict";
    getCircularReplacer = () => {
      const seen = /* @__PURE__ */ new WeakSet();
      return (key, value) => {
        if (typeof value === "object" && value !== null) {
          if (seen.has(value)) {
            return "[Circular]";
          }
          seen.add(value);
        }
        return value;
      };
    };
  }
});

// node_modules/@smithy/util-waiter/dist-es/utils/sleep.js
var sleep;
var init_sleep = __esm({
  "node_modules/@smithy/util-waiter/dist-es/utils/sleep.js"() {
    "use strict";
    sleep = (seconds) => {
      return new Promise((resolve) => setTimeout(resolve, seconds * 1e3));
    };
  }
});

// node_modules/@smithy/util-waiter/dist-es/waiter.js
var waiterServiceDefaults, WaiterState, checkExceptions;
var init_waiter2 = __esm({
  "node_modules/@smithy/util-waiter/dist-es/waiter.js"() {
    "use strict";
    init_circularReplacer();
    waiterServiceDefaults = {
      minDelay: 2,
      maxDelay: 120
    };
    (function(WaiterState2) {
      WaiterState2["ABORTED"] = "ABORTED";
      WaiterState2["FAILURE"] = "FAILURE";
      WaiterState2["SUCCESS"] = "SUCCESS";
      WaiterState2["RETRY"] = "RETRY";
      WaiterState2["TIMEOUT"] = "TIMEOUT";
    })(WaiterState || (WaiterState = {}));
    checkExceptions = (result) => {
      if (result.state === WaiterState.ABORTED) {
        const abortError = new Error(`${JSON.stringify({
          ...result,
          reason: "Request was aborted"
        }, getCircularReplacer())}`);
        abortError.name = "AbortError";
        throw abortError;
      } else if (result.state === WaiterState.TIMEOUT) {
        const timeoutError = new Error(`${JSON.stringify({
          ...result,
          reason: "Waiter has timed out"
        }, getCircularReplacer())}`);
        timeoutError.name = "TimeoutError";
        throw timeoutError;
      } else if (result.state !== WaiterState.SUCCESS) {
        throw new Error(`${JSON.stringify(result, getCircularReplacer())}`);
      }
      return result;
    };
  }
});

// node_modules/@smithy/util-waiter/dist-es/poller.js
var exponentialBackoffWithJitter, randomInRange, runPolling, createMessageFromResponse;
var init_poller = __esm({
  "node_modules/@smithy/util-waiter/dist-es/poller.js"() {
    "use strict";
    init_circularReplacer();
    init_sleep();
    init_waiter2();
    exponentialBackoffWithJitter = (minDelay, maxDelay, attemptCeiling, attempt) => {
      if (attempt > attemptCeiling)
        return maxDelay;
      const delay = minDelay * 2 ** (attempt - 1);
      return randomInRange(minDelay, delay);
    };
    randomInRange = (min, max) => min + Math.random() * (max - min);
    runPolling = async ({ minDelay, maxDelay, maxWaitTime, abortController, client, abortSignal }, input, acceptorChecks) => {
      const observedResponses = {};
      const { state, reason } = await acceptorChecks(client, input);
      if (reason) {
        const message = createMessageFromResponse(reason);
        observedResponses[message] |= 0;
        observedResponses[message] += 1;
      }
      if (state !== WaiterState.RETRY) {
        return { state, reason, observedResponses };
      }
      let currentAttempt = 1;
      const waitUntil = Date.now() + maxWaitTime * 1e3;
      const attemptCeiling = Math.log(maxDelay / minDelay) / Math.log(2) + 1;
      while (true) {
        if (abortController?.signal?.aborted || abortSignal?.aborted) {
          const message = "AbortController signal aborted.";
          observedResponses[message] |= 0;
          observedResponses[message] += 1;
          return { state: WaiterState.ABORTED, observedResponses };
        }
        const delay = exponentialBackoffWithJitter(minDelay, maxDelay, attemptCeiling, currentAttempt);
        if (Date.now() + delay * 1e3 > waitUntil) {
          return { state: WaiterState.TIMEOUT, observedResponses };
        }
        await sleep(delay);
        const { state: state2, reason: reason2 } = await acceptorChecks(client, input);
        if (reason2) {
          const message = createMessageFromResponse(reason2);
          observedResponses[message] |= 0;
          observedResponses[message] += 1;
        }
        if (state2 !== WaiterState.RETRY) {
          return { state: state2, reason: reason2, observedResponses };
        }
        currentAttempt += 1;
      }
    };
    createMessageFromResponse = (reason) => {
      if (reason?.$responseBodyText) {
        return `Deserialization error for body: ${reason.$responseBodyText}`;
      }
      if (reason?.$metadata?.httpStatusCode) {
        if (reason.$response || reason.message) {
          return `${reason.$response.statusCode ?? reason.$metadata.httpStatusCode ?? "Unknown"}: ${reason.message}`;
        }
        return `${reason.$metadata.httpStatusCode}: OK`;
      }
      return String(reason?.message ?? JSON.stringify(reason, getCircularReplacer()) ?? "Unknown");
    };
  }
});

// node_modules/@smithy/util-waiter/dist-es/utils/validate.js
var validateWaiterOptions;
var init_validate = __esm({
  "node_modules/@smithy/util-waiter/dist-es/utils/validate.js"() {
    "use strict";
    validateWaiterOptions = (options) => {
      if (options.maxWaitTime <= 0) {
        throw new Error(`WaiterConfiguration.maxWaitTime must be greater than 0`);
      } else if (options.minDelay <= 0) {
        throw new Error(`WaiterConfiguration.minDelay must be greater than 0`);
      } else if (options.maxDelay <= 0) {
        throw new Error(`WaiterConfiguration.maxDelay must be greater than 0`);
      } else if (options.maxWaitTime <= options.minDelay) {
        throw new Error(`WaiterConfiguration.maxWaitTime [${options.maxWaitTime}] must be greater than WaiterConfiguration.minDelay [${options.minDelay}] for this waiter`);
      } else if (options.maxDelay < options.minDelay) {
        throw new Error(`WaiterConfiguration.maxDelay [${options.maxDelay}] must be greater than WaiterConfiguration.minDelay [${options.minDelay}] for this waiter`);
      }
    };
  }
});

// node_modules/@smithy/util-waiter/dist-es/utils/index.js
var init_utils4 = __esm({
  "node_modules/@smithy/util-waiter/dist-es/utils/index.js"() {
    "use strict";
    init_sleep();
    init_validate();
  }
});

// node_modules/@smithy/util-waiter/dist-es/createWaiter.js
var abortTimeout, createWaiter;
var init_createWaiter = __esm({
  "node_modules/@smithy/util-waiter/dist-es/createWaiter.js"() {
    "use strict";
    init_poller();
    init_utils4();
    init_waiter2();
    abortTimeout = (abortSignal) => {
      let onAbort;
      const promise = new Promise((resolve) => {
        onAbort = () => resolve({ state: WaiterState.ABORTED });
        if (typeof abortSignal.addEventListener === "function") {
          abortSignal.addEventListener("abort", onAbort);
        } else {
          abortSignal.onabort = onAbort;
        }
      });
      return {
        clearListener() {
          if (typeof abortSignal.removeEventListener === "function") {
            abortSignal.removeEventListener("abort", onAbort);
          }
        },
        aborted: promise
      };
    };
    createWaiter = async (options, input, acceptorChecks) => {
      const params = {
        ...waiterServiceDefaults,
        ...options
      };
      validateWaiterOptions(params);
      const exitConditions = [runPolling(params, input, acceptorChecks)];
      const finalize = [];
      if (options.abortSignal) {
        const { aborted, clearListener } = abortTimeout(options.abortSignal);
        finalize.push(clearListener);
        exitConditions.push(aborted);
      }
      if (options.abortController?.signal) {
        const { aborted, clearListener } = abortTimeout(options.abortController.signal);
        finalize.push(clearListener);
        exitConditions.push(aborted);
      }
      return Promise.race(exitConditions).then((result) => {
        for (const fn of finalize) {
          fn();
        }
        return result;
      });
    };
  }
});

// node_modules/@smithy/util-waiter/dist-es/index.js
var init_dist_es57 = __esm({
  "node_modules/@smithy/util-waiter/dist-es/index.js"() {
    "use strict";
    init_createWaiter();
    init_waiter2();
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/waiters/waitForBucketExists.js
var checkState, waitForBucketExists, waitUntilBucketExists;
var init_waitForBucketExists = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/waiters/waitForBucketExists.js"() {
    "use strict";
    init_dist_es57();
    init_HeadBucketCommand();
    checkState = async (client, input) => {
      let reason;
      try {
        const result = await client.send(new HeadBucketCommand(input));
        reason = result;
        return { state: WaiterState.SUCCESS, reason };
      } catch (exception) {
        reason = exception;
        if (exception.name && exception.name == "NotFound") {
          return { state: WaiterState.RETRY, reason };
        }
      }
      return { state: WaiterState.RETRY, reason };
    };
    waitForBucketExists = async (params, input) => {
      const serviceDefaults = { minDelay: 5, maxDelay: 120 };
      return createWaiter({ ...serviceDefaults, ...params }, input, checkState);
    };
    waitUntilBucketExists = async (params, input) => {
      const serviceDefaults = { minDelay: 5, maxDelay: 120 };
      const result = await createWaiter({ ...serviceDefaults, ...params }, input, checkState);
      return checkExceptions(result);
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/waiters/waitForBucketNotExists.js
var checkState2, waitForBucketNotExists, waitUntilBucketNotExists;
var init_waitForBucketNotExists = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/waiters/waitForBucketNotExists.js"() {
    "use strict";
    init_dist_es57();
    init_HeadBucketCommand();
    checkState2 = async (client, input) => {
      let reason;
      try {
        const result = await client.send(new HeadBucketCommand(input));
        reason = result;
      } catch (exception) {
        reason = exception;
        if (exception.name && exception.name == "NotFound") {
          return { state: WaiterState.SUCCESS, reason };
        }
      }
      return { state: WaiterState.RETRY, reason };
    };
    waitForBucketNotExists = async (params, input) => {
      const serviceDefaults = { minDelay: 5, maxDelay: 120 };
      return createWaiter({ ...serviceDefaults, ...params }, input, checkState2);
    };
    waitUntilBucketNotExists = async (params, input) => {
      const serviceDefaults = { minDelay: 5, maxDelay: 120 };
      const result = await createWaiter({ ...serviceDefaults, ...params }, input, checkState2);
      return checkExceptions(result);
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/waiters/waitForObjectExists.js
var checkState3, waitForObjectExists, waitUntilObjectExists;
var init_waitForObjectExists = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/waiters/waitForObjectExists.js"() {
    "use strict";
    init_dist_es57();
    init_HeadObjectCommand();
    checkState3 = async (client, input) => {
      let reason;
      try {
        const result = await client.send(new HeadObjectCommand(input));
        reason = result;
        return { state: WaiterState.SUCCESS, reason };
      } catch (exception) {
        reason = exception;
        if (exception.name && exception.name == "NotFound") {
          return { state: WaiterState.RETRY, reason };
        }
      }
      return { state: WaiterState.RETRY, reason };
    };
    waitForObjectExists = async (params, input) => {
      const serviceDefaults = { minDelay: 5, maxDelay: 120 };
      return createWaiter({ ...serviceDefaults, ...params }, input, checkState3);
    };
    waitUntilObjectExists = async (params, input) => {
      const serviceDefaults = { minDelay: 5, maxDelay: 120 };
      const result = await createWaiter({ ...serviceDefaults, ...params }, input, checkState3);
      return checkExceptions(result);
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/waiters/waitForObjectNotExists.js
var checkState4, waitForObjectNotExists, waitUntilObjectNotExists;
var init_waitForObjectNotExists = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/waiters/waitForObjectNotExists.js"() {
    "use strict";
    init_dist_es57();
    init_HeadObjectCommand();
    checkState4 = async (client, input) => {
      let reason;
      try {
        const result = await client.send(new HeadObjectCommand(input));
        reason = result;
      } catch (exception) {
        reason = exception;
        if (exception.name && exception.name == "NotFound") {
          return { state: WaiterState.SUCCESS, reason };
        }
      }
      return { state: WaiterState.RETRY, reason };
    };
    waitForObjectNotExists = async (params, input) => {
      const serviceDefaults = { minDelay: 5, maxDelay: 120 };
      return createWaiter({ ...serviceDefaults, ...params }, input, checkState4);
    };
    waitUntilObjectNotExists = async (params, input) => {
      const serviceDefaults = { minDelay: 5, maxDelay: 120 };
      const result = await createWaiter({ ...serviceDefaults, ...params }, input, checkState4);
      return checkExceptions(result);
    };
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/waiters/index.js
var init_waiters = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/waiters/index.js"() {
    "use strict";
    init_waitForBucketExists();
    init_waitForBucketNotExists();
    init_waitForObjectExists();
    init_waitForObjectNotExists();
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/models/index.js
var init_models = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/models/index.js"() {
    "use strict";
    init_models_0();
    init_models_1();
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/index.js
var dist_es_exports = {};
__export(dist_es_exports, {
  $Command: () => Command,
  AbortMultipartUploadCommand: () => AbortMultipartUploadCommand,
  AnalyticsFilter: () => AnalyticsFilter,
  AnalyticsS3ExportFileFormat: () => AnalyticsS3ExportFileFormat,
  ArchiveStatus: () => ArchiveStatus,
  BucketAccelerateStatus: () => BucketAccelerateStatus,
  BucketAlreadyExists: () => BucketAlreadyExists,
  BucketAlreadyOwnedByYou: () => BucketAlreadyOwnedByYou,
  BucketCannedACL: () => BucketCannedACL,
  BucketLocationConstraint: () => BucketLocationConstraint,
  BucketLogsPermission: () => BucketLogsPermission,
  BucketType: () => BucketType,
  BucketVersioningStatus: () => BucketVersioningStatus,
  ChecksumAlgorithm: () => ChecksumAlgorithm2,
  ChecksumMode: () => ChecksumMode,
  ChecksumType: () => ChecksumType,
  CompleteMultipartUploadCommand: () => CompleteMultipartUploadCommand,
  CompleteMultipartUploadOutputFilterSensitiveLog: () => CompleteMultipartUploadOutputFilterSensitiveLog,
  CompleteMultipartUploadRequestFilterSensitiveLog: () => CompleteMultipartUploadRequestFilterSensitiveLog,
  CompressionType: () => CompressionType,
  CopyObjectCommand: () => CopyObjectCommand,
  CopyObjectOutputFilterSensitiveLog: () => CopyObjectOutputFilterSensitiveLog,
  CopyObjectRequestFilterSensitiveLog: () => CopyObjectRequestFilterSensitiveLog,
  CreateBucketCommand: () => CreateBucketCommand,
  CreateBucketMetadataConfigurationCommand: () => CreateBucketMetadataConfigurationCommand,
  CreateBucketMetadataTableConfigurationCommand: () => CreateBucketMetadataTableConfigurationCommand,
  CreateMultipartUploadCommand: () => CreateMultipartUploadCommand,
  CreateMultipartUploadOutputFilterSensitiveLog: () => CreateMultipartUploadOutputFilterSensitiveLog,
  CreateMultipartUploadRequestFilterSensitiveLog: () => CreateMultipartUploadRequestFilterSensitiveLog,
  CreateSessionCommand: () => CreateSessionCommand,
  CreateSessionOutputFilterSensitiveLog: () => CreateSessionOutputFilterSensitiveLog,
  CreateSessionRequestFilterSensitiveLog: () => CreateSessionRequestFilterSensitiveLog,
  DataRedundancy: () => DataRedundancy,
  DeleteBucketAnalyticsConfigurationCommand: () => DeleteBucketAnalyticsConfigurationCommand,
  DeleteBucketCommand: () => DeleteBucketCommand,
  DeleteBucketCorsCommand: () => DeleteBucketCorsCommand,
  DeleteBucketEncryptionCommand: () => DeleteBucketEncryptionCommand,
  DeleteBucketIntelligentTieringConfigurationCommand: () => DeleteBucketIntelligentTieringConfigurationCommand,
  DeleteBucketInventoryConfigurationCommand: () => DeleteBucketInventoryConfigurationCommand,
  DeleteBucketLifecycleCommand: () => DeleteBucketLifecycleCommand,
  DeleteBucketMetadataConfigurationCommand: () => DeleteBucketMetadataConfigurationCommand,
  DeleteBucketMetadataTableConfigurationCommand: () => DeleteBucketMetadataTableConfigurationCommand,
  DeleteBucketMetricsConfigurationCommand: () => DeleteBucketMetricsConfigurationCommand,
  DeleteBucketOwnershipControlsCommand: () => DeleteBucketOwnershipControlsCommand,
  DeleteBucketPolicyCommand: () => DeleteBucketPolicyCommand,
  DeleteBucketReplicationCommand: () => DeleteBucketReplicationCommand,
  DeleteBucketTaggingCommand: () => DeleteBucketTaggingCommand,
  DeleteBucketWebsiteCommand: () => DeleteBucketWebsiteCommand,
  DeleteMarkerReplicationStatus: () => DeleteMarkerReplicationStatus,
  DeleteObjectCommand: () => DeleteObjectCommand,
  DeleteObjectTaggingCommand: () => DeleteObjectTaggingCommand,
  DeleteObjectsCommand: () => DeleteObjectsCommand,
  DeletePublicAccessBlockCommand: () => DeletePublicAccessBlockCommand,
  EncodingType: () => EncodingType,
  EncryptionFilterSensitiveLog: () => EncryptionFilterSensitiveLog,
  EncryptionTypeMismatch: () => EncryptionTypeMismatch,
  Event: () => Event,
  ExistingObjectReplicationStatus: () => ExistingObjectReplicationStatus,
  ExpirationState: () => ExpirationState,
  ExpirationStatus: () => ExpirationStatus,
  ExpressionType: () => ExpressionType,
  FileHeaderInfo: () => FileHeaderInfo,
  FilterRuleName: () => FilterRuleName,
  GetBucketAccelerateConfigurationCommand: () => GetBucketAccelerateConfigurationCommand,
  GetBucketAclCommand: () => GetBucketAclCommand,
  GetBucketAnalyticsConfigurationCommand: () => GetBucketAnalyticsConfigurationCommand,
  GetBucketCorsCommand: () => GetBucketCorsCommand,
  GetBucketEncryptionCommand: () => GetBucketEncryptionCommand,
  GetBucketEncryptionOutputFilterSensitiveLog: () => GetBucketEncryptionOutputFilterSensitiveLog,
  GetBucketIntelligentTieringConfigurationCommand: () => GetBucketIntelligentTieringConfigurationCommand,
  GetBucketInventoryConfigurationCommand: () => GetBucketInventoryConfigurationCommand,
  GetBucketInventoryConfigurationOutputFilterSensitiveLog: () => GetBucketInventoryConfigurationOutputFilterSensitiveLog,
  GetBucketLifecycleConfigurationCommand: () => GetBucketLifecycleConfigurationCommand,
  GetBucketLocationCommand: () => GetBucketLocationCommand,
  GetBucketLoggingCommand: () => GetBucketLoggingCommand,
  GetBucketMetadataConfigurationCommand: () => GetBucketMetadataConfigurationCommand,
  GetBucketMetadataTableConfigurationCommand: () => GetBucketMetadataTableConfigurationCommand,
  GetBucketMetricsConfigurationCommand: () => GetBucketMetricsConfigurationCommand,
  GetBucketNotificationConfigurationCommand: () => GetBucketNotificationConfigurationCommand,
  GetBucketOwnershipControlsCommand: () => GetBucketOwnershipControlsCommand,
  GetBucketPolicyCommand: () => GetBucketPolicyCommand,
  GetBucketPolicyStatusCommand: () => GetBucketPolicyStatusCommand,
  GetBucketReplicationCommand: () => GetBucketReplicationCommand,
  GetBucketRequestPaymentCommand: () => GetBucketRequestPaymentCommand,
  GetBucketTaggingCommand: () => GetBucketTaggingCommand,
  GetBucketVersioningCommand: () => GetBucketVersioningCommand,
  GetBucketWebsiteCommand: () => GetBucketWebsiteCommand,
  GetObjectAclCommand: () => GetObjectAclCommand,
  GetObjectAttributesCommand: () => GetObjectAttributesCommand,
  GetObjectAttributesRequestFilterSensitiveLog: () => GetObjectAttributesRequestFilterSensitiveLog,
  GetObjectCommand: () => GetObjectCommand,
  GetObjectLegalHoldCommand: () => GetObjectLegalHoldCommand,
  GetObjectLockConfigurationCommand: () => GetObjectLockConfigurationCommand,
  GetObjectOutputFilterSensitiveLog: () => GetObjectOutputFilterSensitiveLog,
  GetObjectRequestFilterSensitiveLog: () => GetObjectRequestFilterSensitiveLog,
  GetObjectRetentionCommand: () => GetObjectRetentionCommand,
  GetObjectTaggingCommand: () => GetObjectTaggingCommand,
  GetObjectTorrentCommand: () => GetObjectTorrentCommand,
  GetObjectTorrentOutputFilterSensitiveLog: () => GetObjectTorrentOutputFilterSensitiveLog,
  GetPublicAccessBlockCommand: () => GetPublicAccessBlockCommand,
  HeadBucketCommand: () => HeadBucketCommand,
  HeadObjectCommand: () => HeadObjectCommand,
  HeadObjectOutputFilterSensitiveLog: () => HeadObjectOutputFilterSensitiveLog,
  HeadObjectRequestFilterSensitiveLog: () => HeadObjectRequestFilterSensitiveLog,
  IdempotencyParameterMismatch: () => IdempotencyParameterMismatch,
  IntelligentTieringAccessTier: () => IntelligentTieringAccessTier,
  IntelligentTieringStatus: () => IntelligentTieringStatus,
  InvalidObjectState: () => InvalidObjectState,
  InvalidRequest: () => InvalidRequest,
  InvalidWriteOffset: () => InvalidWriteOffset,
  InventoryConfigurationFilterSensitiveLog: () => InventoryConfigurationFilterSensitiveLog,
  InventoryConfigurationState: () => InventoryConfigurationState,
  InventoryDestinationFilterSensitiveLog: () => InventoryDestinationFilterSensitiveLog,
  InventoryEncryptionFilterSensitiveLog: () => InventoryEncryptionFilterSensitiveLog,
  InventoryFormat: () => InventoryFormat,
  InventoryFrequency: () => InventoryFrequency,
  InventoryIncludedObjectVersions: () => InventoryIncludedObjectVersions,
  InventoryOptionalField: () => InventoryOptionalField,
  InventoryS3BucketDestinationFilterSensitiveLog: () => InventoryS3BucketDestinationFilterSensitiveLog,
  JSONType: () => JSONType,
  ListBucketAnalyticsConfigurationsCommand: () => ListBucketAnalyticsConfigurationsCommand,
  ListBucketIntelligentTieringConfigurationsCommand: () => ListBucketIntelligentTieringConfigurationsCommand,
  ListBucketInventoryConfigurationsCommand: () => ListBucketInventoryConfigurationsCommand,
  ListBucketInventoryConfigurationsOutputFilterSensitiveLog: () => ListBucketInventoryConfigurationsOutputFilterSensitiveLog,
  ListBucketMetricsConfigurationsCommand: () => ListBucketMetricsConfigurationsCommand,
  ListBucketsCommand: () => ListBucketsCommand,
  ListDirectoryBucketsCommand: () => ListDirectoryBucketsCommand,
  ListMultipartUploadsCommand: () => ListMultipartUploadsCommand,
  ListObjectVersionsCommand: () => ListObjectVersionsCommand,
  ListObjectsCommand: () => ListObjectsCommand,
  ListObjectsV2Command: () => ListObjectsV2Command,
  ListPartsCommand: () => ListPartsCommand,
  ListPartsRequestFilterSensitiveLog: () => ListPartsRequestFilterSensitiveLog,
  LocationType: () => LocationType,
  MFADelete: () => MFADelete,
  MFADeleteStatus: () => MFADeleteStatus,
  MetadataDirective: () => MetadataDirective,
  MetricsFilter: () => MetricsFilter,
  MetricsStatus: () => MetricsStatus,
  NoSuchBucket: () => NoSuchBucket,
  NoSuchKey: () => NoSuchKey,
  NoSuchUpload: () => NoSuchUpload,
  NotFound: () => NotFound,
  ObjectAlreadyInActiveTierError: () => ObjectAlreadyInActiveTierError,
  ObjectAttributes: () => ObjectAttributes,
  ObjectCannedACL: () => ObjectCannedACL,
  ObjectLockEnabled: () => ObjectLockEnabled,
  ObjectLockLegalHoldStatus: () => ObjectLockLegalHoldStatus,
  ObjectLockMode: () => ObjectLockMode,
  ObjectLockRetentionMode: () => ObjectLockRetentionMode,
  ObjectNotInActiveTierError: () => ObjectNotInActiveTierError,
  ObjectOwnership: () => ObjectOwnership,
  ObjectStorageClass: () => ObjectStorageClass,
  ObjectVersionStorageClass: () => ObjectVersionStorageClass,
  OptionalObjectAttributes: () => OptionalObjectAttributes,
  OutputLocationFilterSensitiveLog: () => OutputLocationFilterSensitiveLog,
  OwnerOverride: () => OwnerOverride,
  PartitionDateSource: () => PartitionDateSource,
  Payer: () => Payer,
  Permission: () => Permission,
  Protocol: () => Protocol,
  PutBucketAccelerateConfigurationCommand: () => PutBucketAccelerateConfigurationCommand,
  PutBucketAclCommand: () => PutBucketAclCommand,
  PutBucketAnalyticsConfigurationCommand: () => PutBucketAnalyticsConfigurationCommand,
  PutBucketCorsCommand: () => PutBucketCorsCommand,
  PutBucketEncryptionCommand: () => PutBucketEncryptionCommand,
  PutBucketEncryptionRequestFilterSensitiveLog: () => PutBucketEncryptionRequestFilterSensitiveLog,
  PutBucketIntelligentTieringConfigurationCommand: () => PutBucketIntelligentTieringConfigurationCommand,
  PutBucketInventoryConfigurationCommand: () => PutBucketInventoryConfigurationCommand,
  PutBucketInventoryConfigurationRequestFilterSensitiveLog: () => PutBucketInventoryConfigurationRequestFilterSensitiveLog,
  PutBucketLifecycleConfigurationCommand: () => PutBucketLifecycleConfigurationCommand,
  PutBucketLoggingCommand: () => PutBucketLoggingCommand,
  PutBucketMetricsConfigurationCommand: () => PutBucketMetricsConfigurationCommand,
  PutBucketNotificationConfigurationCommand: () => PutBucketNotificationConfigurationCommand,
  PutBucketOwnershipControlsCommand: () => PutBucketOwnershipControlsCommand,
  PutBucketPolicyCommand: () => PutBucketPolicyCommand,
  PutBucketReplicationCommand: () => PutBucketReplicationCommand,
  PutBucketRequestPaymentCommand: () => PutBucketRequestPaymentCommand,
  PutBucketTaggingCommand: () => PutBucketTaggingCommand,
  PutBucketVersioningCommand: () => PutBucketVersioningCommand,
  PutBucketWebsiteCommand: () => PutBucketWebsiteCommand,
  PutObjectAclCommand: () => PutObjectAclCommand,
  PutObjectCommand: () => PutObjectCommand,
  PutObjectLegalHoldCommand: () => PutObjectLegalHoldCommand,
  PutObjectLockConfigurationCommand: () => PutObjectLockConfigurationCommand,
  PutObjectOutputFilterSensitiveLog: () => PutObjectOutputFilterSensitiveLog,
  PutObjectRequestFilterSensitiveLog: () => PutObjectRequestFilterSensitiveLog,
  PutObjectRetentionCommand: () => PutObjectRetentionCommand,
  PutObjectTaggingCommand: () => PutObjectTaggingCommand,
  PutPublicAccessBlockCommand: () => PutPublicAccessBlockCommand,
  QuoteFields: () => QuoteFields,
  RenameObjectCommand: () => RenameObjectCommand,
  ReplicaModificationsStatus: () => ReplicaModificationsStatus,
  ReplicationRuleStatus: () => ReplicationRuleStatus,
  ReplicationStatus: () => ReplicationStatus,
  ReplicationTimeStatus: () => ReplicationTimeStatus,
  RequestCharged: () => RequestCharged,
  RequestPayer: () => RequestPayer,
  RestoreObjectCommand: () => RestoreObjectCommand,
  RestoreObjectRequestFilterSensitiveLog: () => RestoreObjectRequestFilterSensitiveLog,
  RestoreRequestFilterSensitiveLog: () => RestoreRequestFilterSensitiveLog,
  RestoreRequestType: () => RestoreRequestType,
  S3: () => S3,
  S3Client: () => S3Client,
  S3LocationFilterSensitiveLog: () => S3LocationFilterSensitiveLog,
  S3ServiceException: () => S3ServiceException,
  S3TablesBucketType: () => S3TablesBucketType,
  SSEKMSFilterSensitiveLog: () => SSEKMSFilterSensitiveLog,
  SelectObjectContentCommand: () => SelectObjectContentCommand,
  SelectObjectContentEventStream: () => SelectObjectContentEventStream,
  SelectObjectContentEventStreamFilterSensitiveLog: () => SelectObjectContentEventStreamFilterSensitiveLog,
  SelectObjectContentOutputFilterSensitiveLog: () => SelectObjectContentOutputFilterSensitiveLog,
  SelectObjectContentRequestFilterSensitiveLog: () => SelectObjectContentRequestFilterSensitiveLog,
  ServerSideEncryption: () => ServerSideEncryption,
  ServerSideEncryptionByDefaultFilterSensitiveLog: () => ServerSideEncryptionByDefaultFilterSensitiveLog,
  ServerSideEncryptionConfigurationFilterSensitiveLog: () => ServerSideEncryptionConfigurationFilterSensitiveLog,
  ServerSideEncryptionRuleFilterSensitiveLog: () => ServerSideEncryptionRuleFilterSensitiveLog,
  SessionCredentialsFilterSensitiveLog: () => SessionCredentialsFilterSensitiveLog,
  SessionMode: () => SessionMode,
  SseKmsEncryptedObjectsStatus: () => SseKmsEncryptedObjectsStatus,
  StorageClass: () => StorageClass,
  StorageClassAnalysisSchemaVersion: () => StorageClassAnalysisSchemaVersion,
  TableSseAlgorithm: () => TableSseAlgorithm,
  TaggingDirective: () => TaggingDirective,
  Tier: () => Tier,
  TooManyParts: () => TooManyParts,
  TransitionDefaultMinimumObjectSize: () => TransitionDefaultMinimumObjectSize,
  TransitionStorageClass: () => TransitionStorageClass,
  Type: () => Type,
  UpdateBucketMetadataInventoryTableConfigurationCommand: () => UpdateBucketMetadataInventoryTableConfigurationCommand,
  UpdateBucketMetadataJournalTableConfigurationCommand: () => UpdateBucketMetadataJournalTableConfigurationCommand,
  UploadPartCommand: () => UploadPartCommand,
  UploadPartCopyCommand: () => UploadPartCopyCommand,
  UploadPartCopyOutputFilterSensitiveLog: () => UploadPartCopyOutputFilterSensitiveLog,
  UploadPartCopyRequestFilterSensitiveLog: () => UploadPartCopyRequestFilterSensitiveLog,
  UploadPartOutputFilterSensitiveLog: () => UploadPartOutputFilterSensitiveLog,
  UploadPartRequestFilterSensitiveLog: () => UploadPartRequestFilterSensitiveLog,
  WriteGetObjectResponseCommand: () => WriteGetObjectResponseCommand,
  WriteGetObjectResponseRequestFilterSensitiveLog: () => WriteGetObjectResponseRequestFilterSensitiveLog,
  __Client: () => Client,
  paginateListBuckets: () => paginateListBuckets,
  paginateListDirectoryBuckets: () => paginateListDirectoryBuckets,
  paginateListObjectsV2: () => paginateListObjectsV2,
  paginateListParts: () => paginateListParts,
  waitForBucketExists: () => waitForBucketExists,
  waitForBucketNotExists: () => waitForBucketNotExists,
  waitForObjectExists: () => waitForObjectExists,
  waitForObjectNotExists: () => waitForObjectNotExists,
  waitUntilBucketExists: () => waitUntilBucketExists,
  waitUntilBucketNotExists: () => waitUntilBucketNotExists,
  waitUntilObjectExists: () => waitUntilObjectExists,
  waitUntilObjectNotExists: () => waitUntilObjectNotExists
});
var init_dist_es58 = __esm({
  "node_modules/@aws-sdk/client-s3/dist-es/index.js"() {
    "use strict";
    init_S3Client();
    init_S3();
    init_commands();
    init_pagination2();
    init_waiters();
    init_models();
    init_S3ServiceException();
  }
});

// node_modules/@liquidmetal-ai/raindrop-framework/dist/core/cors.js
var matchOrigin = (request, env, config) => {
  const requestOrigin = request.headers.get("origin");
  if (!requestOrigin) {
    return null;
  }
  const { origin } = config;
  if (origin === "*") {
    return "*";
  }
  if (typeof origin === "function") {
    return origin(request, env);
  }
  if (typeof origin === "string") {
    return requestOrigin === origin ? origin : null;
  }
  if (Array.isArray(origin)) {
    return origin.includes(requestOrigin) ? requestOrigin : null;
  }
  return null;
};
var addCorsHeaders = (response, request, env, config) => {
  const allowedOrigin = matchOrigin(request, env, config);
  if (!allowedOrigin) {
    return response;
  }
  const headers = new Headers(response.headers);
  headers.set("Access-Control-Allow-Origin", allowedOrigin);
  if (config.credentials) {
    headers.set("Access-Control-Allow-Credentials", "true");
  }
  if (config.exposeHeaders && config.exposeHeaders.length > 0) {
    headers.set("Access-Control-Expose-Headers", config.exposeHeaders.join(", "));
  }
  const vary = headers.get("Vary");
  if (vary) {
    if (!vary.includes("Origin")) {
      headers.set("Vary", `${vary}, Origin`);
    }
  } else {
    headers.set("Vary", "Origin");
  }
  return new Response(response.body, {
    status: response.status,
    statusText: response.statusText,
    headers
  });
};
var handlePreflight = (request, env, config) => {
  const allowedOrigin = matchOrigin(request, env, config);
  if (!allowedOrigin) {
    return new Response(null, { status: 403 });
  }
  const headers = new Headers();
  headers.set("Access-Control-Allow-Origin", allowedOrigin);
  if (config.credentials) {
    headers.set("Access-Control-Allow-Credentials", "true");
  }
  const allowMethods = config.allowMethods || ["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"];
  headers.set("Access-Control-Allow-Methods", allowMethods.join(", "));
  const allowHeaders = config.allowHeaders || ["Content-Type", "Authorization"];
  headers.set("Access-Control-Allow-Headers", allowHeaders.join(", "));
  const maxAge = config.maxAge ?? 86400;
  headers.set("Access-Control-Max-Age", maxAge.toString());
  headers.set("Vary", "Origin");
  return new Response(null, {
    status: 204,
    headers
  });
};
var createCorsHandler = (config) => {
  return (request, env, response) => {
    if (!response) {
      return handlePreflight(request, env, config);
    }
    return addCorsHeaders(response, request, env, config);
  };
};
var corsAllowAll = createCorsHandler({
  origin: "*",
  allowMethods: ["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"],
  allowHeaders: ["Content-Type", "Authorization"],
  credentials: false
});
var corsDisabled = (request, _env, response) => {
  if (!response && request.method === "OPTIONS") {
    return new Response(null, { status: 403 });
  }
  if (!response) {
    throw new Error("corsDisabled called without response for non-OPTIONS request");
  }
  return response;
};

// src/_app/cors.ts
var cors = corsDisabled;

// src/upload-worker/index.ts
import { Each } from "./runtime.js";
var upload_worker_default = class extends Each {
  async process(message) {
    console.log(`\u2601\uFE0F  Upload Worker: Processing job ${message.body.jobId}`);
    const { jobId } = message.body;
    try {
      console.log("   Reading metadata and audio from bucket storage...");
      const metadataObj = await this.env.BRIEF_JOB_STORAGE.get(`job:${jobId}:metadata`);
      const audioObj = await this.env.BRIEF_JOB_STORAGE.get(`job:${jobId}:audio`);
      if (!metadataObj || !audioObj) {
        throw new Error("Metadata or audio not found in bucket storage");
      }
      const metadataJson = await metadataObj.text();
      const audioBase64 = await audioObj.text();
      const metadata = JSON.parse(metadataJson);
      const audioBuffer = Buffer.from(audioBase64, "base64");
      console.log(`   \u2705 Loaded audio (${Math.round(audioBuffer.byteLength / 1024)}KB)`);
      console.log("   Uploading to Vultr CDN...");
      const audioUrl = await this.uploadToVultr(audioBuffer, metadata);
      console.log(`   \u2705 Uploaded to: ${audioUrl}`);
      console.log("   Saving brief to database...");
      const briefId = await this.saveBriefToDatabase(jobId, audioUrl, metadata);
      console.log(`   \u2705 Saved brief ID: ${briefId}`);
      await this.env.BRIEF_JOB_STORAGE.delete(`job:${jobId}:metadata`);
      await this.env.BRIEF_JOB_STORAGE.delete(`job:${jobId}:audio`);
      console.log("   \u2705 Cleaned up bucket storage");
      console.log(`
\u2705 Brief generation completed!`);
      console.log(`   Job ID: ${jobId}`);
      console.log(`   Audio URL: ${audioUrl}`);
      message.ack();
    } catch (error) {
      console.error(`\u274C Upload worker failed: ${error.message}`);
      console.error(`   Stack: ${error.stack}`);
      message.retry({ delaySeconds: 120 });
    }
  }
  async uploadToVultr(audioBuffer, metadata) {
    const { S3Client: S3Client2, PutObjectCommand: PutObjectCommand2 } = await Promise.resolve().then(() => (init_dist_es58(), dist_es_exports));
    const s3 = new S3Client2({
      endpoint: this.env.VULTR_STORAGE_ENDPOINT,
      region: "auto",
      credentials: {
        accessKeyId: this.env.VULTR_ACCESS_KEY,
        secretAccessKey: this.env.VULTR_SECRET_KEY
      }
    });
    const key = `podcasts/${metadata.userId}/daily/${Date.now()}.mp3`;
    await s3.send(new PutObjectCommand2({
      Bucket: "civic-pulse-podcasts",
      Key: key,
      Body: audioBuffer,
      ContentType: "audio/mpeg",
      CacheControl: "public, max-age=31536000",
      Metadata: {
        userId: metadata.userId,
        briefId: metadata.jobId,
        generatedAt: metadata.createdAt
      }
    }));
    return `${this.env.VULTR_CDN_URL}/${key}`;
  }
  async saveBriefToDatabase(jobId, audioUrl, metadata) {
    const duration = 300;
    const query = `
      INSERT INTO briefs (
        id, user_id, type, audio_url, transcript,
        written_digest, policy_areas, duration, created_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, datetime('now'))
    `;
    await this.env.HAKIVO_DB.prepare(query).bind(
      jobId,
      metadata.userId,
      "daily",
      audioUrl,
      JSON.stringify({ status: "generated" }),
      "Brief generated successfully",
      JSON.stringify(metadata.policyInterests),
      duration
    ).run();
    return jobId;
  }
};

// <stdin>
var stdin_default = upload_worker_default;
export {
  cors,
  stdin_default as default
};
